{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>NUREMICS is an open-source Python framework for developing software-grade scientific workflows.</p> <p>\ud83e\udde0 Code like a scientist \u2014 build like an engineer. \ud83e\udde9 Modular workflows \u2014 no more tangled scripts. \ud83e\uddea Parametric exploration \u2014 configuration over code. \ud83d\udcbe Full traceability \u2014 everything written to disk. \ud83d\udee0\ufe0f Industrial mindset \u2014 R&amp;D speed, software rigor.</p>      Getting Started         Handbook         Join the community"},{"location":"#foreword","title":"Foreword","text":"<p>The NUREMICS project is organized into two complementary repositories:</p> <ul> <li> <p><code>nuremics</code>: This repository is the core Python library. It provides the foundational components to create modular and extensible software workflows.</p> </li> <li> <p><code>nuremics-labs</code>: This repository contains examples of end-user applications built using the NUREMICS framework. It is intended to be forked by developers to initiate their own <code>nuremics-labs</code> project and build custom scientific applications tailored to their specific use cases.</p> </li> </ul> <p>Developers are thus encouraged to treat <code>nuremics</code> as the core engine, and to use <code>nuremics-labs</code> as a starting point for developing and maintaining their own scientific software applications built on top of the NUREMICS framework.</p>"},{"location":"#project-philosophy","title":"Project Philosophy","text":"<p>NUREMICS is built with the ambition of bringing robust software engineering practices into Python-driven scientific research and development.</p> <p>While Python has become the de facto standard for scientific programming, its use in R&amp;D environments is often limited to ad-hoc scripts or notebooks. This leads to critical limitations: unclear definition of inputs, algorithms, and outputs; hard-coded parameters that hinder reproducibility; and inefficient workflows for exploring parameter spaces. As a result, scientific studies are often conducted in a \u201cone-shot\u201d manner, making them difficult to reproduce or extend. Output data is rarely traceable in a structured way, and codebases suffer from poor modularity, limited reusability, and frequent duplication. These challenges are compounded when teams grow, as scripts and notebooks are difficult to scale and maintain collaboratively, slowing down innovation and increasing the risk of undetected errors.</p> <p>In regulated industries where scientific results directly support product development (e.g., MedTech, Biotech, Aerospace), such fragility can have severe consequences. This is also why many of these industries remain hesitant to adopt Python and its powerful open ecosystem, due to concerns about reliability and long-term maintainability.</p> <p>In this landscape, NUREMICS emerges as a unifying framework designed to address these challenges: it provides a rigorous development structure that empowers scientists, engineers, and researchers to deliver high-quality scientific outcomes, and take their research to the next level. By enabling the safe integration of tools from the Python ecosystem, NUREMICS supports the engineering of domain-specific software tailored for scientific exploration and reproducibility, while upholding the discipline and maintainability required in high-stakes industrial environments.</p> <p>Inspired by IEC 62304, a standard originally developed for the engineering of medical device software, NUREMICS promotes structured, layered software development through clearly defined architectural components: systems, items, and units. This organization fosters clarity, modularity, and maintainability, while remaining well-suited to the iterative, exploratory nature of scientific development in Python. Although NUREMICS does not aim for full compliance with IEC 62304, it selectively incorporates its most relevant principles, striking a pragmatic balance between engineering rigor and the agility required in fast-paced research environments.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>Installation proceeds as follows:</p> <ol> <li> <p>Fork and clone the <code>nuremics-labs</code> repository. You have two options to get started:</p> <ul> <li> <p>Option A (recommended): Fork the repo to your own GitHub or GitLab account, then clone your fork. This allows you to modify the code and push your changes to your personal version of the project.</p> <pre><code>    nuremics-labs  \u2192  fork  \u2192  your-labs  \u2192  clone\n</code></pre> </li> <li> <p>Option B (quick start): If you just want to try the framework without making changes, you can simply clone the main repo directly.</p> HTTPSSSH <pre><code>git clone https://github.com/nuremics/nuremics-labs.git\n</code></pre> <pre><code>git clone git@github.com:nuremics/nuremics-labs.git\n</code></pre> </li> </ul> </li> <li> <p>(Optional, but recommended) Create the NUREMICS virtual environment. From the root directory of your cloned repo, use either conda or micromamba to create and install the environment using the provided <code>environment.yml</code> file.</p> <p>- Creation -</p> CondaMicromamba <pre><code>conda create -f environment.yml\n</code></pre> <pre><code>micromamba create -f environment.yml\n</code></pre> <p>- Activation -</p> CondaMicromamba <pre><code>conda activate nrs-env\n</code></pre> <pre><code>micromamba activate nrs-env\n</code></pre> </li> <li> <p>Install NUREMICS with the demo application. Each application in <code>nuremics-labs</code> can be installed independently. You can start by installing the <code>DEMO_APP</code>.</p> <pre><code>pip install .[DEMO_APP]\n</code></pre> <p>This will install both the core <code>nuremics</code> framework and the <code>nuremics-labs</code> demo application.</p> </li> </ol>"},{"location":"getting-started/#run-the-demo","title":"Run the demo","text":"<p>To get hands-on experience with the NUREMICS framework, you'll start by running the <code>DEMO_APP</code> and reproducing the scientific results of the <code>Study_Shape</code> and <code>Study_Velocity</code> studies, as demonstrated in the video below.</p> <p>When first run, a NUREMICS App creates a local workspace on your system, where you configure studies, set input data, and collect results. In this tutorial, instead of setting up from scratch, you'll start with a preconfigured workspace to reproduce the <code>Study_Shape</code> and <code>Study_Velocity</code> studies.</p> <p>Follow these steps:</p> <ol> <li> <p>Download the <code>NUREMICS_Starter</code> archive. Retrieve the preconfigured <code>NUREMICS_Starter</code> archive and unzip it anywhere on your system.</p> <p>\ud83d\udce6 Download NUREMICS_Starter archive</p> </li> <li> <p>Prepare the NUREMICS working directory. Locate the <code>nrs_working_dir</code> folder inside the unzipped archive and move it to any location on your system that is most convenient for you.</p> </li> <li> <p>Prepare the <code>.nuremics</code> directory. Locate the <code>.nuremics</code> folder in the same unzipped archive and place it at the root of your forked/cloned <code>nuremics-labs</code> repo.</p> </li> <li> <p>Set the working directory for <code>DEMO_APP</code>. Edit the <code>\"working_dir\"</code> field in <code>.nuremics/settings.json</code> and set the full path to your local <code>nrs_working_dir</code>.</p> \ud83d\udcc4 <code>nuremics-labs/.nuremics/settings.json</code> <pre><code>{\n    \"default_working_dir\": null,\n    \"apps\": {\n        \"DEMO_APP\": {\n            \"working_dir\": \"path/to/your/nrs_working_dir\",\n            \"studies\": [\n                \"Study_Shape\",\n                \"Study_Velocity\"\n            ]\n        }\n    }\n}\n</code></pre> </li> <li> <p>Run the <code>DEMO_APP</code>. From the <code>nuremics-labs/src/labs/apps/general/DEMO_APP</code> folder, run the App.</p> <pre><code>python src/labs/apps/general/DEMO_APP/system.py\n</code></pre> <p>This will launch both studies and store results in <code>nrs_working_dir/DEMO_APP</code>.</p> </li> </ol>"},{"location":"getting-started/#play-with-it","title":"Play with it","text":"<p>Now that you've successfully run the <code>DEMO_APP</code> and reproduced the scientific results of the <code>Study_Shape</code> and <code>Study_Velocity</code> studies, let's play with it!</p>"},{"location":"getting-started/#skip-a-study","title":"Skip a study","text":"<p>Want to skip the execution of a specific study when running your App? Set its <code>\"execute\"</code> field to <code>false</code> in the <code>studies.json</code> file.</p> \ud83d\udcc4 <code>nrs_working_dir/DEMO_APP/studies.json</code> <pre><code>{\n    \"Study_Shape\": {\n        \"execute\": false,\n        ...\n    },\n    \"Study_Velocity\": {\n        \"execute\": true,\n        ...\n    }\n}\n</code></pre>"},{"location":"getting-started/#skip-a-process","title":"Skip a process","text":"<p>Want to skip the execution of a specific process (Proc) within a study? Set its <code>\"execute\"</code> field to <code>false</code> in the <code>process.json</code> file.</p> \ud83d\udcc4 <code>nrs_working_dir/DEMO_APP/Study_Velocity/process.json</code> <pre><code>{\n    \"PolygonGeometryProc\": {\n        \"execute\": false,\n        \"silent\": false\n    },\n    \"ProjectileModelProc\": {\n        \"execute\": true,\n        \"silent\": false\n    },\n    \"TrajectoryAnalysisProc\": {\n        \"execute\": true,\n        \"silent\": false\n    }\n}\n</code></pre>"},{"location":"getting-started/#silent-a-process","title":"Silent a process","text":"<p>Want a specific process (Proc) to be executed in silent mode within a study? Set its <code>\"silent\"</code> field to <code>true</code> in the <code>process.json</code> file.</p> \ud83d\udcc4 <code>nrs_working_dir/DEMO_APP/Study_Velocity/process.json</code> <pre><code>{\n    \"PolygonGeometryProc\": {\n        \"execute\": false,\n        \"silent\": false\n    },\n    \"ProjectileModelProc\": {\n        \"execute\": true,\n        \"silent\": true\n    },\n    \"TrajectoryAnalysisProc\": {\n        \"execute\": true,\n        \"silent\": false\n    }\n}\n</code></pre>"},{"location":"getting-started/#skip-an-experiment","title":"Skip an experiment","text":"<p>Want to skip the execution of a specific experiment in a study? Set the value of the <code>EXECUTE</code> flag to <code>0</code> in the <code>inputs.csv</code> file for the experiment you want to skip.</p> \ud83d\udcc4 <code>nrs_working_dir/DEMO_APP/Study_Velocity/inputs.csv</code> <pre><code>ID,EXECUTE\nTest1,1\nTest2,0\nTest3,1\n</code></pre>"},{"location":"getting-started/#run-a-new-experiment","title":"Run a new experiment","text":"<p>Want to run a new experiment in a study? Add a new line with a unique <code>ID</code> to the <code>inputs.csv</code> file.</p> \ud83d\udcc4 <code>nrs_working_dir/DEMO_APP/Study_Velocity/inputs.csv</code> <pre><code>ID,EXECUTE\nTest1,1\nTest2,0\nTest3,1\nMyExp,1\n</code></pre> <p>Then run the App, which will automatically generate the corresponding input folder where you must upload the required <code>velocity.json</code> file.</p> \ud83d\udcc4 <code>nrs_working_dir/DEMO_APP/Study_Velocity/0_inputs/0_datasets/MyExp/velocity.json</code> <pre><code>{\n    \"v0\": 15.0,\n    \"angle\": 60.0\n}\n</code></pre>"},{"location":"getting-started/#modify-analysis-settings","title":"Modify analysis settings","text":"<p>Want to customize the overall analysis of experiment results for a given study? Use the <code>analysis.json</code> file to control how each one is handled.</p> \ud83d\udcc4 <code>nrs_working_dir/DEMO_APP/Study_Velocity/analysis.json</code> <pre><code>{\n    \"points_coordinates.csv\": {},\n    \"polygon_shape.png\": {},\n    \"comparison\": {\n        \"Test1\": {\n            \"add\": true,\n            \"color\": \"red\",\n            \"linestyle\": \"None\",\n            \"linewidth\": 2.0,\n            \"marker\": \"D\",\n            \"markersize\": 8,\n            \"markevery\": 20,\n            \"label\": \"Model\"\n        },\n        \"Test2\": {\n            \"add\": true,\n            \"color\": \"limegreen\",\n            \"linestyle\": \"None\",\n            \"linewidth\": 2.0,\n            \"marker\": \"v\",\n            \"markersize\": 10,\n            \"markevery\": 15,\n            \"label\": \"Model\"\n        },\n        \"Test3\": {\n            \"add\": true,\n            \"color\": \"dodgerblue\",\n            \"linestyle\": \"None\",\n            \"linewidth\": 2.0,\n            \"marker\": \"X\",\n            \"markersize\": 8,\n            \"markevery\": 20,\n            \"label\": \"Model\"\n        },\n        \"MyExp\": {\n            \"add\": true,\n            \"color\": \"fuchsia\",\n            \"linestyle\": \"None\",\n            \"linewidth\": 2.0,\n            \"marker\": \"o\",\n            \"markersize\": 8,\n            \"markevery\": 20,\n            \"label\": \"Model\"\n        }\n    },\n    \"overall_comparisons.png\": {}\n}\n</code></pre>  You're now ready to dive into NUREMICS\ud83e\uddec       Handbook"},{"location":"build-in-public/","title":"Build In Public","text":"<p>Behind the NUREMICS framework lies a growing ecosystem dedicated to empowering the full spectrum of Numerical Sciences.</p> <p>This Build In Public section brings that mission to life: we develop, in full transparency, a suite of open, modular NUREMICS components designed for diverse fields of Numerical Sciences.</p> <p>Each topic reflects a focused deep-dive into a specific branch of the Numerical Sciences, shaped by curiosity, community feedback, and a commitment to share every step of the journey.</p> <p>Why Build In Public?</p> <ul> <li>To democratize access to high-quality scientific software.</li> <li>To showcase the diversity of numerical workflows and applications.</li> <li>To foster collaboration with engineers, researchers, and developers.</li> <li>To build a community around shared tools and reusable components.</li> </ul> <p>Follow. Engage. Contribute. Each topic has its own dedicated page and Discord channel, where you can follow progress, test components, share feedback, or contribute directly.</p>  Ready to shape the future of Numerical Sciences together?       Join the Community"},{"location":"build-in-public/#topics","title":"Topics","text":"<ul> <li>Computational Modeling &amp; Simulation (CM&amp;S)</li> </ul>"},{"location":"build-in-public/cms/","title":"Computational Modeling &amp; Simulation (CM&amp;S)","text":"<p>This topic focuses on the design and implementation of NUREMICS components dedicated to Computational Modeling &amp; Simulation (CM&amp;S) workflows:</p> <ul> <li>Geometry creation: Build, import, or manipulate a geometric model \u2014 from basic primitive shapes to complex CAD (Computer-Aided Design) assemblies.</li> <li>Physical labeling: Translate a geometric model into physical model \u2014 label volumes, surfaces, edges, and vertices of interest, then assign physical entities, material properties, and boundary conditions.</li> <li>Mesh generation: Discretize a geometric model into mesh \u2014 generating nodes and elements (e.g., tetrahedra, hexahedra, triangles, etc.) that represent the shapes for numerical analysis.</li> <li>Physical data mapping: Transfer physical labels from a geometric model onto the associated mesh \u2014 ensuring the mesh nodes and elements carry out the necessary physical information.</li> <li>Solver resolution: Compute the numerical solution of a physical problem \u2014 applying appropriate numerical methods to solve constitutive equations on the mesh and simulate system behavior.</li> <li>Post-processing &amp; Visualization: Extract and visualize raw simulation results \u2014 turning numerical outputs into interpretable visual formats like plots, maps, and animations.</li> <li>Data Analysis &amp; Interpretation: Interpret and evaluate processed data \u2014 performing comparisons, derived calculations, and decision-making based on simulation outcomes.</li> </ul>  Take part of the discussions on the Discord channel <code>#modeling-and-simulation</code>      Join the Community"},{"location":"build-in-public/cms/#use-cases","title":"Use Cases","text":"<ul> <li>Cantilever subjected to end shear force</li> </ul>"},{"location":"build-in-public/cms/cantilever-shear/","title":"Cantilever subjected to end shear force","text":""},{"location":"build-in-public/cms/cantilever-shear/#use-case","title":"Use Case","text":"<p>This is a classical benchmark in Computational Structural Mechanics (CSM), focusing on the simulation of a beam structure fixed at one end and loaded by a shear force at the other end.</p> <p>This test case is extracted from the scientific article by Sze et al. 2004, which compiles and tabulates detailed reference solutions for a series of well-known non-linear benchmark problems in shell finite element analysis. The reference solution of the present test case was obtained using the commercial solver Abaqus and its S4R four-node shell elements, with reduced integration and hourglass control.</p> Figure 1 (extracted from      Sze et al. 2004):     (a) Cantilever subjected to end shear force. (b) Load\u2013deflection curves for cantilever subjected to end shear force. (c) The deformed 16 \u00d7 1 mesh under the maximum force.    Table 1 (extracted from      Sze et al. 2004):     Horizontal and vertical tip deflections for the cantilever loaded with end shear force.    <p>The purpose of the present use case is thus to implement a custom NUREMICS App specifically tailored to reproduce this benchmark simulation and to compare the obtained results with the published reference solution.</p>"},{"location":"handbook/","title":"Handbook","text":"<p>The software architecture of NUREMICS is illustrated in the diagram below. It follows the layered structure recommended by the IEC 62304 standard, distinguishing between software systems, software items, and software units. This representation provides a clear, high-level view of how the different software components of the project are organized, and how they interact within a structured yet flexible development framework. It also highlights the relationship between the core framework (<code>nuremics</code>) and its domain-specific applications (<code>nuremics-labs</code>), emphasizing the modular and extensible nature of the overall architecture.</p> <p>In the context of NUREMICS:</p> <ul> <li> <p>A software unit corresponds to a single, testable function. It is the smallest building block of logic.</p> </li> <li> <p>A software item typically takes the form of a Python class that encapsulates related functions (units) to serve a specific purpose.</p> </li> <li> <p>A software system refers to a complete application designed to be executed by an end-user, replacing traditional scripts or notebooks.</p> </li> </ul> <p></p> <p>In practice, the core framework <code>nuremics</code> is composed of three foundational software items:</p> <ul> <li> <p>The <code>Process</code> class defines a generic process component. It provides a flexible base structure that can be extended to implement domain-specific processes within <code>nuremics-labs</code>.</p> </li> <li> <p>The <code>Workflow</code> class orchestrates the execution of multiple processes in a defined sequential order. It encapsulates the coordination logic and manages the progression of tasks throughout the workflow.</p> </li> <li> <p>The <code>Application</code> class is the top-level component. It instantiates and executes a workflow, acting as the main entry point for any end-user application developed within <code>nuremics-labs</code>.</p> </li> </ul> <p>In <code>nuremics-labs</code>, two main types of software components are developed to build domain-specific applications:</p> <ul> <li> <p>Procs (software items) \u2014 such as <code>Proc1, Proc2, ..., ProcX</code> \u2014 are implemented by subclassing the core <code>Process</code> class. Each Proc is defined as a class that encapsulates several functions (software units), which represent elementary operations (Ops) executed sequentially within the <code>__call__</code> method of the Proc. This design enables the creation of independent, reusable Procs that can be executed on their own or integrated into larger workflows.</p> </li> <li> <p>Apps (software systems) \u2014 such as <code>APP1, APP2, ..., APPX</code> \u2014 are the end-user-facing software applications. They import and assemble the required Procs, executing them in a defined order through the <code>Workflow</code> class, by instantiating the <code>Application</code> class. This modular architecture promotes flexibility and reusability, allowing the same Procs to be used across multiple Apps tailored to different scientific purposes.</p> </li> </ul>  Explore NUREMICS in:       Theory         Practice"},{"location":"handbook/practice/","title":"Practice","text":""},{"location":"handbook/practice/#use-app","title":"Use App","text":"<p>This section walks you through the usage of a NUREMICS App from the end-user's perspective. We will demonstrate how to interact with a ready-to-use App, including how to design studies, define experiments, provide inputs, run the App, and retrieve the expected outputs.</p> <p>When launching the App, NUREMICS first provides the following terminal feedback:</p> <ul> <li>A visual banner indicating the launch of a NUREMICS App.</li> <li>A structured overview of the assembled workflow, with its constitutive Procs and Ops, and their order of execution within the App workflow.</li> <li>A summary of the App's I/O interface. This summary includes all declared user parameters (<code>\"user_params\"</code>) and user paths (<code>\"user_paths\"</code>) required as inputs, along with the corresponding output files and folders that the App will generate. It serves as an explicit interface contract, allowing you to understand what data you need to provide and what results to expect.</li> </ul> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>                      ___\n                     /\\  \\                      ___\n     ___            /::\\  \\        ___         /\\  \\\n    /\\__\\          /:/\\:\\  \\      /\\__\\       /::\\  \\\n   /::|  |        /::\\~\\:\\  \\    /::|  |     /:/\\:\\  \\\n  /:|:|  |       /:/\\:\\ \\:\\__\\  /:|:|  |    /:/  \\:\\  \\\n /:/|:|  |__     \\/_|::\\/:/  / /:/|:|__|__ /:/__/ \\:\\__\\\n/:/ |:| /\\__\\  ___  |:|::/  / /:/ |::::\\__\\\\:\\  \\  \\/__/\n\\/__|:|/:/  / /\\__\\ |:|\\/__/  \\/__/~~/:/  / \\:\\  \\\n    |:/:/  / /:/  / |:|  |  ___     /:/  /   \\:\\  \\\n    |::/  / /:/  /   \\|__| /\\  \\   /:/  / ___ \\:\\__\\ ___\n    /:/  / /:/  /  ___    /::\\  \\ /:/  / /\\  \\ \\/__//\\  \\\n    \\/__/ /:/__/  /\\__\\  /:/\\:\\  \\\\/__/  \\:\\  \\    /::\\  \\\n          \\:\\  \\ /:/  / /::\\~\\:\\  \\      /::\\__\\  /:/\\ \\  \\\n           \\:\\  /:/  / /:/\\:\\ \\:\\__\\  __/:/\\/__/ _\\:\\~\\ \\  \\\n            \\:\\/:/  /  \\:\\~\\:\\ \\/__/ /\\/:/  /   /\\ \\:\\ \\ \\__\\\n             \\::/  /    \\:\\ \\:\\__\\   \\::/__/    \\:\\ \\:\\ \\/__/\n              \\/__/      \\:\\ \\/__/    \\:\\__\\     \\:\\ \\:\\__\\\n                          \\:\\__\\       \\/__/      \\:\\/:/  /\n                           \\/__/                   \\::/  /\n                                                    \\/__/\n&gt; APPLICATION &lt;\n\n| Workflow |\nDEMO_APP_____\n             |_____PolygonGeometryProc_____\n             |                             |_____generate_polygon_shape\n             |                             |_____plot_polygon_shape\n             |\n             |_____ProjectileModelProc_____\n             |                             |_____simulate_projectile_motion\n             |                             |_____calculate_analytical_trajectory\n             |                             |_____compare_model_vs_analytical_trajectories\n             |\n             |_____TrajectoryAnalysisProc_____\n                                              |_____plot_overall_model_vs_theory\n\n&gt; INPUTS &lt;\n\n| User Parameters |\n&gt; nb_sides (int)\n&gt; gravity (float)\n&gt; mass (float)\n\n| User Paths |\n&gt; plot_title.txt\n&gt; velocity.json\n&gt; configs\n\n&gt; OUTPUTS &lt;\n\n&gt; points_coordinates.csv\n&gt; polygon_shape.png\n&gt; comparison\n&gt; overall_comparisons.png\n</code></pre></p>"},{"location":"handbook/practice/#specify-working-directory","title":"Specify Working Directory","text":"<p>If this is your first time launching a NUREMICS App, NUREMICS will prompt you to specify the working directory (<code>\"working_dir\"</code>) for the App. This directory serves as the root location where all input/output data, logs, and results will be stored.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>(X) Please define DEMO_APP \"working_dir\" in file :\n&gt; .../nuremics-labs/.nuremics/settings.json\n</code></pre></p> <p>As indicated in the terminal message, you must define this path in the <code>settings.json</code> file located in the <code>.nuremics</code> folder. This folder should reside at the root of your <code>nuremics-labs</code> repository.</p> \ud83d\udcc4<code>nuremics-labs/.nuremics/settings.json</code> <pre><code>{\n    \"default_working_dir\": null,\n    \"apps\": {\n        \"DEMO_APP\": {\n            \"working_dir\": \"path/to/your/app/working_dir\",\n            \"studies\": []\n        }\n    }\n}\n</code></pre> <p>If you've already launched a NUREMICS App before, but this is your first time launching this specific App, NUREMICS may have already registered a <code>default_working_dir</code> in the <code>settings.json</code> file based on a previous App. In that case, it will suggest using this same directory as the <code>\"working_dir\"</code> for the current App.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>(!) Found \"default_working_dir\": path/to/your/previous/app/working_dir\nAccept it as \"working_dir\" for DEMO_APP: [Y/n]\n</code></pre></p> <p>You can either accept the proposed path by pressing <code>Y</code>, or reject it with <code>n</code> and manually define a new one by editing the <code>settings.json</code> file.</p> <p>A new folder named after the App is then automatically generated under the specified <code>\"working_dir\"</code>. This folder acts as the root container for all the execution-related content generated by the App.</p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/ \u2795 #generated\n</code></pre></p>"},{"location":"handbook/practice/#declare-studies","title":"Declare Studies","text":"<p>NUREMICS then prompts you to declare the different studies you want to carry out with the App.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; STUDIES &lt;\n\n(X) Please declare at least one study in file :\n&gt; .../nuremics-labs/.nuremics/settings.json\n</code></pre></p> <p>This must be declared in the same <code>settings.json</code> file located at the root of your <code>nuremics-labs</code> repository, as a list of identifiers corresponding to the different studies you want to carry out. You can declare as many studies as needed, each representing a self-contained parametric study.</p> \ud83d\udcc4<code>nuremics-labs/.nuremics/settings.json</code> <pre><code>{\n    \"default_working_dir\": null,\n    \"apps\": {\n        \"DEMO_APP\": {\n            \"working_dir\": \"path/to/your/app/working_dir\",\n            \"studies\": [\n                \"Study_Shape\",\n                \"Study_Velocity\"\n            ]\n        }\n    }\n}\n</code></pre> <p>A <code>studies.json</code> file is then generated inside the App's <code>\"working_dir\"</code>. This file serves as a centralized configuration hub for all declared studies.</p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u2514\u2500\u2500 studies.json \u2795 #generated\n</code></pre></p>"},{"location":"handbook/practice/#configure-studies","title":"Configure Studies","text":"<p>NUREMICS then prompts you to configure the first study that you previously declared.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; STUDIES &lt;\n\n| Study_Shape |\n(X) nb_sides not configured.\n(X) gravity not configured.\n(X) mass not configured.\n(X) plot_title.txt not configured.\n(X) velocity.json not configured.\n(X) configs not configured.\n\n(X) Please configure file :\n&gt; .../DEMO_APP/studies.json\n</code></pre></p> <p>You must now complete the <code>studies.json</code> file by specifying, for each input, whether it should remain fixed (<code>false</code>) or be allowed to vary (<code>true</code>) across the experiments that will later be defined within the study.</p> \ud83d\udcc4<code>&lt;working_dir&gt;/DEMO_APP/studies.json</code> <pre><code>{\n    \"Study_Shape\": {\n        \"execute\": true,\n        \"user_params\": {\n            \"nb_sides\": true,\n            \"gravity\": false,\n            \"mass\": false\n        },\n        \"user_paths\": {\n            \"plot_title.txt\": false,\n            \"velocity.json\": false,\n            \"configs\": false\n        }\n    },\n    \"Study_Velocity\": {\n        \"execute\": true,\n        \"user_params\": {\n            \"nb_sides\": null,\n            \"gravity\": null,\n            \"mass\": null\n        },\n        \"user_paths\": {\n            \"plot_title.txt\": null,\n            \"velocity.json\": null,\n            \"configs\": null\n        }\n    }\n}\n</code></pre> <p>NUREMICS then prompts that the first study is properly configured, but indicates that the second declared study still requires configuration.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; STUDIES &lt;\n\n| Study_Shape |\n(V) nb_sides is variable.\n(V) gravity is fixed.\n(V) mass is fixed.\n(V) plot_title.txt is fixed.\n(V) velocity.json is fixed.\n(V) configs is fixed.\n\n| Study_Velocity |\n(X) nb_sides not configured.\n(X) gravity not configured.\n(X) mass not configured.\n(X) plot_title.txt not configured.\n(X) velocity.json not configured.\n(X) configs not configured.\n\n(X) Please configure file :\n&gt; .../DEMO_APP/studies.json\n</code></pre></p> <p>The same work must therefore be done in the <code>studies.json</code> file to properly configure the study.</p> \ud83d\udcc4<code>&lt;working_dir&gt;/DEMO_APP/studies.json</code> <pre><code>{\n    \"Study_Shape\": {\n        \"execute\": true,\n        \"user_params\": {\n            \"nb_sides\": true,\n            \"gravity\": false,\n            \"mass\": false\n        },\n        \"user_paths\": {\n            \"plot_title.txt\": false,\n            \"velocity.json\": false,\n            \"configs\": false\n        }\n    },\n    \"Study_Velocity\": {\n        \"execute\": true,\n        \"user_params\": {\n            \"nb_sides\": false,\n            \"gravity\": false,\n            \"mass\": false\n        },\n        \"user_paths\": {\n            \"plot_title.txt\": false,\n            \"velocity.json\": true,\n            \"configs\": false\n        }\n    }\n}\n</code></pre> <p>NUREMICS finally prompts that all declared studies are properly configured.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; STUDIES &lt;\n\n| Study_Shape |\n(V) nb_sides is variable.\n(V) gravity is fixed.\n(V) mass is fixed.\n(V) plot_title.txt is fixed.\n(V) velocity.json is fixed.\n(V) configs is fixed.\n\n| Study_Velocity |\n(V) nb_sides is fixed.\n(V) gravity is fixed.\n(V) mass is fixed.\n(V) plot_title.txt is fixed.\n(V) velocity.json is variable.\n(V) configs is fixed.\n</code></pre></p> <p>A dedicated folder for each study is then generated inside the App's <code>\"working_dir\"</code>.</p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u251c\u2500\u2500 studies.json\n    \u251c\u2500\u2500 Study_Shape/    \u2795 #generated\n    \u2514\u2500\u2500 Study_Velocity/ \u2795 #generated\n</code></pre></p>"},{"location":"handbook/practice/#set-input-data","title":"Set Input Data","text":"<p>Each study folder inside the App's <code>\"working_dir\"</code> now contains an initialized input database that you must complete to run your first experiments.</p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u251c\u2500\u2500 studies.json\n    \u251c\u2500\u2500 Study_Shape/\n    \u2502   \u251c\u2500\u2500 inputs.csv  \u2795 #generated\n    \u2502   \u251c\u2500\u2500 inputs.json \u2795 #generated\n    \u2502   \u2514\u2500\u2500 0_inputs/   \u2795 #generated\n    \u2514\u2500\u2500 Study_Velocity/\n        \u251c\u2500\u2500 inputs.csv  \u2795 #generated\n        \u251c\u2500\u2500 inputs.json \u2795 #generated\n        \u2514\u2500\u2500 0_inputs/   \u2795 #generated\n</code></pre></p> <p>This input database contains:</p> <ul> <li><code>inputs.csv</code>: This is the main file for declaring the experiments you want to run in the study. This is also where you must set the input parameters defined as variable <code>\"user_params\"</code>.</li> <li><code>inputs.json</code>: In this file, you must set the input parameters defined as fixed <code>\"user_params\"</code>.</li> <li><code>0_inputs/</code>: This folder must contain the input files and/or folders defined as <code>\"user_paths\"</code> (either fixed or variable).</li> </ul> <p>NUREMICS first prompts you to set the fixed input data for the first declared study.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; SETTINGS &lt;\n\n| Study_Shape |\n&gt; Common : (X) gravity (X) mass (X) plot_title.txt (X) velocity.json (X) configs\n\n(X) Please set inputs :\n&gt; .../DEMO_APP/Study_Shape/inputs.json\n&gt; .../DEMO_APP/Study_Shape/0_inputs/plot_title.txt\n&gt; .../DEMO_APP/Study_Shape/0_inputs/velocity.json\n&gt; .../DEMO_APP/Study_Shape/0_inputs/configs\n</code></pre></p> \ud83d\udcc4<code>&lt;working_dir&gt;/DEMO_APP/Study_Shape/inputs.json</code> <pre><code>{\n    \"gravity\": -9.81,\n    \"mass\": 0.1\n}\n</code></pre> \ud83d\udcc4<code>&lt;working_dir&gt;/DEMO_APP/Study_Shape/0_inputs/plot_title.txt</code> <pre><code>2D polygon shape\n</code></pre> \ud83d\udcc4<code>&lt;working_dir&gt;/DEMO_APP/Study_Shape/0_inputs/velocity.json</code> <pre><code>{\n    \"v0\": 15.0,\n    \"angle\": 45.0\n}\n</code></pre> \ud83d\udcc1<code>&lt;working_dir&gt;/DEMO_APP/Study_Shape/0_inputs/configs/</code>\ud83d\udcc4<code>solver_config.json</code>\ud83d\udcc4<code>display_config.json</code> <pre><code>{\n    \"timestep\": 0.01\n}\n</code></pre> <pre><code>{\n    \"fps\": 60,\n    \"size\": 700\n}\n</code></pre> <p>All fixed input data have now been completed within the input database of the study.</p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u251c\u2500\u2500 studies.json\n    \u251c\u2500\u2500 Study_Shape/\n    \u2502   \u251c\u2500\u2500 inputs.csv\n    \u2502   \u251c\u2500\u2500 inputs.json\n    \u2502   \u2514\u2500\u2500 0_inputs/\n    \u2502       \u251c\u2500\u2500 plot_title.txt          \u2b07\ufe0f #uploaded\n    \u2502       \u251c\u2500\u2500 velocity.json           \u2b07\ufe0f #uploaded\n    \u2502       \u2514\u2500\u2500 configs/                \u2b07\ufe0f #uploaded\n    \u2502           \u251c\u2500\u2500 solver_config.json  \u2b07\ufe0f #uploaded\n    \u2502           \u2514\u2500\u2500 display_config.json \u2b07\ufe0f #uploaded\n    \u2514\u2500\u2500 Study_Velocity/\n        \u251c\u2500\u2500 inputs.csv\n        \u251c\u2500\u2500 inputs.json\n        \u2514\u2500\u2500 0_inputs/\n</code></pre></p> <p>NUREMICS then prompts that all fixed input data have been properly set, but indicates that datasets of variable input data still need to be declared in order to define the experiments to run.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; SETTINGS &lt;\n\n| Study_Shape |\n&gt; Common : (V) gravity (V) mass (V) plot_title.txt (V) velocity.json (V) configs\n\n(X) Please declare at least one experiment in file :\n&gt; .../DEMO_APP/Study_Shape/inputs.csv\n</code></pre></p> <p>Let's first declare three experiments in the <code>inputs.csv</code> file.</p> \ud83d\udcc4 <code>&lt;working_dir&gt;/DEMO_APP/Study_Shape/inputs.csv</code> <pre><code>ID,nb_sides,EXECUTE\nTest1,,\nTest2,,\nTest3,,\n</code></pre> <p>NUREMICS now prompts that the three experiments have been declared, but is waiting for the variable input data to be set for each of them.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code> &gt; SETTINGS &lt;\n\n| Study_Shape |\n&gt; Common : (V) gravity (V) mass (V) plot_title.txt (V) velocity.json (V) configs\n&gt; Test1 : (X) nb_sides\n&gt; Test2 : (X) nb_sides\n&gt; Test3 : (X) nb_sides\n\n(X) Please set inputs :\n&gt; .../DEMO_APP/Study_Shape/inputs.csv\n</code></pre></p> <p>Let\u2019s thus set input values for each experiment in the <code>inputs.csv</code> file.</p> \ud83d\udcc4 <code>&lt;working_dir&gt;/DEMO_APP/Study_Shape/inputs.csv</code> <pre><code>ID,nb_sides,EXECUTE\nTest1,3,\nTest2,4,\nTest3,5,\n</code></pre> <p>NUREMICS finally prompts that all input data are properly set for the study.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; SETTINGS &lt;\n\n| Study_Shape |\n&gt; Common : (V) gravity (V) mass (V) plot_title.txt (V) velocity.json (V) configs\n&gt; Test1 : (V) nb_sides\n&gt; Test2 : (V) nb_sides\n&gt; Test3 : (V) nb_sides\n</code></pre></p> <p>The same work must be done to set the input data for the second declared study.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| Study_Velocity |\n&gt; Common : (X) nb_sides (X) gravity (X) mass (X) plot_title.txt (X) configs\n\n(X) Please set inputs :\n&gt; .../DEMO_APP/Study_Velocity/inputs.json\n&gt; .../DEMO_APP/Study_Velocity/0_inputs/plot_title.txt\n&gt; .../DEMO_APP/Study_Velocity/0_inputs/configs\n</code></pre></p> \ud83d\udcc4<code>&lt;working_dir&gt;/DEMO_APP/Study_Velocity/inputs.json</code> <pre><code>{\n    \"nb_sides\": 5,\n    \"gravity\": -9.81,\n    \"mass\": 0.1\n}\n</code></pre> \ud83d\udcc4<code>&lt;working_dir&gt;/DEMO_APP/Study_Velocity/0_inputs/plot_title.txt</code> <pre><code>2D polygon shape\n</code></pre> \ud83d\udcc1<code>&lt;working_dir&gt;/DEMO_APP/Study_Velocity/0_inputs/configs/</code>\ud83d\udcc4<code>solver_config.json</code>\ud83d\udcc4<code>display_config.json</code> <pre><code>{\n    \"timestep\": 0.01\n}\n</code></pre> <pre><code>{\n    \"fps\": 60,\n    \"size\": 700\n}\n</code></pre> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u251c\u2500\u2500 studies.json\n    \u251c\u2500\u2500 Study_Shape/\n    \u2502   \u251c\u2500\u2500 inputs.csv\n    \u2502   \u251c\u2500\u2500 inputs.json\n    \u2502   \u2514\u2500\u2500 0_inputs/\n    \u2502       \u251c\u2500\u2500 plot_title.txt\n    \u2502       \u251c\u2500\u2500 velocity.json\n    \u2502       \u2514\u2500\u2500 configs/\n    \u2502           \u251c\u2500\u2500 solver_config.json\n    \u2502           \u2514\u2500\u2500 display_config.json\n    \u2514\u2500\u2500 Study_Velocity/\n        \u251c\u2500\u2500 inputs.csv\n        \u251c\u2500\u2500 inputs.json\n        \u2514\u2500\u2500 0_inputs/\n            \u251c\u2500\u2500 plot_title.txt          \u2b07\ufe0f #uploaded\n            \u2514\u2500\u2500 configs/                \u2b07\ufe0f #uploaded\n                \u251c\u2500\u2500 solver_config.json  \u2b07\ufe0f #uploaded\n                \u2514\u2500\u2500 display_config.json \u2b07\ufe0f #uploaded\n</code></pre></p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| Study_Velocity |\n&gt; Common : (V) nb_sides (V) gravity (V) mass (V) plot_title.txt (V) configs\n\n(X) Please declare at least one experiment in file :\n&gt; .../DEMO_APP/Study_Velocity/inputs.csv\n</code></pre></p> \ud83d\udcc4 <code>&lt;working_dir&gt;/DEMO_APP/Study_Velocity/inputs.csv</code> <pre><code>ID,EXECUTE\nTest1,\nTest2,\nTest3,\n</code></pre> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| Study_Velocity |\n&gt; Common : (V) nb_sides (V) gravity (V) mass (V) plot_title.txt (V) configs\n&gt; Test1 : (X) velocity.json\n&gt; Test2 : (X) velocity.json\n&gt; Test3 : (X) velocity.json\n\n(X) Please set inputs :\n&gt; .../DEMO_APP/Study_Velocity/0_inputs/0_datasets/Test1/velocity.json\n&gt; .../DEMO_APP/Study_Velocity/0_inputs/0_datasets/Test2/velocity.json\n&gt; .../DEMO_APP/Study_Velocity/0_inputs/0_datasets/Test3/velocity.json\n</code></pre></p> \ud83d\udcc1<code>&lt;working_dir&gt;/DEMO_APP/Study_Velocity/0_inputs/0_datasets/Test1</code>\ud83d\udcc4<code>velocity.json</code>\ud83d\udcc1<code>Test2</code>\ud83d\udcc4<code>velocity.json</code>\ud83d\udcc1<code>Test3</code>\ud83d\udcc4<code>velocity.json</code> <pre><code>{\n    \"v0\": 15.0,\n    \"angle\": 45.0\n}\n</code></pre> <pre><code>{\n    \"v0\": 20.0,\n    \"angle\": 45.0\n}\n</code></pre> <pre><code>{\n    \"v0\": 20.0,\n    \"angle\": 60.0\n}\n</code></pre> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u251c\u2500\u2500 studies.json\n    \u251c\u2500\u2500 Study_Shape/\n    \u2502   \u251c\u2500\u2500 inputs.csv\n    \u2502   \u251c\u2500\u2500 inputs.json\n    \u2502   \u2514\u2500\u2500 0_inputs/\n    \u2502       \u251c\u2500\u2500 plot_title.txt\n    \u2502       \u251c\u2500\u2500 velocity.json\n    \u2502       \u2514\u2500\u2500 configs/\n    \u2502           \u251c\u2500\u2500 solver_config.json\n    \u2502           \u2514\u2500\u2500 display_config.json\n    \u2514\u2500\u2500 Study_Velocity/\n        \u251c\u2500\u2500 inputs.csv\n        \u251c\u2500\u2500 inputs.json\n        \u2514\u2500\u2500 0_inputs/\n            \u251c\u2500\u2500 plot_title.txt\n            \u251c\u2500\u2500 configs/\n            \u2502   \u251c\u2500\u2500 solver_config.json\n            \u2502   \u2514\u2500\u2500 display_config.json\n            \u2514\u2500\u2500 0_datasets/           \u2795 #generated\n                \u251c\u2500\u2500 Test1/            \u2795 #generated\n                \u2502   \u2514\u2500\u2500 velocity.json \u2b07\ufe0f #uploaded\n                \u251c\u2500\u2500 Test2/            \u2795 #generated\n                \u2502   \u2514\u2500\u2500 velocity.json \u2b07\ufe0f #uploaded\n                \u2514\u2500\u2500 Test3/            \u2795 #generated\n                    \u2514\u2500\u2500 velocity.json \u2b07\ufe0f #uploaded\n</code></pre></p> <p>NUREMICS finally prompts that all input data are properly set for all declared studies.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; SETTINGS &lt;\n\n| Study_Shape |\n&gt; Common : (V) gravity (V) mass (V) plot_title.txt (V) velocity.json (V) configs\n&gt; Test1 : (V) nb_sides\n&gt; Test2 : (V) nb_sides\n&gt; Test3 : (V) nb_sides\n\n| Study_Velocity |\n&gt; Common : (V) nb_sides (V) gravity (V) mass (V) plot_title.txt (V) configs\n&gt; Test1 : (V) velocity.json\n&gt; Test2 : (V) velocity.json\n&gt; Test3 : (V) velocity.json\n</code></pre></p>"},{"location":"handbook/practice/#get-results","title":"Get Results","text":"<p>At this stage, NUREMICS is ready to run all the defined studies and generate the corresponding results.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; RUNNING &lt;\n\n| Study_Shape | PolygonGeometryProc | Test1 |\n&gt; n_sides = 3\n&gt; radius = 0.5\n&gt; title_file = .../DEMO_APP/Study_Shape/0_inputs/plot_title.txt\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Shape | PolygonGeometryProc | Test2 |\n&gt; n_sides = 4\n&gt; radius = 0.5\n&gt; title_file = .../DEMO_APP/Study_Shape/0_inputs/plot_title.txt\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Shape | PolygonGeometryProc | Test3 |\n&gt; n_sides = 5\n&gt; radius = 0.5\n&gt; title_file = .../DEMO_APP/Study_Shape/0_inputs/plot_title.txt\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Shape | ProjectileModelProc | Test1 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; velocity_file = .../DEMO_APP/Study_Shape/0_inputs/velocity.json\n&gt; configs_folder = .../DEMO_APP/Study_Shape/0_inputs/configs\n&gt; coords_file = .../DEMO_APP/Study_Shape/1_PolygonGeometryProc/Test1/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Shape | ProjectileModelProc | Test2 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; velocity_file = .../DEMO_APP/Study_Shape/0_inputs/velocity.json\n&gt; configs_folder = .../DEMO_APP/Study_Shape/0_inputs/configs\n&gt; coords_file = .../DEMO_APP/Study_Shape/1_PolygonGeometryProc/Test2/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Shape | ProjectileModelProc | Test3 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; velocity_file = .../DEMO_APP/Study_Shape/0_inputs/velocity.json\n&gt; configs_folder = .../DEMO_APP/Study_Shape/0_inputs/configs\n&gt; coords_file = .../DEMO_APP/Study_Shape/1_PolygonGeometryProc/Test3/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Shape | TrajectoryAnalysisProc |\n&gt; comp_folder = comparison\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Velocity | PolygonGeometryProc |\n&gt; n_sides = 5\n&gt; radius = 0.5\n&gt; title_file = .../DEMO_APP/Study_Velocity/0_inputs/plot_title.txt\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Velocity | ProjectileModelProc | Test1 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; configs_folder = .../DEMO_APP/Study_Velocity/0_inputs/configs\n&gt; velocity_file = .../DEMO_APP/Study_Velocity/0_inputs/0_datasets/Test1/velocity.json\n&gt; coords_file = .../DEMO_APP/Study_Velocity/1_PolygonGeometryProc/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Velocity | ProjectileModelProc | Test2 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; configs_folder = .../DEMO_APP/Study_Velocity/0_inputs/configs\n&gt; velocity_file = .../DEMO_APP/Study_Velocity/0_inputs/0_datasets/Test2/velocity.json\n&gt; coords_file = .../DEMO_APP/Study_Velocity/1_PolygonGeometryProc/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Velocity | ProjectileModelProc | Test3 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; configs_folder = .../DEMO_APP/Study_Velocity/0_inputs/configs\n&gt; velocity_file = .../DEMO_APP/Study_Velocity/0_inputs/0_datasets/Test3/velocity.json\n&gt; coords_file = .../DEMO_APP/Study_Velocity/1_PolygonGeometryProc/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Velocity | TrajectoryAnalysisProc |\n&gt; comp_folder = comparison\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n</code></pre></p> <p>You can then access the results in the output database generated by NUREMICS within the App's <code>\"working_dir\"</code>. </p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u251c\u2500\u2500 studies.json\n    \u251c\u2500\u2500 Study_Shape/\n    \u2502   \u251c\u2500\u2500 inputs.csv\n    \u2502   \u251c\u2500\u2500 inputs.json\n    \u2502   \u251c\u2500\u2500 0_inputs/\n    \u2502   \u2502   \u251c\u2500\u2500 plot_title.txt\n    \u2502   \u2502   \u251c\u2500\u2500 velocity.json\n    \u2502   \u2502   \u2514\u2500\u2500 configs/\n    \u2502   \u2502       \u251c\u2500\u2500 solver_config.json\n    \u2502   \u2502       \u2514\u2500\u2500 display_config.json\n    \u2502   \u251c\u2500\u2500 1_PolygonGeometryProc/          \u2795 #generated\n    \u2502   \u2502   \u251c\u2500\u2500 Test1/                      \u2795 #generated\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 points_coordinates.csv  \u2795 #generated\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 polygon_shape.png       \u2795 #generated\n    \u2502   \u2502   \u251c\u2500\u2500 Test2/                      \u2795 #generated\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 points_coordinates.csv  \u2795 #generated\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 polygon_shape.png       \u2795 #generated\n    \u2502   \u2502   \u2514\u2500\u2500 Test3/                      \u2795 #generated\n    \u2502   \u2502       \u251c\u2500\u2500 points_coordinates.csv  \u2795 #generated\n    \u2502   \u2502       \u2514\u2500\u2500 polygon_shape.png       \u2795 #generated\n    \u2502   \u251c\u2500\u2500 2_ProjectileModelProc/          \u2795 #generated\n    \u2502   \u2502   \u251c\u2500\u2500 Test1/                      \u2795 #generated\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 comparison/             \u2795 #generated\n    \u2502   \u2502   \u2502       \u251c\u2500\u2500 results.xlsx        \u2795 #generated\n    \u2502   \u2502   \u2502       \u2514\u2500\u2500 model_vs_theory.png \u2795 #generated\n    \u2502   \u2502   \u251c\u2500\u2500 Test2/                      \u2795 #generated\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 comparison/             \u2795 #generated\n    \u2502   \u2502   \u2502       \u251c\u2500\u2500 results.xlsx        \u2795 #generated\n    \u2502   \u2502   \u2502       \u2514\u2500\u2500 model_vs_theory.png \u2795 #generated\n    \u2502   \u2502   \u2514\u2500\u2500 Test3/                      \u2795 #generated\n    \u2502   \u2502       \u2514\u2500\u2500 comparison/             \u2795 #generated\n    \u2502   \u2502           \u251c\u2500\u2500 results.xlsx        \u2795 #generated\n    \u2502   \u2502           \u2514\u2500\u2500 model_vs_theory.png \u2795 #generated\n    \u2502   \u2514\u2500\u2500 3_TrajectoryAnalysisProc        \u2795 #generated\n    \u2502       \u2514\u2500\u2500 overall_comparisons.png     \u2795 #generated\n    \u2514\u2500\u2500 Study_Velocity/\n        \u251c\u2500\u2500 inputs.csv\n        \u251c\u2500\u2500 inputs.json\n        \u251c\u2500\u2500 0_inputs/\n        \u2502   \u251c\u2500\u2500 plot_title.txt\n        \u2502   \u251c\u2500\u2500 configs/\n        \u2502   \u2502   \u251c\u2500\u2500 solver_config.json\n        \u2502   \u2502   \u2514\u2500\u2500 display_config.json\n        \u2502   \u2514\u2500\u2500 0_datasets/\n        \u2502       \u251c\u2500\u2500 Test1/\n        \u2502       \u2502   \u2514\u2500\u2500 velocity.json\n        \u2502       \u251c\u2500\u2500 Test2/\n        \u2502       \u2502   \u2514\u2500\u2500 velocity.json\n        \u2502       \u2514\u2500\u2500 Test3/\n        \u2502           \u2514\u2500\u2500 velocity.json\n        \u251c\u2500\u2500 1_PolygonGeometryProc/          \u2795 #generated\n        \u2502   \u251c\u2500\u2500 points_coordinates.csv      \u2795 #generated\n        \u2502   \u2514\u2500\u2500 polygon_shape.png           \u2795 #generated\n        \u251c\u2500\u2500 2_ProjectileModelProc/          \u2795 #generated\n        \u2502   \u251c\u2500\u2500 Test1/                      \u2795 #generated\n        \u2502   \u2502   \u2514\u2500\u2500 comparison/             \u2795 #generated\n        \u2502   \u2502       \u251c\u2500\u2500 results.xlsx        \u2795 #generated\n        \u2502   \u2502       \u2514\u2500\u2500 model_vs_theory.png \u2795 #generated\n        \u2502   \u251c\u2500\u2500 Test2/                      \u2795 #generated\n        \u2502   \u2502   \u2514\u2500\u2500 comparison/             \u2795 #generated\n        \u2502   \u2502       \u251c\u2500\u2500 results.xlsx        \u2795 #generated\n        \u2502   \u2502       \u2514\u2500\u2500 model_vs_theory.png \u2795 #generated\n        \u2502   \u2514\u2500\u2500 Test3/                      \u2795 #generated\n        \u2502       \u2514\u2500\u2500 comparison/             \u2795 #generated\n        \u2502           \u251c\u2500\u2500 results.xlsx        \u2795 #generated\n        \u2502           \u2514\u2500\u2500 model_vs_theory.png \u2795 #generated\n        \u2514\u2500\u2500 3_TrajectoryAnalysisProc        \u2795 #generated\n            \u2514\u2500\u2500 overall_comparisons.png     \u2795 #generated\n</code></pre></p>"},{"location":"handbook/practice/#create-app","title":"Create App","text":"<p>Now that we've saw how to use a NUREMICS App as an end-user, it's now time to look under the hood and explore how the App is actually built. This section dives into the developer's side of NUREMICS, exposing how to define, organize, and structure a fully functional App.</p> <p>You'll start by implementing your own Procs, which encapsulate domain-specific logic and computational tasks. Then, you\u2019ll learn how to assemble these building blocks into a fully operational App.</p>"},{"location":"handbook/practice/#implement-procs","title":"Implement Procs","text":"<p>We start by defining the core building blocks of the App to be created: the Procs. Each Proc is a reusable item that encapsulates a specific piece of logic executed within the overall workflow. Internally, this logic can be further decomposed into elementary operations (Ops), implemented as individual functions (units) within the Proc itself.</p> <p>To implement our first Proc, we begin by importing the <code>Process</code> base class from <code>nuremics</code>, which all custom Procs must inherit from. To make this inheritance simple and structured, we also import the <code>attrs</code> library, which helps define clean, data-driven Python classes.</p> <pre><code>import attrs\nfrom nuremics import Process\n</code></pre> <p>We then declare our first Proc as a Python class named <code>PolygonGeometryProc</code>, inheriting from the <code>Process</code> base class. This marks it as a modular item of computation which can be executed within a NUREMICS workflow.</p> <pre><code>import attrs\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n</code></pre> <p>We now declare the input data required by our <code>PolygonGeometryProc</code>, grouped into two categories: Parameters and Paths. Each input is defined using <code>attrs.field()</code> and marked with <code>metadata={\"input\": True}</code>.</p> <p>This metadata is essential: it tells the NUREMICS framework that these attributes are expected as input data, ensuring they are properly tracked and managed throughout the workflow.</p> <pre><code>import attrs\nfrom pathlib import Path\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n\n    # Parameters\n    radius: float = attrs.field(init=False, metadata={\"input\": True})\n    n_sides: int = attrs.field(init=False, metadata={\"input\": True})\n\n    # Paths\n    title_file: Path = attrs.field(init=False, metadata={\"input\": True}, converter=Path)\n</code></pre> <p>In addition to the previously declared input data, a Proc can also define internal variables: attributes used during the execution of its internal logic but not provided as input data.</p> <p>These internal variables, like <code>df_points</code> in our example below, are declared without the <code>metadata={\"input\": True}</code> tag, signaling to the NUREMICS framework that they are not exposed to the workflow and will be set or computed within the Proc itself.</p> <pre><code>import attrs\nimport pandas as pd\nfrom pathlib import Path\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n\n    # Parameters\n    radius: float = attrs.field(init=False, metadata={\"input\": True})\n    n_sides: int = attrs.field(init=False, metadata={\"input\": True})\n\n    # Paths\n    title_file: Path = attrs.field(init=False, metadata={\"input\": True}, converter=Path)\n\n    # Internal\n    df_points: pd.DataFrame = attrs.field(init=False)\n</code></pre> <p>The operations executed by the Proc are finally implemented as elementary functions (Ops), which are then sequentially called within the <code>__call__()</code> method to define the overall logic of the Proc.</p> <pre><code>import attrs\nimport pandas as pd\nfrom pathlib import Path\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n\n    # Parameters\n    radius: float = attrs.field(init=False, metadata={\"input\": True})\n    n_sides: int = attrs.field(init=False, metadata={\"input\": True})\n\n    # Paths\n    title_file: Path = attrs.field(init=False, metadata={\"input\": True}, converter=Path)\n\n    # Internal\n    df_points: pd.DataFrame = attrs.field(init=False)\n\n    def __call__(self):\n        super().__call__()\n\n        self.generate_polygon_shape()\n        self.plot_polygon_shape()\n\n    def generate_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n\n    def plot_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n</code></pre> <p>Note that the Proc should at some point produce output data, typically in the form of files or folders generated during the execution of its Ops. To make these output data trackable by the NUREMICS framework, each must be registered in the <code>self.output_paths</code> dictionary using a label that is unique to the Proc (e.g., <code>\"coords_file\"</code>, <code>\"fig_file\"</code>).</p> <p>Using the dictionary syntax <code>self.output_paths[\"coords_file\"]</code> effectively declares an output variable named <code>coords_file</code>, which will later be instantiated by assigning it a specific file or folder name when integrating the Proc into a broader application workflow.</p> <pre><code>import attrs\nimport pandas as pd\nfrom pathlib import Path\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n\n    # Parameters\n    radius: float = attrs.field(init=False, metadata={\"input\": True})\n    n_sides: int = attrs.field(init=False, metadata={\"input\": True})\n\n    # Paths\n    title_file: Path = attrs.field(init=False, metadata={\"input\": True}, converter=Path)\n\n    # Internal\n    df_points: pd.DataFrame = attrs.field(init=False)\n\n    def __call__(self):\n        super().__call__()\n\n        self.generate_polygon_shape()\n        self.plot_polygon_shape()\n\n    def generate_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n        file = self.output_paths[\"coords_file\"]\n        # &lt;/&gt; Write file &lt;/&gt;\n\n    def plot_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n        file = self.output_paths[\"fig_file\"]\n        # &lt;/&gt; Write file &lt;/&gt;\n</code></pre> <p>Even though Procs are not intended to be executed independently by end-users, they are still designed with the possibility to run out of the box. This allows developers to easily execute them during the development phase or when implementing dedicated unit tests for a specific Proc.</p> <p>In such cases, it is important to set <code>set_inputs=True</code> when instantiating the Proc, to explicitly inform the NUREMICS framework that the input data are being provided manually, outside of any workflow context.</p> <pre><code>import attrs\nimport pandas as pd\nfrom pathlib import Path\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n\n    # Parameters\n    radius: float = attrs.field(init=False, metadata={\"input\": True})\n    n_sides: int = attrs.field(init=False, metadata={\"input\": True})\n\n    # Paths\n    title_file: Path = attrs.field(init=False, metadata={\"input\": True}, converter=Path)\n\n    # Internal\n    df_points: pd.DataFrame = attrs.field(init=False)\n\n    def __call__(self):\n        super().__call__()\n\n        self.generate_polygon_shape()\n        self.plot_polygon_shape()\n\n    def generate_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n        file = self.output_paths[\"coords_file\"]\n        # &lt;/&gt; Write file &lt;/&gt;\n\n    def plot_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n        file = self.output_paths[\"fig_file\"]\n        # &lt;/&gt; Write file &lt;/&gt;\n\nif __name__ == \"__main__\":\n\n    # ================================================================== #\n    #                      USER-DEFINED PARAMETERS                       #\n    #              &gt;&gt;&gt;&gt;&gt; TO BE EDITED BY THE OPERATOR &lt;&lt;&lt;&lt;&lt;              #\n    # ================================================================== #\n\n    # Working directory\n    working_dir = Path(r\"...\")\n\n    # Input parameters\n    radius = 0.5\n    n_sides = 3\n\n    # Input paths\n    title_file = Path(r\"...\") / \"plot_title.txt\"\n\n    # Output paths\n    coords_file = \"points_coordinates.csv\"\n    fig_file = \"polygon_shape.png\"\n\n    # ================================================================== #\n\n    # Go to working directory\n    os.chdir(working_dir)\n\n    # Create dictionary containing input data\n    dict_inputs = {\n        \"radius\": radius,\n        \"n_sides\": n_sides,\n        \"title_file\": title_file,\n    }\n\n    # Create process\n    process = PolygonGeometryProc(\n        dict_inputs=dict_inputs,\n        set_inputs=True,\n    )\n\n    # Define output paths\n    process.output_paths[\"coords_file\"] = coords_file\n    process.output_paths[\"fig_file\"] = fig_file\n\n    # Run process\n    process()\n    process.finalize()\n</code></pre>"},{"location":"handbook/practice/#assemble-procs-into-app","title":"Assemble Procs into App","text":"<p>Most of the development effort has already been carried out when implementing the individual Procs. The next step consists in assembling them into a coherent App, where each Proc is instantiated, connected, and orchestrated to form a complete, executable workflow.</p> <p>We start by defining the name of our App.</p> <pre><code>APP_NAME = \"DEMO_APP\"\n</code></pre> <p>We then import the <code>Application</code> class from <code>nuremics</code>, which serves as the container and manager to define a workflow composed of multiple Procs.</p> <pre><code>from nuremics import Application\n\nAPP_NAME = \"DEMO_APP\"\n</code></pre> <p>We now import two Procs, <code>PolygonGeometryProc</code> and <code>ProjectileModelProc</code>, previously implemented. These will be the building blocks to assemble into our final App.</p> <pre><code>from nuremics import Application\nfrom labs.procs.general.PolygonGeometryProc.item import PolygonGeometryProc\nfrom labs.procs.general.ProjectileModelProc.item import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\n</code></pre> <p>The source code of the App then adopts the structure of a standard Python script, which can both be executed directly or imported as a module. This is achieved by defining a <code>main()</code> function and guarding it with the typical <code>if __name__ == \"__main__\":</code> statement.</p> <pre><code>from nuremics import Application\nfrom procs.general.PolygonGeometryProc.item import PolygonGeometryProc\nfrom procs.general.ProjectileModelProc.item import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\n\ndef main():\n    # Application logic here\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Inside the <code>main()</code> function, we define a list called <code>workflow</code> which contains the sequence of Procs to be executed, in the order specified. This list is made up of dictionaries, where each dictionary describes the assembly characteristics of each individual Proc into the App. This dictionary-based structure offers flexibility to easily add more parameters or options later by simply adding new keys to each dictionary in the workflow.</p> <p>Let's first define the key <code>\"process\"</code> of each dictionary, which specifies the Proc class (previously imported, e.g., <code>PolygonGeometryProc</code> and <code>ProjectileModelProc</code>) to instantiate and execute within the App workflow.</p> <pre><code>from nuremics import Application\nfrom procs.general.PolygonGeometryProc.item import PolygonGeometryProc\nfrom procs.general.ProjectileModelProc.item import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\n\ndef main():\n\n    # --------------- #\n    # Define workflow #\n    # --------------- #\n    workflow = [\n        {\n            \"process\": PolygonGeometryProc,\n        },\n        {\n            \"process\": ProjectileModelProc,\n        },\n    ]\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>We now create an <code>Application</code> object <code>app</code>, which acts as the core engine of our App. This object is instantiated using the previously defined inputs:</p> <ul> <li> <p><code>app_name</code>: the name of the App.</p> </li> <li> <p><code>nuremics_dir</code>: the root directory of your <code>nuremics-labs</code> repository.</p> </li> <li> <p><code>workflow</code>: the ordered list of Procs to run.</p> </li> </ul> <p>Once the <code>Application</code> object is created, calling <code>app()</code> launches the workflow execution of all the defined Procs.</p> <pre><code>import git\nfrom pathlib import Path\nfrom nuremics import Application\nfrom procs.general.PolygonGeometryProc.item import PolygonGeometryProc\nfrom procs.general.ProjectileModelProc.item import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\nrepo = git.Repo(Path(__file__).resolve().parent, search_parent_directories=True)\n\ndef main():\n\n    # --------------- #\n    # Define workflow #\n    # --------------- #\n    workflow = [\n        {\n            \"process\": PolygonGeometryProc,\n        },\n        {\n            \"process\": ProjectileModelProc,\n        },\n    ]\n\n    # ------------------ #\n    # Define application #\n    # ------------------ #\n    app = Application(\n        app_name=APP_NAME,\n        nuremics_dir=repo.working_tree_dir,\n        workflow=workflow,\n    )\n    # Run it!\n    app()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>At this stage, we can start executing the App and see what's happen.</p> <p>Note that NUREMICS performs a structural check of each Proc by inspecting its <code>__call__</code> method. Specifically, it ensures that only functions (Ops) defined within the Proc class itself are called during execution. This design choice enforces a clean and self-contained structure for each Proc, where all internal logic remains encapsulated.</p> <p>Let's consider a case where the developer does not adhere to this enforced structural rule, for instance, by injecting additional logic directly into the <code>__call__</code> method of a Proc (in this example, in the <code>ProjectileModelProc</code> class).</p> <pre><code>    def __call__(self):\n        super().__call__()\n\n        some_variable = 2 # &lt;-- External logic added here\n\n        self.simulate_projectile_motion()\n        self.calculate_analytical_trajectory()\n        self.compare_model_vs_analytical_trajectories()\n</code></pre> <p>In this situation, NUREMICS will immediately raise a structural validation error and halt execution.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| Workflow |\nDEMO_APP_____\n             |_____PolygonGeometryProc_____\n             |                             |_____generate_polygon_shape\n             |                             |_____plot_polygon_shape\n             |\n             |_____ProjectileModelProc_____(X)\n\n(X) Each process must only call its internal function(s):\n\n    def __call__(self):\n        super().__call__()\n\n        self.operation1()\n        self.operation2()\n        self.operation3()\n        ...\n</code></pre></p> <p>NUREMICS is then expected to display a summary of all required input/output data for each Proc, along with their current mapping status within the App.</p> <p>At this stage, the system automatically verifies whether every required input/output data has been properly mapped within the App configuration.</p> <p>If any input parameters are missing, they are explicitly listed, and the developer is prompted to define them using either the <code>\"user_params\"</code> or <code>\"hard_params\"</code> key.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| PolygonGeometryProc |\n&gt; Input Parameter(s) :\n(float) radius  -----||----- Not defined (X)\n(int)   n_sides -----||----- Not defined (X)\n\n(X) Please define all input parameters either in \"user_params\" or \"hard_params\".\n</code></pre></p> <p>The input parameters of the Proc <code>PolygonGeometryProc</code> can be properly mapped within the App by defining the <code>\"user_params\"</code> and/or <code>\"hard_params\"</code> keys in its corresponding dictionary entry inside the <code>workflow</code> list.</p> <pre><code>import git\nfrom pathlib import Path\nfrom nuremics import Application\nfrom procs.general.PolygonGeometryProc.item import PolygonGeometryProc\nfrom procs.general.ProjectileModelProc.item import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\nrepo = git.Repo(Path(__file__).resolve().parent, search_parent_directories=True)\n\ndef main():\n\n    # --------------- #\n    # Define workflow #\n    # --------------- #\n    workflow = [\n        {\n            \"process\": PolygonGeometryProc,\n            \"user_params\": {\n                \"n_sides\": \"nb_sides\",\n            },\n            \"hard_params\": {\n                \"radius\": 0.5,\n            },\n        },\n        {\n            \"process\": ProjectileModelProc,\n        },\n    ]\n\n    # ------------------ #\n    # Define application #\n    # ------------------ #\n    app = Application(\n        app_name=APP_NAME,\n        nuremics_dir=repo.working_tree_dir,\n        workflow=workflow,\n    )\n    # Run it!\n    app()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>When running the App again, NUREMICS detects that all required input parameters for <code>PolygonGeometryProc</code> have been successfully mapped. However, it now reports that one or more input paths are missing. These are explicitly listed, and the developer is prompted to define them using either the <code>\"user_paths\"</code> or <code>\"required_paths\"</code> key.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| PolygonGeometryProc |\n&gt; Input Parameter(s) :\n(float) radius  -----||----- 0.5      (hard_params)\n(int)   n_sides -----||----- nb_sides (user_params)\n&gt; Input Path(s) :\ntitle_file -----||----- Not defined (X)\n\n(X) Please define all input paths either in \"user_paths\" or \"required_paths\".\n</code></pre></p> <p>The input paths of the Proc <code>PolygonGeometryProc</code> can be properly mapped within the App by defining the <code>\"user_paths\"</code> and/or <code>\"required_paths\"</code> keys in its corresponding dictionary entry inside the workflow list.</p> <pre><code>import git\nfrom pathlib import Path\nfrom nuremics import Application\nfrom procs.general.PolygonGeometryProc.item import PolygonGeometryProc\nfrom procs.general.ProjectileModelProc.item import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\nrepo = git.Repo(Path(__file__).resolve().parent, search_parent_directories=True)\n\ndef main():\n\n    # --------------- #\n    # Define workflow #\n    # --------------- #\n    workflow = [\n        {\n            \"process\": PolygonGeometryProc,\n            \"user_params\": {\n                \"n_sides\": \"nb_sides\",\n            },\n            \"hard_params\": {\n                \"radius\": 0.5,\n            },\n            \"user_paths\": {\n                \"title_file\": \"plot_title.txt\",\n            },\n        },\n        {\n            \"process\": ProjectileModelProc,\n        },\n    ]\n\n    # ------------------ #\n    # Define application #\n    # ------------------ #\n    app = Application(\n        app_name=APP_NAME,\n        nuremics_dir=repo.working_tree_dir,\n        workflow=workflow,\n    )\n    # Run it!\n    app()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>When running the App again, NUREMICS detects that all required input paths for <code>PolygonGeometryProc</code> have been successfully mapped. However, it now reports that one or more output paths are missing. These are explicitly listed, and the developer is prompted to define them using the <code>\"output_paths\"</code> key.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| PolygonGeometryProc |\n&gt; Input Parameter(s) :\n(float) radius  -----||----- 0.5      (hard_params)\n(int)   n_sides -----||----- nb_sides (user_params)\n&gt; Input Path(s) :\ntitle_file -----||----- plot_title.txt (user_paths)\n&gt; Input Analysis :\nNone.\n&gt; Output Path(s) :\ncoords_file -----||----- Not defined (X)\nfig_file    -----||----- Not defined (X)\n\n(X) Please define all output paths in \"output_paths\".\n</code></pre></p> <p>The output paths of the Proc <code>PolygonGeometryProc</code> can be properly mapped within the App by defining the <code>\"output_paths\"</code> key in its corresponding dictionary entry inside the workflow list.</p> <p>In the same way, we also complete the mapping for the Proc <code>ProjectileModelProc</code> by providing all required entries: <code>\"user_params\"</code> and/or <code>\"hard_params\"</code>, <code>\"user_paths\"</code> and/or <code>\"required_paths\"</code>, <code>\"output_paths\"</code>.</p> <pre><code>import git\nfrom pathlib import Path\nfrom nuremics import Application\nfrom procs.general.PolygonGeometryProc.item import PolygonGeometryProc\nfrom procs.general.ProjectileModelProc.item import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\nrepo = git.Repo(Path(__file__).resolve().parent, search_parent_directories=True)\n\ndef main():\n\n    # --------------- #\n    # Define workflow #\n    # --------------- #\n    workflow = [\n        {\n            \"process\": PolygonGeometryProc,\n            \"user_params\": {\n                \"n_sides\": \"nb_sides\",\n            },\n            \"hard_params\": {\n                \"radius\": 0.5,\n            },\n            \"user_paths\": {\n                \"title_file\": \"plot_title.txt\",\n            },\n            \"output_paths\": {\n                \"coords_file\": \"points_coordinates.csv\",\n                \"fig_file\": \"polygon_shape.png\",\n            },\n        },\n        {\n            \"process\": ProjectileModelProc,\n            \"user_params\": {\n                \"gravity\": \"gravity\",\n                \"mass\": \"mass\",\n            },\n            \"user_paths\": {\n                \"velocity_file\": \"velocity.json\",\n                \"configs_folder\": \"configs\",\n            },\n            \"required_paths\": {\n                \"coords_file\": \"points_coordinates.csv\",\n            },\n            \"output_paths\": {\n                \"comp_folder\": \"comparison\",\n            },\n        },\n    ]\n\n    # ------------------ #\n    # Define application #\n    # ------------------ #\n    app = Application(\n        app_name=APP_NAME,\n        nuremics_dir=repo.working_tree_dir,\n        workflow=workflow,\n    )\n    # Run it!\n    app()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>With all required mappings now properly defined for each Proc, the App can be executed without raising any errors. NUREMICS confirms that the full mapping is complete by prompting a summary for each Proc, indicating that all input parameters, input paths, and output paths have been successfully resolved.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| PolygonGeometryProc |\n&gt; Input Parameter(s) :\n(float) radius  -----||----- 0.5      (hard_params)\n(int)   n_sides -----||----- nb_sides (user_params)\n&gt; Input Path(s) :\ntitle_file -----||----- plot_title.txt (user_paths)\n&gt; Input Analysis :\nNone.\n&gt; Output Path(s) :\ncoords_file -----||----- points_coordinates.csv (output_paths)\nfig_file    -----||----- polygon_shape.png      (output_paths)\n\n| ProjectileModelProc |\n&gt; Input Parameter(s) :\n(float) gravity -----||----- gravity (user_params)\n(float) mass    -----||----- mass    (user_params)\n&gt; Input Path(s) :\nvelocity_file  -----||----- velocity.json          (user_paths)\nconfigs_folder -----||----- configs                (user_paths)\ncoords_file    -----||----- points_coordinates.csv (required_paths)\n&gt; Input Analysis :\nNone.\n&gt; Output Path(s) :\ncomp_folder -----||----- comparison (output_paths)\n</code></pre></p> <p>As the App has now been fully assembled, NUREMICS displays a clean summary of its I/O interface, as it will appear to the end-user. This summary includes all declared user parameters (<code>\"user_params\"</code>) and user paths (<code>\"user_paths\"</code>) required as inputs, along with the corresponding output files and folders that the App will generate. It serves as an explicit interface contract, allowing end-users to clearly understand what data they need to provide and what results to expect.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; INPUTS &lt;\n\n| User Parameters |\n&gt; nb_sides (int)\n&gt; gravity (float)\n&gt; mass (float)\n\n| User Paths |\n&gt; plot_title.txt\n&gt; velocity.json\n&gt; configs\n\n&gt; OUTPUTS &lt;\n\n&gt; points_coordinates.csv\n&gt; polygon_shape.png\n&gt; comparison\n</code></pre></p> <p>With all Procs implemented and properly assembled within the App, the development work is now complete. The developer\u2019s responsibility ends here (excluding, of course, the implementation of unit tests to ensure long-term maintainability, which falls outside the scope of this tutorial).</p> <p>The App is now fully functional and ready to be operated by end-users. From this point, users can interact with the App through its declared I/O interface, without needing to modify or understand the underlying code structure.</p>  Explore NUREMICS in:       Theory"},{"location":"handbook/theory/","title":"Theory","text":""},{"location":"handbook/theory/#design-patterns","title":"Design Patterns","text":"<p>Let\u2019s introduce the core design patterns behind Procs and Apps in NUREMICS.</p>"},{"location":"handbook/theory/#proc","title":"Proc","text":"<p>A Proc can be seen as an algorithmic box which processes some input data and produces corresponding output data.</p> <p>The input data typically fall into two main categories:</p> <ul> <li> <p>Input parameters: Scalar values such as <code>float</code>, <code>int</code>, <code>bool</code>, or <code>str</code>.</p> </li> <li> <p>Input paths: Files or folders provided as <code>Path</code> objects (from Python's <code>pathlib</code> module), pointing to structured data on disk.</p> </li> </ul> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n\n  **Parameters** {\n    float radius\n    int n_sides\n  }\n  **Paths** {\n    file title_file \"txt\"\n  }</code></pre> <p>As mentioned in the Handbook Overview, the algorithmic box of the Proc is a class composed of functions (Op) called sequentially within its <code>__call__</code> method.</p> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **PolygonGeometryProc** : feeds\n\n  **Parameters** {\n    float radius\n    int n_sides\n  }\n  **Paths** {\n    file title_file \"txt\"\n  }\n  **PolygonGeometryProc** {\n    op generate_polygon_shape\n    op plot_polygon_shape\n  }</code></pre> <p>Output data are typically expressed as <code>Path</code> objects as well, corresponding to files or folders written to disk during the execution of the Proc.</p> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **PolygonGeometryProc** : feeds\n  **PolygonGeometryProc** ||--|| **Outputs** : generates\n\n  **Parameters** {\n    float radius\n    int n_sides\n  }\n  **Paths** {\n    file title_file \"txt\"\n  }\n  **PolygonGeometryProc** {\n    op generate_polygon_shape\n    op plot_polygon_shape\n  }\n  **Outputs** {\n    file coords_file \"csv\"\n    file fig_file \"png\"\n  }</code></pre> <p>For the sake of example, let's define another Proc considering the same structure.</p> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **ProjectileModelProc** : feeds\n  **ProjectileModelProc** ||--|| **Outputs** : generates\n\n  **Parameters** {\n    float gravity\n    float mass\n  }\n  **Paths** {\n    file velocity_file \"json\"\n    folder configs_folder \"_\"\n    file coords_file \"csv\"\n  }\n  **ProjectileModelProc** {\n    op simulate_projectile_motion\n    op calculate_analytical_trajectory\n    op compare_model_vs_analytical_trajectories\n  }\n  **Outputs** {\n    folder comp_folder \"_\"\n  }</code></pre>"},{"location":"handbook/theory/#app","title":"App","text":"<p>A final end-user App can be built by plugging together previously implemented Procs, and specifying their sequential order of execution within the workflow.</p> <pre><code>flowchart RL\n  **PolygonGeometryProc** e1@--1--o **DEMO_APP**\n  **ProjectileModelProc** e2@--2--o **DEMO_APP**\n  **TrajectoryAnalysisProc** e3@--3--o **DEMO_APP**\n  **generate_polygon_shape** e4@--A--o **PolygonGeometryProc**\n  **plot_polygon_shape** e5@--B--o **PolygonGeometryProc**\n  **simulate_projectile_motion** e6@--A--o **ProjectileModelProc**\n  **calculate_analytical_trajectory** e7@--B--o **ProjectileModelProc**\n  **compare_model_vs_analytical_trajectories** e8@--C--o **ProjectileModelProc**\n  **plot_overall_model_vs_theory** e9@--A--o **TrajectoryAnalysisProc**\n  e1@{ animate: true }\n  e2@{ animate: true }\n  e3@{ animate: true }\n  e4@{ animate: true }\n  e5@{ animate: true }\n  e6@{ animate: true }\n  e7@{ animate: true }\n  e8@{ animate: true }\n  e9@{ animate: true }</code></pre> <p>Each Proc integrated into the App defines its own set of inputs and outputs, specific to its internal algorithmic logic. When these Procs are assembled into a workflow, the App itself exposes a higher-level set of inputs and outputs. These define the I/O interface presented to the end-user, who provides the necessary input data and retrieves the final results upon execution.</p> <p>The assembly step is performed through a mapping between the internal I/O data of each Proc and the global I/O interface of the App. This mapping mechanism serves multiple purposes:</p> <ul> <li> <p>It defines which data are exposed to the end-user (and how they are displayed) and which remain internal to the workflow.</p> </li> <li> <p>It manages the data dependencies between Procs, when the output of one Proc is used as input for another.</p> </li> </ul> <p>This notably ensures a coherent and seamless management of data across the workflow, while delivering a clean and focused I/O interface tailored to the user's needs.</p> <p>The mapping between a Proc and the App starts by specifying which Proc input parameters are exposed to the end-user, and how they are labeled in the App input interface.</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }</code></pre> <p>The Proc input parameters that remain internal to the workflow are assigned fixed values directly within the mapping definition, without being exposed to the end-user.</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n  **hard_params** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }\n  **hard_params** {\n    float radius \"0.5\"\n  }</code></pre> <p>The Proc input paths that need to be provided by the end-user are specified by defining the expected file or folder names within the App input interface.</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n  **hard_params** ||--|| **PolygonGeometryProc** : mapping\n  **user_paths** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }\n  **hard_params** {\n    float radius \"0.5\"\n  }\n  **user_paths** {\n    file title_file \"plot_title.txt\"\n  }</code></pre> <p>The Proc input paths can also be mapped to output paths produced by a previous Proc within the workflow (although this does not apply here, as we are currently focusing on the first Proc in the workflow).</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **DEMO_APP** ||--|| **required_paths** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n  **hard_params** ||--|| **PolygonGeometryProc** : mapping\n  **user_paths** ||--|| **PolygonGeometryProc** : mapping\n  **required_paths** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }\n  **hard_params** {\n    float radius \"0.5\"\n  }\n  **user_paths** {\n    file title_file \"plot_title.txt\"\n  }\n  **required_paths** {\n    _ _ \"_\"\n  }</code></pre> <p>Finally, the Proc output paths are specified by indicating the name of the file(s) or folder(s) that will be written by the Proc during the workflow execution.</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **DEMO_APP** ||--|| **required_paths** : mapping\n  **DEMO_APP** ||--|| **output_paths** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n  **hard_params** ||--|| **PolygonGeometryProc** : mapping\n  **user_paths** ||--|| **PolygonGeometryProc** : mapping\n  **required_paths** ||--|| **PolygonGeometryProc** : mapping\n  **output_paths** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }\n  **hard_params** {\n    float radius \"0.5\"\n  }\n  **user_paths** {\n    file title_file \"plot_title.txt\"\n  }\n  **required_paths** {\n    _ _ \"_\"\n  }\n  **output_paths** {\n    file coords_file \"points_coordinates.csv\"\n    file fig_file \"polygon_shape.png\"\n  }</code></pre> <p>Let's now assemble the second Proc to be executed by the App within the workflow, by establishing a dependency: the output data produced by the first Proc will serve as input data for this second one.</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **DEMO_APP** ||--|| **required_paths** : mapping\n  **DEMO_APP** ||--|| **output_paths** : mapping\n  **user_params** ||--|| **ProjectileModelProc** : mapping\n  **hard_params** ||--|| **ProjectileModelProc** : mapping\n  **user_paths** ||--|| **ProjectileModelProc** : mapping\n  **required_paths** ||--|| **ProjectileModelProc** : mapping\n  **output_paths** ||--|| **ProjectileModelProc** : mapping\n\n  **user_params** {\n    float gravity \"gravity\"   \n    float mass \"mass\"\n  }\n  **hard_params** {\n    _ _ \"_\"\n  }\n  **user_paths** {\n    file velocity_file \"velocity.json\"\n    folder configs_folder \"configs\"\n  }\n  **required_paths** {\n    file coords_file \"points_coordinates.csv\"\n  }\n  **output_paths** {\n    folder comp_folder \"comparison\"\n  }</code></pre> <p>Once all Procs have been assembled into the App, the final I/O interface presented to the end-user emerges.</p> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path1[\"plot_title.txt _(file)_\"]\n      path2[\"velocity.json _(file)_\"]\n      path3[\"configs _(folder)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"nb_sides _(int)_\"]\n      param2[\"gravity _(float)_\"]\n      param3[\"mass _(float)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc1[\"PolygonGeometryProc\"]\n    proc2[\"ProjectileModelProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out1[\"points_coordinates.csv _(file)_\"]\n    out2[\"polygon_shape.png _(file)_\"]\n    out3[\"comparison _(folder)_\"]\n  end\n\n  **INPUTS** --&gt; **DEMO_APP**\n  **DEMO_APP** --&gt; **OUTPUTS**</code></pre> <p>It is also insightful for the end-user to present this I/O interface by showing which INPUTS are used by each Proc of the App, and which OUTPUTS are written by each of them.</p> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path1[\"plot_title.txt _(file)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"nb_sides _(int)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc1[\"PolygonGeometryProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out1[\"points_coordinates.csv _(file)_\"]\n    out2[\"polygon_shape.png _(file)_\"]\n  end\n\n  **INPUTS** --&gt; proc1\n  proc1 --&gt; **OUTPUTS**</code></pre> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path2[\"velocity.json _(file)_\"]\n      path3[\"configs _(folder)_\"]\n      out1[\"points_coordinates.csv _(file)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param2[\"gravity _(float)_\"]\n      param3[\"mass _(float)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc2[\"ProjectileModelProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out3[\"comparison _(folder)_\"]\n  end\n\n  **INPUTS** --&gt; proc2\n  proc2 --&gt; **OUTPUTS**\n\n  classDef blueBox fill:#d0e6ff,stroke:#339,stroke-width:1.5px;\n  class out1 blueBox;</code></pre>"},{"location":"handbook/theory/#usability","title":"Usability","text":"<p>The Apps built with NUREMICS come with a lean and pragmatic user interface by design. No flashy GUI, but instead, the focus is on simplicity and efficiency:</p> <ul> <li> <p>An input database that the operator completes by editing configuration files and uploading the required input files and folders.</p> </li> <li> <p>A terminal interface that provides informative feedback at each execution, clearly indicating what the App is doing and what actions are expected from the operator.</p> </li> <li> <p>An output database that stores all results in a well-structured and traceable folder hierarchy.</p> </li> </ul> <pre><code>sequenceDiagram\n    actor Operator\n    Operator-&gt;&gt;DEMO_APP: Execution\n    DEMO_APP-&gt;&gt;INPUTS: Initialize database\n    DEMO_APP-&gt;&gt;Operator: Terminal feedback\n    Operator-&gt;&gt;INPUTS: Complete database\n    Operator-&gt;&gt;DEMO_APP: Execution\n    DEMO_APP-&gt;&gt;INPUTS: Read database\n    DEMO_APP-&gt;&gt;OUTPUTS: Write database\n    DEMO_APP-&gt;&gt;Operator: Terminal feedback\n    Operator-&gt;&gt;OUTPUTS: Access results</code></pre> <p>This streamlined approach prioritizes clarity, control, and reproducibility, making each App built with NUREMICS well-suited for both direct interaction by end-users and seamless integration into larger software ecosystems. In such environments, NUREMICS can operate as a backend computational engine, interacting programmatically with other tools (such as web applications) that provide their own user interfaces.</p>"},{"location":"handbook/theory/#configuration","title":"Configuration","text":"<p>When running an App, the operator first defines a set of studies aimed at exploring the INPUTS space and analyzing the outcomes in the OUTPUTS space.</p> <pre><code>flowchart LR\n    Study_Shape\n    Study_Velocity</code></pre> <p>The operator then configures each study by selecting which inputs stay constant (Fixed) and which ones change (Variable) across the various experiments.</p> <pre><code>flowchart LR\n\n  subgraph Fixed1[\"**Fixed**\"]\n    direction TB\n\n    subgraph Paths_Fixed1[\"**Paths**\"]\n      direction LR\n      path1_1[\"plot_title.txt\"]\n      path2_1[\"velocity.json\"]\n      path3_1[\"configs\"]\n    end\n\n    subgraph Parameter_Fixed1[\"**Parameters**\"]\n      direction LR\n      param2_1[\"gravity\"]\n      param3_1[\"mass\"]\n    end\n  end\n\n  subgraph Variable1[\"**Variable**\"]\n    direction TB\n\n    subgraph Paths_Variable1[\"**Paths**\"]\n      direction LR\n      no_path[\"_\"]\n    end\n\n    subgraph Parameter_Variable1[\"**Parameters**\"]\n      direction LR\n      param1_1[\"nb_sides\"]\n    end\n  end\n\n  Study_Shape --&gt; Fixed1\n  Study_Shape --&gt; Variable1\n\n  subgraph Fixed2[\"**Fixed**\"]\n    direction TB\n\n    subgraph Paths_Fixed2[\"**Paths**\"]\n      direction LR\n      path1_2[\"plot_title.txt\"]\n      path3_2[\"configs\"]\n    end\n\n    subgraph Parameter_Fixed2[\"**Parameters**\"]\n      direction LR\n      param1_2[\"nb_sides\"]\n      param2_2[\"gravity\"]\n      param3_2[\"mass\"]\n    end\n  end\n\n  subgraph Variable2[\"**Variable**\"]\n    direction TB\n\n    subgraph Paths_Variable2[\"**Paths**\"]\n      direction LR\n      path2_2[\"velocity.json\"]\n    end\n\n    subgraph Parameter_Variable2[\"**Parameters**\"]\n      direction LR\n      no_param[\"_\"]\n    end\n  end\n\n  Study_Velocity --&gt; Fixed2\n  Study_Velocity --&gt; Variable2</code></pre>"},{"location":"handbook/theory/#settings","title":"Settings","text":"<p>To conduct experiments, the operator assigns values for both fixed and variable inputs: fixed inputs remain constant across all experiments (Common), while variable inputs are adjusted from one experiment to another (Test1, Test2, ...).</p> <pre><code>flowchart LR\n    Study_Shape --&gt; Study1_Common[\"Common\"]\n    Study_Shape --&gt; Study1_Test1[\"Test1\"]\n    Study_Shape --&gt; Study1_Test2[\"Test2\"]\n    Study_Shape --&gt; Study1_Test3[\"...\"]\n\n    Study1_Common --&gt; common1_param2[\"gravity = ...\"]\n    Study1_Common --&gt; common1_param3[\"mass = ...\"]\n    Study1_Common --&gt; common1_input1[\"plot_title.txt _(uploaded)_\"]\n    Study1_Common --&gt; common1_input2[\"velocity.json _(uploaded)_\"]\n    Study1_Common --&gt; common1_input3[\"configs _(uploaded)_\"]\n\n    Study1_Test1 --&gt; test1_param1[\"nb_sides = ...\"]\n    Study1_Test2 --&gt; test2_param1[\"nb_sides = ...\"]\n    Study1_Test3 --&gt; test3_param1[\"nb_sides = ...\"]\n\n    Study_Velocity --&gt; Study2_Common[\"Common\"]\n    Study_Velocity --&gt; Study2_Test1[\"Test1\"]\n    Study_Velocity --&gt; Study2_Test2[\"Test2\"]\n    Study_Velocity --&gt; Study2_Test3[\"...\"]\n\n    Study2_Common --&gt; common2_param1[\"nb_sides = ...\"]\n    Study2_Common --&gt; common2_param2[\"gravity = ...\"]\n    Study2_Common --&gt; common2_param3[\"mass = ...\"]\n    Study2_Common --&gt; common2_input1[\"plot_title.txt _(uploaded)_\"]\n    Study2_Common --&gt; common2_input3[\"configs _(uploaded)_\"]\n\n    Study2_Test1 --&gt; test1_path2[\"velocity.json _(uploaded)_\"]\n    Study2_Test2 --&gt; test2_path2[\"velocity.json _(uploaded)_\"]\n    Study2_Test3 --&gt; test3_path2[\"velocity.json _(uploaded)_\"]</code></pre>"},{"location":"handbook/theory/#results","title":"Results","text":"<p>At the end of the execution, results are stored in a structured output tree, ready for review or further processing. The outputs are first organized by Proc, each of them writing its own result data. Within each Proc, the results are further subdivided by experiment (Test1, Test2, ...), ensuring a clear separation and traceability of outcomes across the entire study.</p> <p>This organization is automatically determined based on how the study is configured by the operator. NUREMICS analyzes which input data are marked as fixed or variable, and how they connect to the internal workflow of the App. If a Proc directly depends on variable inputs, or indirectly through upstream dependencies, it will generate distinct outputs for each experiment. Otherwise, it will produce shared outputs only once.</p> <p>This logic ensures that only the necessary parts of the workflow are repeated through experimentations, and that the output structure faithfully reflects the configuration of the study along with the internal dependencies within the workflow.</p> <pre><code>flowchart LR\n    Study_Shape --&gt; Study1_PolygonGeometryProc[\"PolygonGeometryProc\"]\n    Study_Shape --&gt; Study1_ProjectileModelProc[\"ProjectileModelProc\"]\n\n    Study1_PolygonGeometryProc --&gt; Study1_PolygonGeometryProc_Test1[\"Test1\"]\n    Study1_PolygonGeometryProc --&gt; Study1_PolygonGeometryProc_Test2[\"Test2\"]\n    Study1_PolygonGeometryProc --&gt; Study1_PolygonGeometryProc_Test3[\"...\"]\n\n    Study1_PolygonGeometryProc_Test1 --&gt; Study1_PolygonGeometryProc_Test1_output1[\"points_coordinates.csv\"]\n    Study1_PolygonGeometryProc_Test1 --&gt; Study1_PolygonGeometryProc_Test1_output2[\"polygon_shape.png\"]\n    Study1_PolygonGeometryProc_Test2 --&gt; Study1_PolygonGeometryProc_Test2_output1[\"points_coordinates.csv\"]\n    Study1_PolygonGeometryProc_Test2 --&gt; Study1_PolygonGeometryProc_Test2_output2[\"polygon_shape.png\"]\n    Study1_PolygonGeometryProc_Test3 --&gt; Study1_PolygonGeometryProc_Test3_output1[\"points_coordinates.csv\"]\n    Study1_PolygonGeometryProc_Test3 --&gt; Study1_PolygonGeometryProc_Test3_output2[\"polygon_shape.png\"]\n\n    Study1_ProjectileModelProc --&gt; Study1_ProjectileModelProc_Test1[\"Test1\"]\n    Study1_ProjectileModelProc --&gt; Study1_ProjectileModelProc_Test2[\"Test2\"]\n    Study1_ProjectileModelProc --&gt; Study1_ProjectileModelProc_Test3[\"...\"]\n\n    Study1_ProjectileModelProc_Test1 --&gt; Study1_ProjectileModelProc_Test1_output3[\"comparison\"]\n    Study1_ProjectileModelProc_Test2 --&gt; Study1_ProjectileModelProc_Test2_output3[\"comparison\"]\n    Study1_ProjectileModelProc_Test3 --&gt; Study1_ProjectileModelProc_Test3_output3[\"comparison\"]\n\n    Study_Velocity --&gt; Study2_PolygonGeometryProc[\"PolygonGeometryProc\"]\n    Study_Velocity --&gt; Study2_ProjectileModelProc[\"ProjectileModelProc\"]\n\n    Study2_PolygonGeometryProc --&gt; Study2_PolygonGeometryProc_Common_output1[\"points_coordinates.csv\"]\n    Study2_PolygonGeometryProc --&gt; Study2_PolygonGeometryProc_Common_output2[\"polygon_shape.png\"]\n\n    Study2_ProjectileModelProc --&gt; Study2_ProjectileModelProc_Test1[\"Test1\"]\n    Study2_ProjectileModelProc --&gt; Study2_ProjectileModelProc_Test2[\"Test2\"]\n    Study2_ProjectileModelProc --&gt; Study2_ProjectileModelProc_Test3[\"...\"]\n\n    Study2_ProjectileModelProc_Test1 --&gt; Study2_ProjectileModelProc_Test1_output3[\"comparison\"]\n    Study2_ProjectileModelProc_Test2 --&gt; Study2_ProjectileModelProc_Test2_output3[\"comparison\"]\n    Study2_ProjectileModelProc_Test3 --&gt; Study2_ProjectileModelProc_Test3_output3[\"comparison\"]</code></pre>  Explore NUREMICS in:       Practice"},{"location":"labs/apps/general/DEMO_APP/","title":"DEMO_APP","text":""},{"location":"labs/apps/general/DEMO_APP/#workflow","title":"Workflow","text":"<ol> <li><code>PolygonGeometryProc</code>: Generate and plot a regular 2D polygon shape.   A/ <code>generate_polygon_shape</code>: Generate the 2D coordinates of a regular polygon.   B/ <code>plot_polygon_shape</code>: Plot a closed 2D polygon from a set of points.</li> <li><code>ProjectileModelProc</code>: Simulate the motion of a projectile and compare its trajectory with the analytical solution.   A/ <code>simulate_projectile_motion</code>: Simulate the motion of a 2D rigid body under gravity projected with an initial velocity.   B/ <code>calculate_analytical_trajectory</code>: Calculate the theoretical trajectory of a projectile using analytical equations.   C/ <code>compare_model_vs_analytical_trajectories</code>: Plot and save the comparison between simulated (model) and theoretical projectile trajectories.</li> <li><code>TrajectoryAnalysisProc</code>: Perform overall comparisons between simulated (model) and theoretical trajectories.   A/ <code>plot_overall_model_vs_theory</code>: Generate overall comparative plots of simulated (model) and theoritical trajectories.</li> </ol> <pre><code>flowchart RL\n  **PolygonGeometryProc** e1@--1--o **DEMO_APP**\n  **ProjectileModelProc** e2@--2--o **DEMO_APP**\n  **TrajectoryAnalysisProc** e3@--3--o **DEMO_APP**\n  **generate_polygon_shape** e4@--A--o **PolygonGeometryProc**\n  **plot_polygon_shape** e5@--B--o **PolygonGeometryProc**\n  **simulate_projectile_motion** e6@--A--o **ProjectileModelProc**\n  **calculate_analytical_trajectory** e7@--B--o **ProjectileModelProc**\n  **compare_model_vs_analytical_trajectories** e8@--C--o **ProjectileModelProc**\n  **plot_overall_model_vs_theory** e9@--A--o **TrajectoryAnalysisProc**\n  e1@{ animate: true }\n  e2@{ animate: true }\n  e3@{ animate: true }\n  e4@{ animate: true }\n  e5@{ animate: true }\n  e6@{ animate: true }\n  e7@{ animate: true }\n  e8@{ animate: true }\n  e9@{ animate: true }</code></pre>"},{"location":"labs/apps/general/DEMO_APP/#mapping","title":"Mapping","text":"<pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **DEMO_APP** ||--|| **output_paths** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n  **hard_params** ||--|| **PolygonGeometryProc** : mapping\n  **user_paths** ||--|| **PolygonGeometryProc** : mapping\n  **output_paths** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }\n  **hard_params** {\n    float radius \"0.5\"\n  }\n  **user_paths** {\n    file title_file \"plot_title.txt\"\n  }\n  **output_paths** {\n    file coords_file \"points_coordinates.csv\"\n    file fig_file \"polygon_shape.png\"\n  }</code></pre> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **DEMO_APP** ||--|| **required_paths** : mapping\n  **DEMO_APP** ||--|| **output_paths** : mapping\n  **user_params** ||--|| **ProjectileModelProc** : mapping\n  **user_paths** ||--|| **ProjectileModelProc** : mapping\n  **required_paths** ||--|| **ProjectileModelProc** : mapping\n  **output_paths** ||--|| **ProjectileModelProc** : mapping\n\n  **user_params** {\n    float gravity \"gravity\"   \n    float mass \"mass\"\n  }\n  **user_paths** {\n    file velocity_file \"velocity.json\"\n    folder configs_folder \"configs\"\n  }\n  **required_paths** {\n    file coords_file \"points_coordinates.csv\"\n  }\n  **output_paths** {\n    folder comp_folder \"comparison\"\n  }</code></pre> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **overall_analysis** : mapping\n  **DEMO_APP** ||--|| **output_paths** : mapping\n  **overall_analysis** ||--|| **TrajectoryAnalysisProc** : mapping\n  **output_paths** ||--|| **TrajectoryAnalysisProc** : mapping\n\n  **overall_analysis** {\n    folder comp_folder \"comparison\"\n  }\n  **output_paths** {\n    file fig_file \"overall_comparisons.png\" \n  }</code></pre>"},{"location":"labs/apps/general/DEMO_APP/#io-interface","title":"I/O Interface","text":"<pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path1[\"plot_title.txt _(file)_\"]\n      path2[\"velocity.json _(file)_\"]\n      path3[\"configs _(folder)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"nb_sides _(int)_\"]\n      param2[\"gravity _(float)_\"]\n      param3[\"mass _(float)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc1[\"PolygonGeometryProc\"]\n    proc2[\"ProjectileModelProc\"]\n    proc3[\"TrajectoryAnalysisProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out1[\"points_coordinates.csv _(file)_\"]\n    out2[\"polygon_shape.png _(file)_\"]\n    out3[\"comparison _(folder)_\"]\n    out4[\"overall_comparisons.png _(file)_\"]\n  end\n\n  **INPUTS** --&gt; **DEMO_APP**\n  **DEMO_APP** --&gt; **OUTPUTS**</code></pre> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path1[\"plot_title.txt _(file)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"nb_sides _(int)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc1[\"PolygonGeometryProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out1[\"points_coordinates.csv _(file)_\"]\n    out2[\"polygon_shape.png _(file)_\"]\n  end\n\n  **INPUTS** --&gt; proc1\n  proc1 --&gt; **OUTPUTS**</code></pre> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path2[\"velocity.json _(file)_\"]\n      path3[\"configs _(folder)_\"]\n      out1[\"points_coordinates.csv _(file)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param2[\"gravity _(float)_\"]\n      param3[\"mass _(float)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc2[\"ProjectileModelProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out3[\"comparison _(folder)_\"]\n  end\n\n  **INPUTS** --&gt; proc2\n  proc2 --&gt; **OUTPUTS**\n\n  classDef blueBox fill:#d0e6ff,stroke:#339,stroke-width:1.5px;\n  class out1 blueBox;</code></pre> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      out3[\"comparison _(folder)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param[\"_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc3[\"TrajectoryAnalysisProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out4[\"overall_comparisons.png _(file)_\"]\n  end\n\n  **INPUTS** --&gt; proc3\n  proc3 --&gt; **OUTPUTS**\n\n  classDef blueBox fill:#d0e6ff,stroke:#339,stroke-width:1.5px;\n  class out3 blueBox;</code></pre>"},{"location":"labs/apps/general/DEMO_APP/#inputs","title":"INPUTS","text":""},{"location":"labs/apps/general/DEMO_APP/#parameters","title":"Parameters","text":"<ul> <li><code>nb_sides</code>: Number of sides of the polygon.</li> <li><code>gravity</code>: Gravitational acceleration (m/s\u00b2).</li> <li><code>mass</code>: Mass of the body (kg).</li> </ul>"},{"location":"labs/apps/general/DEMO_APP/#paths","title":"Paths","text":"<ul> <li><code>plot_title.txt</code>: File containing the plot title of the 2D polygon shape.</li> <li><code>velocity.json</code>: File containing the velocity initial conditions {v0 (m/s); angle (\u00b0)}.</li> <li><code>configs/</code> <code>solver_config.json</code>: File containing the parameters for solver configuration.  <code>display_config.json</code>: File containing the parameters for display configuration.</li> </ul>"},{"location":"labs/apps/general/DEMO_APP/#outputs","title":"OUTPUTS","text":"<ul> <li><code>points_coordinates.csv</code>: File containing the X/Y coordinates of the polygon vertices.</li> <li><code>polygon_shape.png</code>: Image of the plotted polygon figure.</li> <li><code>comparison/</code> <code>results.xlsx</code>: File containing simulated (model) and theoritical trajectories.  <code>model_vs_theory.png</code>: Image comparing both trajectories.</li> <li><code>overall_comparisons.png</code>: Image containing overall comparative plots.</li> </ul>      View source code"},{"location":"labs/procs/general/PolygonGeometryProc/","title":"PolygonGeometryProc","text":""},{"location":"labs/procs/general/PolygonGeometryProc/#process","title":"Process","text":"<p>Generate and plot a regular 2D polygon shape. A/ <code>generate_polygon_shape</code>: Generate the 2D coordinates of a regular polygon. B/ <code>plot_polygon_shape</code>: Plot a closed 2D polygon from a set of points.</p> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **PolygonGeometryProc** : feeds\n  **PolygonGeometryProc** ||--|| **Outputs** : generates\n\n  **Parameters** {\n    float radius\n    int n_sides\n  }\n  **Paths** {\n    file title_file \"txt\"\n  }\n  **PolygonGeometryProc** {\n    op generate_polygon_shape\n    op plot_polygon_shape\n  }\n  **Outputs** {\n    file coords_file \"csv\"\n    file fig_file \"png\"\n  }</code></pre>"},{"location":"labs/procs/general/PolygonGeometryProc/#input-parameters","title":"Input Parameter(s)","text":"<ul> <li><code>radius</code>: Radius (m) of the circumscribed circle of the polygon.</li> <li><code>n_sides</code>: Number of sides of the polygon.</li> </ul>"},{"location":"labs/procs/general/PolygonGeometryProc/#input-paths","title":"Input Path(s)","text":"<ul> <li><code>title_file</code>: File containing the plot title of the 2D polygon shape.</li> </ul>"},{"location":"labs/procs/general/PolygonGeometryProc/#output-paths","title":"Output Path(s)","text":"<ul> <li><code>coords_file</code>: File containing the X/Y coordinates of the polygon vertices.</li> <li><code>fig_file</code>: Image of the plotted polygon figure.</li> </ul>      View source code"},{"location":"labs/procs/general/ProjectileModelProc/","title":"ProjectileModelProc","text":""},{"location":"labs/procs/general/ProjectileModelProc/#process","title":"Process","text":"<p>Simulate the motion of a projectile and compare its trajectory with the analytical solution. A/ <code>simulate_projectile_motion</code>: Simulate the motion of a 2D rigid body under gravity projected with an initial velocity. B/ <code>calculate_analytical_trajectory</code>: Calculate the theoretical trajectory of a projectile using analytical equations. C/ <code>compare_model_vs_analytical_trajectories</code>: Plot and save the comparison between simulated (model) and theoretical projectile trajectories.</p> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **ProjectileModelProc** : feeds\n  **ProjectileModelProc** ||--|| **Outputs** : generates\n\n  **Parameters** {\n    float gravity\n    float mass\n  }\n  **Paths** {\n    file velocity_file \"json\"\n    folder configs_folder \"_\"\n    file coords_file \"csv\"\n  }\n  **ProjectileModelProc** {\n    op simulate_projectile_motion\n    op calculate_analytical_trajectory\n    op compare_model_vs_analytical_trajectories\n  }\n  **Outputs** {\n    folder comp_folder \"_\"\n  }</code></pre>"},{"location":"labs/procs/general/ProjectileModelProc/#input-parameters","title":"Input Parameter(s)","text":"<ul> <li><code>gravity</code>: Gravitational acceleration (m/s\u00b2).</li> <li><code>mass</code>: Mass of the body (kg).</li> </ul>"},{"location":"labs/procs/general/ProjectileModelProc/#input-paths","title":"Input Path(s)","text":"<ul> <li><code>velocity_file</code>: File containing the velocity initial conditions {v0 (m/s); angle (\u00b0)}.</li> <li><code>configs_folder/</code> <code>solver_config.json</code>: File containing the parameters for solver configuration. <code>display_config.json</code>: File containing the parameters for display configuration.</li> <li><code>coords_file</code>: File containing the X/Y coordinates of the polygonal shape to simulate.</li> </ul>"},{"location":"labs/procs/general/ProjectileModelProc/#output-paths","title":"Output Path(s)","text":"<ul> <li><code>comp_folder/</code> <code>results.xlsx</code>: File containing simulated (model) and theoritical trajectories. <code>model_vs_theory.png</code>: Image comparing both trajectories.</li> </ul>      View source code"},{"location":"labs/procs/general/TrajectoryAnalysisProc/","title":"TrajectoryAnalysisProc","text":""},{"location":"labs/procs/general/TrajectoryAnalysisProc/#process","title":"Process","text":"<p>Perform overall comparisons between simulated (model) and theoretical trajectories. A/ <code>plot_overall_model_vs_theory</code>: Generate overall comparative plots of simulated (model) and theoritical trajectories.</p> <pre><code>erDiagram\n  **Analysis** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **TrajectoryAnalysisProc** : feeds\n  **TrajectoryAnalysisProc** ||--|| **Outputs** : generates\n\n  **Analysis** {\n    folder comp_folder \"_\"\n  }\n  **TrajectoryAnalysisProc** {\n    op plot_overall_model_vs_theory\n  }\n  **Outputs** {\n    file fig_file \"png\"\n  }</code></pre>"},{"location":"labs/procs/general/TrajectoryAnalysisProc/#input-analysis","title":"Input Analysis","text":"<ul> <li><code>comp_folder/</code> <code>results.xlsx</code>: File containing both trajectories.</li> </ul>"},{"location":"labs/procs/general/TrajectoryAnalysisProc/#output-paths","title":"Output Path(s)","text":"<ul> <li><code>fig_file</code>: Image containing overall comparative plots.</li> </ul>      View source code"}]}