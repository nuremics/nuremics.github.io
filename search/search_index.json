{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>nuRemics is an open-source Python framework for building software-grade scientific tools.</p> <p>\ud83d\udd2c Scientific agility \u2014 engineering rigor. \ud83e\udde9 Modular by design \u2014 no more siloed tools. \ud83d\udcca Parametric exploration \u2014 iterate without limits. \ud83d\udccb Full traceability \u2014 every experiment accounted for. \ud83d\udcc8 Built to scale \u2014 from lab to industry.  \ud83c\udf10 Community-driven \u2014 innovation thrives together.</p>      Getting Started         Onboarding         Use Cases"},{"location":"#overview","title":"Overview","text":"<p>The nuRemics framework provides a dedicated environment to build custom software tools designed for the automated production of scientific results at scale, ensuring systematic reproducibility and full traceability across every execution. This is achieved through a clear separation of concerns, organized into the following layered structure: </p> <p>APP</p> <p>It is the execution engine where the core scientific logic is formalized and implemented in a codebase. It operates as a structured workflow composed of autonomous software processes (e.g., Process1-3) executed in a sequential order. Each software process encapsulates a specific stage of the computation and acts as an independent functional item.</p> <p>INPUTS</p> <p>It defines the entry points required by the application to function (e.g., Input1\u20136) and ensures that each input is routed to its respective software process, in order to satisfy the corresponding data requirements.</p> <p>OUTPUTS</p> <p>It defines the delivery points where results are produced during execution (e.g., Output1\u20134). Each software process generates its own outputs, which are either stored as final results or re-routed as inputs of subsequent software processes within the workflow.</p> <p>CONFIGURATION</p> <p>It orchestrates how the application is controlled by the operator across different study scenarios (e.g., Study1\u20132). For each study, the operator defines which inputs are Fixed (constant throughout the study) and which are Variable (changing between individual test). This enables automated batch execution of multiple tests (e.g., Test1\u20133) by systematically updating the inputs.</p> <p>TRACEABILITY</p> <p>It automatically generates a structured directory tree (Study &gt; Process &gt; Test) where each output is stored within a hierarchy that directly links it back to the specific configuration that produced it. This provides a permanent, auditable record of every production run.</p>"},{"location":"#meet-our-ambassadors","title":"Meet Our Ambassadors","text":"Irina RAKOTOARISEDY PhD student in Deep Learning University Carlos III of Madrid"},{"location":"development-chart/","title":"Development chart","text":"<p>The chart below outlines the key phases in the scientific development of nuRemics Apps, along with the roles involved in each phase. Each role is associated with specific responsibilities and expertise. This structure ensures a reproducible and high-quality development process.</p> Phase Role Scientific Expertise Python Expertise Software Expertise Main Responsabilities Use Case Requirements Scientist \u2705 \u274c \u274c Defines the scientific/business need into a clear use case, constituting the Functional Requirement Specifications (FRS). Architecture Workflow Architect \u274c \u2705 \u274c Translate the use case into a structured scientific workflow, formalizing the Software Requirement Specifications (SRS). Implementation Scientific Developer \u2705 \u2705 \u274c Implement the software items constituting the workflow in compliance with the defined SRS. Integration Software Developer \u274c \u2705 \u2705 Support the implementation, optimize the code, and develop tests for integration and Software Quality Assurance (SQA). Deployment DevOps \u274c \u274c \u2705 Ensure reliable deployment and installation processes for end-users. Production End-User Scientist \u2705 \u274c \u274c Execute workflow to produce, interpret, and report scientific results. <p>\u2705 Required  \u274c Not required</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#foreword","title":"Foreword","text":"<p>The nuRemics project is organized into two complementary repositories:</p> <ul> <li> <p><code>nuremics</code>: This repository is the core Python library. It provides the foundational components to create modular and extensible software workflows.</p> </li> <li> <p><code>nuremics-labs</code>: This repository contains examples of end-user applications built using the nuRemics framework. It is intended to be forked by developers to initiate their own <code>nuremics-labs</code> project and build custom scientific applications tailored to their specific use cases.</p> </li> </ul> <p>Developers are thus encouraged to treat <code>nuremics</code> as the core engine, and to use <code>nuremics-labs</code> as a starting point for developing and maintaining their own scientific software applications built on top of the nuRemics framework.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Installation proceeds as follows:</p> <ol> <li> <p>Fork and clone the <code>nuremics-labs</code> repository. You have two options to get started:</p> <ul> <li> <p>Option A (recommended): Fork the repo to your own GitHub or GitLab account, then clone your fork. This allows you to modify the code and push your changes to your personal version of the project.</p> <pre><code>    nuremics-labs  \u2192  fork  \u2192  your-labs  \u2192  clone\n</code></pre> </li> <li> <p>Option B (quick start): If you just want to try the framework without making changes, you can simply clone the main repo directly.</p> HTTPSSSH <pre><code>git clone https://github.com/nuremics/nuremics-labs.git\n</code></pre> <pre><code>git clone git@github.com:nuremics/nuremics-labs.git\n</code></pre> </li> </ul> </li> <li> <p>(Optional, but recommended) Create the nuRemics virtual environment. From the root directory of your cloned repo, use either conda or micromamba to create and install the environment using the provided <code>environment.yml</code> file.</p> <p>- Creation -</p> CondaMicromamba <pre><code>conda create -f environment.yml\n</code></pre> <pre><code>micromamba create -f environment.yml\n</code></pre> <p>- Activation -</p> CondaMicromamba <pre><code>conda activate nrs-env\n</code></pre> <pre><code>micromamba activate nrs-env\n</code></pre> </li> <li> <p>Install nuRemics with the demo application. Each application in <code>nuremics-labs</code> can be installed independently. You can start by installing the <code>DEMO_APP</code>.</p> <pre><code>pip install .[DEMO_APP]\n</code></pre> <p>This will install both the core <code>nuremics</code> framework and the <code>nuremics-labs</code> demo application.</p> </li> </ol>"},{"location":"getting-started/#run-the-demo","title":"Run the demo","text":"<p>To get hands-on experience with the nuRemics framework, you'll start by running the <code>DEMO_APP</code> and reproducing the scientific results of the <code>Study_Shape</code> and <code>Study_Velocity</code> studies, as demonstrated in the video below.</p> <p>When first run, a nuRemics App creates a local workspace on your system, where you configure studies, set input data, and collect results. In this tutorial, instead of setting up from scratch, you'll start with a preconfigured workspace to reproduce the <code>Study_Shape</code> and <code>Study_Velocity</code> studies.</p> <p>Follow these steps:</p> <ol> <li> <p>Download the <code>nuRemics_Starter</code> archive. Retrieve the preconfigured <code>nuRemics_Starter</code> archive and unzip it anywhere on your system.</p> <p>\ud83d\udce6 Download nuRemics_Starter archive</p> </li> <li> <p>Prepare the nuRemics working directory. Locate the <code>nrs_working_dir</code> folder inside the unzipped archive and move it to any location on your system that is most convenient for you.</p> </li> <li> <p>Prepare the <code>.nuremics</code> directory. Locate the <code>.nuremics</code> folder in the same unzipped archive and place it at the root of your forked/cloned <code>nuremics-labs</code> repo.</p> </li> <li> <p>Set the working directory for <code>DEMO_APP</code>. Edit the <code>\"working_dir\"</code> field in <code>.nuremics/settings.json</code> and set the full path to your local <code>nrs_working_dir</code>.</p> \ud83d\udcc4 <code>nuremics-labs/.nuremics/settings.json</code> <pre><code>{\n    \"default_working_dir\": null,\n    \"apps\": {\n        \"DEMO_APP\": {\n            \"working_dir\": \"path/to/your/nrs_working_dir\",\n            \"studies\": [\n                \"Study_Shape\",\n                \"Study_Velocity\"\n            ]\n        }\n    }\n}\n</code></pre> </li> <li> <p>Run the <code>DEMO_APP</code>. From the <code>nuremics-labs/src/labs/apps/general/DEMO_APP</code> folder, run the App.</p> <pre><code>python src/labs/apps/general/DEMO_APP/system.py\n</code></pre> <p>This will launch both studies and store results in <code>nrs_working_dir/DEMO_APP</code>.</p> </li> </ol>"},{"location":"getting-started/#play-with-it","title":"Play with it","text":"<p>Now that you've successfully run the <code>DEMO_APP</code> and reproduced the scientific results of the <code>Study_Shape</code> and <code>Study_Velocity</code> studies, let's play with it!</p>"},{"location":"getting-started/#skip-a-study","title":"Skip a study","text":"<p>Want to skip the execution of a specific study when running your App? Set its <code>\"execute\"</code> field to <code>false</code> in the <code>studies.json</code> file.</p> \ud83d\udcc4 <code>nrs_working_dir/DEMO_APP/studies.json</code> <pre><code>{\n    \"Study_Shape\": {\n        \"execute\": false,\n        ...\n    },\n    \"Study_Velocity\": {\n        \"execute\": true,\n        ...\n    }\n}\n</code></pre>"},{"location":"getting-started/#skip-a-process","title":"Skip a process","text":"<p>Want to skip the execution of a specific process (Proc) within a study? Set its <code>\"execute\"</code> field to <code>false</code> in the <code>process.json</code> file.</p> \ud83d\udcc4 <code>nrs_working_dir/DEMO_APP/Study_Velocity/process.json</code> <pre><code>{\n    \"PolygonGeometryProc\": {\n        \"execute\": false,\n        \"silent\": false\n    },\n    \"ProjectileModelProc\": {\n        \"execute\": true,\n        \"silent\": false\n    },\n    \"TrajectoryAnalysisProc\": {\n        \"execute\": true,\n        \"silent\": false\n    }\n}\n</code></pre>"},{"location":"getting-started/#silent-a-process","title":"Silent a process","text":"<p>Want a specific process (Proc) to be executed in silent mode within a study? Set its <code>\"silent\"</code> field to <code>true</code> in the <code>process.json</code> file.</p> \ud83d\udcc4 <code>nrs_working_dir/DEMO_APP/Study_Velocity/process.json</code> <pre><code>{\n    \"PolygonGeometryProc\": {\n        \"execute\": false,\n        \"silent\": false\n    },\n    \"ProjectileModelProc\": {\n        \"execute\": true,\n        \"silent\": true\n    },\n    \"TrajectoryAnalysisProc\": {\n        \"execute\": true,\n        \"silent\": false\n    }\n}\n</code></pre>"},{"location":"getting-started/#skip-an-experiment","title":"Skip an experiment","text":"<p>Want to skip the execution of a specific experiment in a study? Set the value of the <code>EXECUTE</code> flag to <code>0</code> in the <code>inputs.csv</code> file for the experiment you want to skip.</p> \ud83d\udcc4 <code>nrs_working_dir/DEMO_APP/Study_Velocity/inputs.csv</code> <pre><code>ID,EXECUTE\nTest1,1\nTest2,0\nTest3,1\n</code></pre>"},{"location":"getting-started/#run-a-new-experiment","title":"Run a new experiment","text":"<p>Want to run a new experiment in a study? Add a new line with a unique <code>ID</code> to the <code>inputs.csv</code> file.</p> \ud83d\udcc4 <code>nrs_working_dir/DEMO_APP/Study_Velocity/inputs.csv</code> <pre><code>ID,EXECUTE\nTest1,1\nTest2,0\nTest3,1\nMyExp,1\n</code></pre> <p>Then run the App, which will automatically generate the corresponding input folder where you must upload the required <code>velocity.json</code> file.</p> \ud83d\udcc4 <code>nrs_working_dir/DEMO_APP/Study_Velocity/0_inputs/0_datasets/MyExp/velocity.json</code> <pre><code>{\n    \"v0\": 15.0,\n    \"angle\": 60.0\n}\n</code></pre>"},{"location":"getting-started/#modify-analysis-settings","title":"Modify analysis settings","text":"<p>Want to customize the overall analysis of experiment results for a given study? Use the <code>analysis.json</code> file to control how each one is handled.</p> \ud83d\udcc4 <code>nrs_working_dir/DEMO_APP/Study_Velocity/analysis.json</code> <pre><code>{\n    \"points_coordinates.csv\": {},\n    \"polygon_shape.png\": {},\n    \"comparison\": {\n        \"Test1\": {\n            \"add\": true,\n            \"color\": \"red\",\n            \"linestyle\": \"None\",\n            \"linewidth\": 2.0,\n            \"marker\": \"D\",\n            \"markersize\": 8,\n            \"markevery\": 20,\n            \"label\": \"Model\"\n        },\n        \"Test2\": {\n            \"add\": true,\n            \"color\": \"limegreen\",\n            \"linestyle\": \"None\",\n            \"linewidth\": 2.0,\n            \"marker\": \"v\",\n            \"markersize\": 10,\n            \"markevery\": 15,\n            \"label\": \"Model\"\n        },\n        \"Test3\": {\n            \"add\": true,\n            \"color\": \"dodgerblue\",\n            \"linestyle\": \"None\",\n            \"linewidth\": 2.0,\n            \"marker\": \"X\",\n            \"markersize\": 8,\n            \"markevery\": 20,\n            \"label\": \"Model\"\n        },\n        \"MyExp\": {\n            \"add\": true,\n            \"color\": \"fuchsia\",\n            \"linestyle\": \"None\",\n            \"linewidth\": 2.0,\n            \"marker\": \"o\",\n            \"markersize\": 8,\n            \"markevery\": 20,\n            \"label\": \"Model\"\n        }\n    },\n    \"overall_comparisons.png\": {}\n}\n</code></pre>  You're now ready to dive into nuRemics\ud83e\uddec       Handbook"},{"location":"ambassadors/Irina_RAKOTOARISEDY/","title":"Irina RAKOTOARISEDY","text":""},{"location":"handbook/","title":"Handbook","text":"<p>The software architecture of nuRemics is illustrated in the diagram below. It follows the layered structure recommended by the IEC 62304 standard, distinguishing between software systems, software items, and software units. This representation provides a clear, high-level view of how the different software components of the project are organized, and how they interact within a structured yet flexible development framework. It also highlights the relationship between the core framework (<code>nuremics</code>) and its domain-specific applications (<code>nuremics-labs</code>), emphasizing the modular and extensible nature of the overall architecture.</p> <p>In the context of nuRemics:</p> <ul> <li> <p>A software unit corresponds to a single, testable function. It is the smallest building block of logic.</p> </li> <li> <p>A software item typically takes the form of a Python class that encapsulates related functions (units) to serve a specific purpose.</p> </li> <li> <p>A software system refers to a complete application designed to be executed by an end-user, replacing traditional scripts or notebooks.</p> </li> </ul> <p></p> <p>In practice, the core framework <code>nuremics</code> is composed of three foundational classes:</p> <ul> <li> <p>The <code>Process</code> class defines a generic process component. It provides a flexible base structure that can be extended to implement domain-specific processes within <code>nuremics-labs</code>.</p> </li> <li> <p>The <code>Workflow</code> class orchestrates the execution of multiple processes in a defined sequential order. It encapsulates the coordination logic and manages the progression of tasks throughout the workflow.</p> </li> <li> <p>The <code>Application</code> class is the top-level component. It instantiates and executes a workflow, acting as the main entry point for any end-user application developed within <code>nuremics-labs</code>.</p> </li> </ul> <p>In <code>nuremics-labs</code>, two main types of software components are developed to build domain-specific applications:</p> <ul> <li> <p>Procs (software items) \u2014 such as <code>Proc1, Proc2, ..., ProcX</code> \u2014 are implemented by subclassing the core <code>Process</code> class. Each Proc is defined as a class that encapsulates several functions (software units), which represent elementary operations (Ops) executed sequentially within the <code>__call__</code> method of the Proc. This design enables the creation of independent, reusable Procs that can be executed on their own or integrated into larger workflows.</p> </li> <li> <p>Apps (software systems) \u2014 such as <code>APP1, APP2, ..., APPX</code> \u2014 are the end-user-facing software applications. They import and assemble the required Procs, executing them in a defined order through the <code>Workflow</code> class, by instantiating the <code>Application</code> class. This modular architecture promotes flexibility and reusability, allowing the same Procs to be used across multiple Apps tailored to different scientific purposes.</p> </li> </ul>  Explore nuRemics in:       Theory         Practice"},{"location":"handbook/practice/","title":"Practice","text":""},{"location":"handbook/practice/#use-app","title":"Use App","text":"<p>This section walks you through the usage of a nuRemics App from the end-user's perspective. We will demonstrate how to interact with a ready-to-use App, including how to design studies, define experiments, provide inputs, run the App, and retrieve the expected outputs.</p> <p>When launching the App, nuRemics first provides the following terminal feedback:</p> <ul> <li>A visual banner indicating the launch of a nuRemics App.</li> <li>A structured overview of the assembled workflow, with its constitutive Procs and Ops, and their order of execution within the App workflow.</li> <li>A summary of the App's I/O interface. This summary includes all declared user parameters (<code>\"user_params\"</code>) and user paths (<code>\"user_paths\"</code>) required as inputs, along with the corresponding output files and folders that the App will generate. It serves as an explicit interface contract, allowing you to understand what data you need to provide and what results to expect.</li> </ul> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>                      ___\n                     /\\  \\                      ___\n     ___            /::\\  \\        ___         /\\  \\\n    /\\__\\          /:/\\:\\  \\      /\\__\\       /::\\  \\\n   /::|  |        /::\\~\\:\\  \\    /::|  |     /:/\\:\\  \\\n  /:|:|  |       /:/\\:\\ \\:\\__\\  /:|:|  |    /:/  \\:\\  \\\n /:/|:|  |__     \\/_|::\\/:/  / /:/|:|__|__ /:/__/ \\:\\__\\\n/:/ |:| /\\__\\  ___  |:|::/  / /:/ |::::\\__\\\\:\\  \\  \\/__/\n\\/__|:|/:/  / /\\__\\ |:|\\/__/  \\/__/~~/:/  / \\:\\  \\\n    |:/:/  / /:/  / |:|  |  ___     /:/  /   \\:\\  \\\n    |::/  / /:/  /   \\|__| /\\  \\   /:/  / ___ \\:\\__\\ ___\n    /:/  / /:/  /  ___    /::\\  \\ /:/  / /\\  \\ \\/__//\\  \\\n    \\/__/ /:/__/  /\\__\\  /:/\\:\\  \\\\/__/  \\:\\  \\    /::\\  \\\n          \\:\\  \\ /:/  / /::\\~\\:\\  \\      /::\\__\\  /:/\\ \\  \\\n           \\:\\  /:/  / /:/\\:\\ \\:\\__\\  __/:/\\/__/ _\\:\\~\\ \\  \\\n            \\:\\/:/  /  \\:\\~\\:\\ \\/__/ /\\/:/  /   /\\ \\:\\ \\ \\__\\\n             \\::/  /    \\:\\ \\:\\__\\   \\::/__/    \\:\\ \\:\\ \\/__/\n              \\/__/      \\:\\ \\/__/    \\:\\__\\     \\:\\ \\:\\__\\\n                          \\:\\__\\       \\/__/      \\:\\/:/  /\n                           \\/__/                   \\::/  /\n                                                    \\/__/\n&gt; APPLICATION &lt;\n\n| Workflow |\nDEMO_APP_____\n             |_____PolygonGeometryProc_____\n             |                             |_____generate_polygon_shape\n             |                             |_____plot_polygon_shape\n             |\n             |_____ProjectileModelProc_____\n             |                             |_____simulate_projectile_motion\n             |                             |_____calculate_analytical_trajectory\n             |                             |_____compare_model_vs_analytical_trajectories\n             |\n             |_____TrajectoryAnalysisProc_____\n                                              |_____plot_overall_model_vs_theory\n\n&gt; INPUTS &lt;\n\n| User Parameters |\n&gt; nb_sides (int)\n&gt; gravity (float)\n&gt; mass (float)\n\n| User Paths |\n&gt; plot_title.txt\n&gt; velocity.json\n&gt; configs\n\n&gt; OUTPUTS &lt;\n\n&gt; points_coordinates.csv\n&gt; polygon_shape.png\n&gt; comparison\n&gt; overall_comparisons.png\n</code></pre></p>"},{"location":"handbook/practice/#specify-working-directory","title":"Specify Working Directory","text":"<p>If this is your first time launching a nuRemics App, nuRemics will prompt you to specify the working directory (<code>\"working_dir\"</code>) for the App. This directory serves as the root location where all input/output data, logs, and results will be stored.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>(X) Please define DEMO_APP \"working_dir\" in file :\n&gt; .../nuremics-labs/.nuremics/settings.json\n</code></pre></p> <p>As indicated in the terminal message, you must define this path in the <code>settings.json</code> file located in the <code>.nuremics</code> folder. This folder should reside at the root of your <code>nuremics-labs</code> repository.</p> \ud83d\udcc4<code>nuremics-labs/.nuremics/settings.json</code> <pre><code>{\n    \"default_working_dir\": null,\n    \"apps\": {\n        \"DEMO_APP\": {\n            \"working_dir\": \"path/to/your/app/working_dir\",\n            \"studies\": []\n        }\n    }\n}\n</code></pre> <p>If you've already launched a nuRemics App before, but this is your first time launching this specific App, nuRemics may have already registered a <code>default_working_dir</code> in the <code>settings.json</code> file based on a previous App. In that case, it will suggest using this same directory as the <code>\"working_dir\"</code> for the current App.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>(!) Found \"default_working_dir\": path/to/your/previous/app/working_dir\nAccept it as \"working_dir\" for DEMO_APP: [Y/n]\n</code></pre></p> <p>You can either accept the proposed path by pressing <code>Y</code>, or reject it with <code>n</code> and manually define a new one by editing the <code>settings.json</code> file.</p> <p>A new folder named after the App is then automatically generated under the specified <code>\"working_dir\"</code>. This folder acts as the root container for all the execution-related content generated by the App.</p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/ \u2795 #generated\n</code></pre></p>"},{"location":"handbook/practice/#declare-studies","title":"Declare Studies","text":"<p>nuRemics then prompts you to declare the different studies you want to carry out with the App.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; STUDIES &lt;\n\n(X) Please declare at least one study in file :\n&gt; .../nuremics-labs/.nuremics/settings.json\n</code></pre></p> <p>This must be declared in the same <code>settings.json</code> file located at the root of your <code>nuremics-labs</code> repository, as a list of identifiers corresponding to the different studies you want to carry out. You can declare as many studies as needed, each representing a self-contained parametric study.</p> \ud83d\udcc4<code>nuremics-labs/.nuremics/settings.json</code> <pre><code>{\n    \"default_working_dir\": null,\n    \"apps\": {\n        \"DEMO_APP\": {\n            \"working_dir\": \"path/to/your/app/working_dir\",\n            \"studies\": [\n                \"Study_Shape\",\n                \"Study_Velocity\"\n            ]\n        }\n    }\n}\n</code></pre> <p>A <code>studies.json</code> file is then generated inside the App's <code>\"working_dir\"</code>. This file serves as a centralized configuration hub for all declared studies.</p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u2514\u2500\u2500 studies.json \u2795 #generated\n</code></pre></p>"},{"location":"handbook/practice/#configure-studies","title":"Configure Studies","text":"<p>nuRemics then prompts you to configure the first study that you previously declared.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; STUDIES &lt;\n\n| Study_Shape |\n(X) nb_sides not configured.\n(X) gravity not configured.\n(X) mass not configured.\n(X) plot_title.txt not configured.\n(X) velocity.json not configured.\n(X) configs not configured.\n\n(X) Please configure file :\n&gt; .../DEMO_APP/studies.json\n</code></pre></p> <p>You must now complete the <code>studies.json</code> file by specifying, for each input, whether it should remain fixed (<code>false</code>) or be allowed to vary (<code>true</code>) across the experiments that will later be defined within the study.</p> \ud83d\udcc4<code>&lt;working_dir&gt;/DEMO_APP/studies.json</code> <pre><code>{\n    \"Study_Shape\": {\n        \"execute\": true,\n        \"user_params\": {\n            \"nb_sides\": true,\n            \"gravity\": false,\n            \"mass\": false\n        },\n        \"user_paths\": {\n            \"plot_title.txt\": false,\n            \"velocity.json\": false,\n            \"configs\": false\n        }\n    },\n    \"Study_Velocity\": {\n        \"execute\": true,\n        \"user_params\": {\n            \"nb_sides\": null,\n            \"gravity\": null,\n            \"mass\": null\n        },\n        \"user_paths\": {\n            \"plot_title.txt\": null,\n            \"velocity.json\": null,\n            \"configs\": null\n        }\n    }\n}\n</code></pre> <p>nuRemics then prompts that the first study is properly configured, but indicates that the second declared study still requires configuration.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; STUDIES &lt;\n\n| Study_Shape |\n(V) nb_sides is variable.\n(V) gravity is fixed.\n(V) mass is fixed.\n(V) plot_title.txt is fixed.\n(V) velocity.json is fixed.\n(V) configs is fixed.\n\n| Study_Velocity |\n(X) nb_sides not configured.\n(X) gravity not configured.\n(X) mass not configured.\n(X) plot_title.txt not configured.\n(X) velocity.json not configured.\n(X) configs not configured.\n\n(X) Please configure file :\n&gt; .../DEMO_APP/studies.json\n</code></pre></p> <p>The same work must therefore be done in the <code>studies.json</code> file to properly configure the study.</p> \ud83d\udcc4<code>&lt;working_dir&gt;/DEMO_APP/studies.json</code> <pre><code>{\n    \"Study_Shape\": {\n        \"execute\": true,\n        \"user_params\": {\n            \"nb_sides\": true,\n            \"gravity\": false,\n            \"mass\": false\n        },\n        \"user_paths\": {\n            \"plot_title.txt\": false,\n            \"velocity.json\": false,\n            \"configs\": false\n        }\n    },\n    \"Study_Velocity\": {\n        \"execute\": true,\n        \"user_params\": {\n            \"nb_sides\": false,\n            \"gravity\": false,\n            \"mass\": false\n        },\n        \"user_paths\": {\n            \"plot_title.txt\": false,\n            \"velocity.json\": true,\n            \"configs\": false\n        }\n    }\n}\n</code></pre> <p>nuRemics finally prompts that all declared studies are properly configured.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; STUDIES &lt;\n\n| Study_Shape |\n(V) nb_sides is variable.\n(V) gravity is fixed.\n(V) mass is fixed.\n(V) plot_title.txt is fixed.\n(V) velocity.json is fixed.\n(V) configs is fixed.\n\n| Study_Velocity |\n(V) nb_sides is fixed.\n(V) gravity is fixed.\n(V) mass is fixed.\n(V) plot_title.txt is fixed.\n(V) velocity.json is variable.\n(V) configs is fixed.\n</code></pre></p> <p>A dedicated folder for each study is then generated inside the App's <code>\"working_dir\"</code>.</p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u251c\u2500\u2500 studies.json\n    \u251c\u2500\u2500 Study_Shape/    \u2795 #generated\n    \u2514\u2500\u2500 Study_Velocity/ \u2795 #generated\n</code></pre></p>"},{"location":"handbook/practice/#set-input-data","title":"Set Input Data","text":"<p>Each study folder inside the App's <code>\"working_dir\"</code> now contains an initialized input database that you must complete to run your first experiments.</p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u251c\u2500\u2500 studies.json\n    \u251c\u2500\u2500 Study_Shape/\n    \u2502   \u251c\u2500\u2500 inputs.csv  \u2795 #generated\n    \u2502   \u251c\u2500\u2500 inputs.json \u2795 #generated\n    \u2502   \u2514\u2500\u2500 0_inputs/   \u2795 #generated\n    \u2514\u2500\u2500 Study_Velocity/\n        \u251c\u2500\u2500 inputs.csv  \u2795 #generated\n        \u251c\u2500\u2500 inputs.json \u2795 #generated\n        \u2514\u2500\u2500 0_inputs/   \u2795 #generated\n</code></pre></p> <p>This input database contains:</p> <ul> <li><code>inputs.csv</code>: This is the main file for declaring the experiments you want to run in the study. This is also where you must set the input parameters defined as variable <code>\"user_params\"</code>.</li> <li><code>inputs.json</code>: In this file, you must set the input parameters defined as fixed <code>\"user_params\"</code>.</li> <li><code>0_inputs/</code>: This folder must contain the input files and/or folders defined as <code>\"user_paths\"</code> (either fixed or variable).</li> </ul> <p>nuRemics first prompts you to set the fixed input data for the first declared study.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; SETTINGS &lt;\n\n| Study_Shape |\n&gt; Common : (X) gravity (X) mass (X) plot_title.txt (X) velocity.json (X) configs\n\n(X) Please set inputs :\n&gt; .../DEMO_APP/Study_Shape/inputs.json\n&gt; .../DEMO_APP/Study_Shape/0_inputs/plot_title.txt\n&gt; .../DEMO_APP/Study_Shape/0_inputs/velocity.json\n&gt; .../DEMO_APP/Study_Shape/0_inputs/configs\n</code></pre></p> \ud83d\udcc4<code>&lt;working_dir&gt;/DEMO_APP/Study_Shape/inputs.json</code> <pre><code>{\n    \"gravity\": -9.81,\n    \"mass\": 0.1\n}\n</code></pre> \ud83d\udcc4<code>&lt;working_dir&gt;/DEMO_APP/Study_Shape/0_inputs/plot_title.txt</code> <pre><code>2D polygon shape\n</code></pre> \ud83d\udcc4<code>&lt;working_dir&gt;/DEMO_APP/Study_Shape/0_inputs/velocity.json</code> <pre><code>{\n    \"v0\": 15.0,\n    \"angle\": 45.0\n}\n</code></pre> \ud83d\udcc1<code>&lt;working_dir&gt;/DEMO_APP/Study_Shape/0_inputs/configs/</code>\ud83d\udcc4<code>solver_config.json</code>\ud83d\udcc4<code>display_config.json</code> <pre><code>{\n    \"timestep\": 0.01\n}\n</code></pre> <pre><code>{\n    \"fps\": 60,\n    \"size\": 700\n}\n</code></pre> <p>All fixed input data have now been completed within the input database of the study.</p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u251c\u2500\u2500 studies.json\n    \u251c\u2500\u2500 Study_Shape/\n    \u2502   \u251c\u2500\u2500 inputs.csv\n    \u2502   \u251c\u2500\u2500 inputs.json\n    \u2502   \u2514\u2500\u2500 0_inputs/\n    \u2502       \u251c\u2500\u2500 plot_title.txt          \u2b07\ufe0f #uploaded\n    \u2502       \u251c\u2500\u2500 velocity.json           \u2b07\ufe0f #uploaded\n    \u2502       \u2514\u2500\u2500 configs/                \u2b07\ufe0f #uploaded\n    \u2502           \u251c\u2500\u2500 solver_config.json  \u2b07\ufe0f #uploaded\n    \u2502           \u2514\u2500\u2500 display_config.json \u2b07\ufe0f #uploaded\n    \u2514\u2500\u2500 Study_Velocity/\n        \u251c\u2500\u2500 inputs.csv\n        \u251c\u2500\u2500 inputs.json\n        \u2514\u2500\u2500 0_inputs/\n</code></pre></p> <p>nuRemics then prompts that all fixed input data have been properly set, but indicates that datasets of variable input data still need to be declared in order to define the experiments to run.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; SETTINGS &lt;\n\n| Study_Shape |\n&gt; Common : (V) gravity (V) mass (V) plot_title.txt (V) velocity.json (V) configs\n\n(X) Please declare at least one experiment in file :\n&gt; .../DEMO_APP/Study_Shape/inputs.csv\n</code></pre></p> <p>Let's first declare three experiments in the <code>inputs.csv</code> file.</p> \ud83d\udcc4 <code>&lt;working_dir&gt;/DEMO_APP/Study_Shape/inputs.csv</code> <pre><code>ID,nb_sides,EXECUTE\nTest1,,\nTest2,,\nTest3,,\n</code></pre> <p>nuRemics now prompts that the three experiments have been declared, but is waiting for the variable input data to be set for each of them.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code> &gt; SETTINGS &lt;\n\n| Study_Shape |\n&gt; Common : (V) gravity (V) mass (V) plot_title.txt (V) velocity.json (V) configs\n&gt; Test1 : (X) nb_sides\n&gt; Test2 : (X) nb_sides\n&gt; Test3 : (X) nb_sides\n\n(X) Please set inputs :\n&gt; .../DEMO_APP/Study_Shape/inputs.csv\n</code></pre></p> <p>Let\u2019s thus set input values for each experiment in the <code>inputs.csv</code> file.</p> \ud83d\udcc4 <code>&lt;working_dir&gt;/DEMO_APP/Study_Shape/inputs.csv</code> <pre><code>ID,nb_sides,EXECUTE\nTest1,3,\nTest2,4,\nTest3,5,\n</code></pre> <p>nuRemics finally prompts that all input data are properly set for the study.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; SETTINGS &lt;\n\n| Study_Shape |\n&gt; Common : (V) gravity (V) mass (V) plot_title.txt (V) velocity.json (V) configs\n&gt; Test1 : (V) nb_sides\n&gt; Test2 : (V) nb_sides\n&gt; Test3 : (V) nb_sides\n</code></pre></p> <p>The same work must be done to set the input data for the second declared study.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| Study_Velocity |\n&gt; Common : (X) nb_sides (X) gravity (X) mass (X) plot_title.txt (X) configs\n\n(X) Please set inputs :\n&gt; .../DEMO_APP/Study_Velocity/inputs.json\n&gt; .../DEMO_APP/Study_Velocity/0_inputs/plot_title.txt\n&gt; .../DEMO_APP/Study_Velocity/0_inputs/configs\n</code></pre></p> \ud83d\udcc4<code>&lt;working_dir&gt;/DEMO_APP/Study_Velocity/inputs.json</code> <pre><code>{\n    \"nb_sides\": 5,\n    \"gravity\": -9.81,\n    \"mass\": 0.1\n}\n</code></pre> \ud83d\udcc4<code>&lt;working_dir&gt;/DEMO_APP/Study_Velocity/0_inputs/plot_title.txt</code> <pre><code>2D polygon shape\n</code></pre> \ud83d\udcc1<code>&lt;working_dir&gt;/DEMO_APP/Study_Velocity/0_inputs/configs/</code>\ud83d\udcc4<code>solver_config.json</code>\ud83d\udcc4<code>display_config.json</code> <pre><code>{\n    \"timestep\": 0.01\n}\n</code></pre> <pre><code>{\n    \"fps\": 60,\n    \"size\": 700\n}\n</code></pre> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u251c\u2500\u2500 studies.json\n    \u251c\u2500\u2500 Study_Shape/\n    \u2502   \u251c\u2500\u2500 inputs.csv\n    \u2502   \u251c\u2500\u2500 inputs.json\n    \u2502   \u2514\u2500\u2500 0_inputs/\n    \u2502       \u251c\u2500\u2500 plot_title.txt\n    \u2502       \u251c\u2500\u2500 velocity.json\n    \u2502       \u2514\u2500\u2500 configs/\n    \u2502           \u251c\u2500\u2500 solver_config.json\n    \u2502           \u2514\u2500\u2500 display_config.json\n    \u2514\u2500\u2500 Study_Velocity/\n        \u251c\u2500\u2500 inputs.csv\n        \u251c\u2500\u2500 inputs.json\n        \u2514\u2500\u2500 0_inputs/\n            \u251c\u2500\u2500 plot_title.txt          \u2b07\ufe0f #uploaded\n            \u2514\u2500\u2500 configs/                \u2b07\ufe0f #uploaded\n                \u251c\u2500\u2500 solver_config.json  \u2b07\ufe0f #uploaded\n                \u2514\u2500\u2500 display_config.json \u2b07\ufe0f #uploaded\n</code></pre></p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| Study_Velocity |\n&gt; Common : (V) nb_sides (V) gravity (V) mass (V) plot_title.txt (V) configs\n\n(X) Please declare at least one experiment in file :\n&gt; .../DEMO_APP/Study_Velocity/inputs.csv\n</code></pre></p> \ud83d\udcc4 <code>&lt;working_dir&gt;/DEMO_APP/Study_Velocity/inputs.csv</code> <pre><code>ID,EXECUTE\nTest1,\nTest2,\nTest3,\n</code></pre> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| Study_Velocity |\n&gt; Common : (V) nb_sides (V) gravity (V) mass (V) plot_title.txt (V) configs\n&gt; Test1 : (X) velocity.json\n&gt; Test2 : (X) velocity.json\n&gt; Test3 : (X) velocity.json\n\n(X) Please set inputs :\n&gt; .../DEMO_APP/Study_Velocity/0_inputs/0_datasets/Test1/velocity.json\n&gt; .../DEMO_APP/Study_Velocity/0_inputs/0_datasets/Test2/velocity.json\n&gt; .../DEMO_APP/Study_Velocity/0_inputs/0_datasets/Test3/velocity.json\n</code></pre></p> \ud83d\udcc1<code>&lt;working_dir&gt;/DEMO_APP/Study_Velocity/0_inputs/0_datasets/Test1</code>\ud83d\udcc4<code>velocity.json</code>\ud83d\udcc1<code>Test2</code>\ud83d\udcc4<code>velocity.json</code>\ud83d\udcc1<code>Test3</code>\ud83d\udcc4<code>velocity.json</code> <pre><code>{\n    \"v0\": 15.0,\n    \"angle\": 45.0\n}\n</code></pre> <pre><code>{\n    \"v0\": 20.0,\n    \"angle\": 45.0\n}\n</code></pre> <pre><code>{\n    \"v0\": 20.0,\n    \"angle\": 60.0\n}\n</code></pre> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u251c\u2500\u2500 studies.json\n    \u251c\u2500\u2500 Study_Shape/\n    \u2502   \u251c\u2500\u2500 inputs.csv\n    \u2502   \u251c\u2500\u2500 inputs.json\n    \u2502   \u2514\u2500\u2500 0_inputs/\n    \u2502       \u251c\u2500\u2500 plot_title.txt\n    \u2502       \u251c\u2500\u2500 velocity.json\n    \u2502       \u2514\u2500\u2500 configs/\n    \u2502           \u251c\u2500\u2500 solver_config.json\n    \u2502           \u2514\u2500\u2500 display_config.json\n    \u2514\u2500\u2500 Study_Velocity/\n        \u251c\u2500\u2500 inputs.csv\n        \u251c\u2500\u2500 inputs.json\n        \u2514\u2500\u2500 0_inputs/\n            \u251c\u2500\u2500 plot_title.txt\n            \u251c\u2500\u2500 configs/\n            \u2502   \u251c\u2500\u2500 solver_config.json\n            \u2502   \u2514\u2500\u2500 display_config.json\n            \u2514\u2500\u2500 0_datasets/           \u2795 #generated\n                \u251c\u2500\u2500 Test1/            \u2795 #generated\n                \u2502   \u2514\u2500\u2500 velocity.json \u2b07\ufe0f #uploaded\n                \u251c\u2500\u2500 Test2/            \u2795 #generated\n                \u2502   \u2514\u2500\u2500 velocity.json \u2b07\ufe0f #uploaded\n                \u2514\u2500\u2500 Test3/            \u2795 #generated\n                    \u2514\u2500\u2500 velocity.json \u2b07\ufe0f #uploaded\n</code></pre></p> <p>nuRemics finally prompts that all input data are properly set for all declared studies.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; SETTINGS &lt;\n\n| Study_Shape |\n&gt; Common : (V) gravity (V) mass (V) plot_title.txt (V) velocity.json (V) configs\n&gt; Test1 : (V) nb_sides\n&gt; Test2 : (V) nb_sides\n&gt; Test3 : (V) nb_sides\n\n| Study_Velocity |\n&gt; Common : (V) nb_sides (V) gravity (V) mass (V) plot_title.txt (V) configs\n&gt; Test1 : (V) velocity.json\n&gt; Test2 : (V) velocity.json\n&gt; Test3 : (V) velocity.json\n</code></pre></p>"},{"location":"handbook/practice/#get-results","title":"Get Results","text":"<p>At this stage, nuRemics is ready to run all the defined studies and generate the corresponding results.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; RUNNING &lt;\n\n| Study_Shape | PolygonGeometryProc | Test1 |\n&gt; n_sides = 3\n&gt; radius = 0.5\n&gt; title_file = .../DEMO_APP/Study_Shape/0_inputs/plot_title.txt\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Shape | PolygonGeometryProc | Test2 |\n&gt; n_sides = 4\n&gt; radius = 0.5\n&gt; title_file = .../DEMO_APP/Study_Shape/0_inputs/plot_title.txt\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Shape | PolygonGeometryProc | Test3 |\n&gt; n_sides = 5\n&gt; radius = 0.5\n&gt; title_file = .../DEMO_APP/Study_Shape/0_inputs/plot_title.txt\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Shape | ProjectileModelProc | Test1 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; velocity_file = .../DEMO_APP/Study_Shape/0_inputs/velocity.json\n&gt; configs_folder = .../DEMO_APP/Study_Shape/0_inputs/configs\n&gt; coords_file = .../DEMO_APP/Study_Shape/1_PolygonGeometryProc/Test1/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Shape | ProjectileModelProc | Test2 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; velocity_file = .../DEMO_APP/Study_Shape/0_inputs/velocity.json\n&gt; configs_folder = .../DEMO_APP/Study_Shape/0_inputs/configs\n&gt; coords_file = .../DEMO_APP/Study_Shape/1_PolygonGeometryProc/Test2/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Shape | ProjectileModelProc | Test3 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; velocity_file = .../DEMO_APP/Study_Shape/0_inputs/velocity.json\n&gt; configs_folder = .../DEMO_APP/Study_Shape/0_inputs/configs\n&gt; coords_file = .../DEMO_APP/Study_Shape/1_PolygonGeometryProc/Test3/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Shape | TrajectoryAnalysisProc |\n&gt; comp_folder = comparison\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Velocity | PolygonGeometryProc |\n&gt; n_sides = 5\n&gt; radius = 0.5\n&gt; title_file = .../DEMO_APP/Study_Velocity/0_inputs/plot_title.txt\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Velocity | ProjectileModelProc | Test1 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; configs_folder = .../DEMO_APP/Study_Velocity/0_inputs/configs\n&gt; velocity_file = .../DEMO_APP/Study_Velocity/0_inputs/0_datasets/Test1/velocity.json\n&gt; coords_file = .../DEMO_APP/Study_Velocity/1_PolygonGeometryProc/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Velocity | ProjectileModelProc | Test2 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; configs_folder = .../DEMO_APP/Study_Velocity/0_inputs/configs\n&gt; velocity_file = .../DEMO_APP/Study_Velocity/0_inputs/0_datasets/Test2/velocity.json\n&gt; coords_file = .../DEMO_APP/Study_Velocity/1_PolygonGeometryProc/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Velocity | ProjectileModelProc | Test3 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; configs_folder = .../DEMO_APP/Study_Velocity/0_inputs/configs\n&gt; velocity_file = .../DEMO_APP/Study_Velocity/0_inputs/0_datasets/Test3/velocity.json\n&gt; coords_file = .../DEMO_APP/Study_Velocity/1_PolygonGeometryProc/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Velocity | TrajectoryAnalysisProc |\n&gt; comp_folder = comparison\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n</code></pre></p> <p>You can then access the results in the output database generated by nuRemics within the App's <code>\"working_dir\"</code>. </p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u251c\u2500\u2500 studies.json\n    \u251c\u2500\u2500 Study_Shape/\n    \u2502   \u251c\u2500\u2500 inputs.csv\n    \u2502   \u251c\u2500\u2500 inputs.json\n    \u2502   \u251c\u2500\u2500 0_inputs/\n    \u2502   \u2502   \u251c\u2500\u2500 plot_title.txt\n    \u2502   \u2502   \u251c\u2500\u2500 velocity.json\n    \u2502   \u2502   \u2514\u2500\u2500 configs/\n    \u2502   \u2502       \u251c\u2500\u2500 solver_config.json\n    \u2502   \u2502       \u2514\u2500\u2500 display_config.json\n    \u2502   \u251c\u2500\u2500 1_PolygonGeometryProc/          \u2795 #generated\n    \u2502   \u2502   \u251c\u2500\u2500 Test1/                      \u2795 #generated\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 points_coordinates.csv  \u2795 #generated\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 polygon_shape.png       \u2795 #generated\n    \u2502   \u2502   \u251c\u2500\u2500 Test2/                      \u2795 #generated\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 points_coordinates.csv  \u2795 #generated\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 polygon_shape.png       \u2795 #generated\n    \u2502   \u2502   \u2514\u2500\u2500 Test3/                      \u2795 #generated\n    \u2502   \u2502       \u251c\u2500\u2500 points_coordinates.csv  \u2795 #generated\n    \u2502   \u2502       \u2514\u2500\u2500 polygon_shape.png       \u2795 #generated\n    \u2502   \u251c\u2500\u2500 2_ProjectileModelProc/          \u2795 #generated\n    \u2502   \u2502   \u251c\u2500\u2500 Test1/                      \u2795 #generated\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 comparison/             \u2795 #generated\n    \u2502   \u2502   \u2502       \u251c\u2500\u2500 results.xlsx        \u2795 #generated\n    \u2502   \u2502   \u2502       \u2514\u2500\u2500 model_vs_theory.png \u2795 #generated\n    \u2502   \u2502   \u251c\u2500\u2500 Test2/                      \u2795 #generated\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 comparison/             \u2795 #generated\n    \u2502   \u2502   \u2502       \u251c\u2500\u2500 results.xlsx        \u2795 #generated\n    \u2502   \u2502   \u2502       \u2514\u2500\u2500 model_vs_theory.png \u2795 #generated\n    \u2502   \u2502   \u2514\u2500\u2500 Test3/                      \u2795 #generated\n    \u2502   \u2502       \u2514\u2500\u2500 comparison/             \u2795 #generated\n    \u2502   \u2502           \u251c\u2500\u2500 results.xlsx        \u2795 #generated\n    \u2502   \u2502           \u2514\u2500\u2500 model_vs_theory.png \u2795 #generated\n    \u2502   \u2514\u2500\u2500 3_TrajectoryAnalysisProc        \u2795 #generated\n    \u2502       \u2514\u2500\u2500 overall_comparisons.png     \u2795 #generated\n    \u2514\u2500\u2500 Study_Velocity/\n        \u251c\u2500\u2500 inputs.csv\n        \u251c\u2500\u2500 inputs.json\n        \u251c\u2500\u2500 0_inputs/\n        \u2502   \u251c\u2500\u2500 plot_title.txt\n        \u2502   \u251c\u2500\u2500 configs/\n        \u2502   \u2502   \u251c\u2500\u2500 solver_config.json\n        \u2502   \u2502   \u2514\u2500\u2500 display_config.json\n        \u2502   \u2514\u2500\u2500 0_datasets/\n        \u2502       \u251c\u2500\u2500 Test1/\n        \u2502       \u2502   \u2514\u2500\u2500 velocity.json\n        \u2502       \u251c\u2500\u2500 Test2/\n        \u2502       \u2502   \u2514\u2500\u2500 velocity.json\n        \u2502       \u2514\u2500\u2500 Test3/\n        \u2502           \u2514\u2500\u2500 velocity.json\n        \u251c\u2500\u2500 1_PolygonGeometryProc/          \u2795 #generated\n        \u2502   \u251c\u2500\u2500 points_coordinates.csv      \u2795 #generated\n        \u2502   \u2514\u2500\u2500 polygon_shape.png           \u2795 #generated\n        \u251c\u2500\u2500 2_ProjectileModelProc/          \u2795 #generated\n        \u2502   \u251c\u2500\u2500 Test1/                      \u2795 #generated\n        \u2502   \u2502   \u2514\u2500\u2500 comparison/             \u2795 #generated\n        \u2502   \u2502       \u251c\u2500\u2500 results.xlsx        \u2795 #generated\n        \u2502   \u2502       \u2514\u2500\u2500 model_vs_theory.png \u2795 #generated\n        \u2502   \u251c\u2500\u2500 Test2/                      \u2795 #generated\n        \u2502   \u2502   \u2514\u2500\u2500 comparison/             \u2795 #generated\n        \u2502   \u2502       \u251c\u2500\u2500 results.xlsx        \u2795 #generated\n        \u2502   \u2502       \u2514\u2500\u2500 model_vs_theory.png \u2795 #generated\n        \u2502   \u2514\u2500\u2500 Test3/                      \u2795 #generated\n        \u2502       \u2514\u2500\u2500 comparison/             \u2795 #generated\n        \u2502           \u251c\u2500\u2500 results.xlsx        \u2795 #generated\n        \u2502           \u2514\u2500\u2500 model_vs_theory.png \u2795 #generated\n        \u2514\u2500\u2500 3_TrajectoryAnalysisProc        \u2795 #generated\n            \u2514\u2500\u2500 overall_comparisons.png     \u2795 #generated\n</code></pre></p>"},{"location":"handbook/practice/#create-app","title":"Create App","text":"<p>Now that we've saw how to use a nuRemics App as an end-user, it's now time to look under the hood and explore how the App is actually built. This section dives into the developer's side of nuRemics, exposing how to define, organize, and structure a fully functional App.</p> <p>You'll start by implementing your own Procs, which encapsulate domain-specific logic and computational tasks. Then, you\u2019ll learn how to assemble these building blocks into a fully operational App.</p>"},{"location":"handbook/practice/#implement-procs","title":"Implement Procs","text":"<p>We start by defining the core building blocks of the App to be created: the Procs. Each Proc is a reusable item that encapsulates a specific piece of logic executed within the overall workflow. Internally, this logic can be further decomposed into elementary operations (Ops), implemented as individual functions (units) within the Proc itself.</p> <p>To implement our first Proc, we begin by importing the <code>Process</code> base class from <code>nuremics</code>, which all custom Procs must inherit from. To make this inheritance simple and structured, we also import the <code>attrs</code> library, which helps define clean, data-driven Python classes.</p> <pre><code>import attrs\nfrom nuremics import Process\n</code></pre> <p>We then declare our first Proc as a Python class named <code>PolygonGeometryProc</code>, inheriting from the <code>Process</code> base class. This marks it as a modular item of computation which can be executed within a nuRemics workflow.</p> <pre><code>import attrs\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n</code></pre> <p>We now declare the input data required by our <code>PolygonGeometryProc</code>, grouped into two categories: Parameters and Paths. Each input is defined using <code>attrs.field()</code> and marked with <code>metadata={\"input\": True}</code>.</p> <p>This metadata is essential: it tells the nuRemics framework that these attributes are expected as input data, ensuring they are properly tracked and managed throughout the workflow.</p> <pre><code>import attrs\nfrom pathlib import Path\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n\n    # Parameters\n    radius: float = attrs.field(init=False, metadata={\"input\": True})\n    n_sides: int = attrs.field(init=False, metadata={\"input\": True})\n\n    # Paths\n    title_file: Path = attrs.field(init=False, metadata={\"input\": True}, converter=Path)\n</code></pre> <p>In addition to the previously declared input data, a Proc can also define internal variables: attributes used during the execution of its internal logic but not provided as input data.</p> <p>These internal variables, like <code>df_points</code> in our example below, are declared without the <code>metadata={\"input\": True}</code> tag, signaling to the nuRemics framework that they are not exposed to the workflow and will be set or computed within the Proc itself.</p> <pre><code>import attrs\nimport pandas as pd\nfrom pathlib import Path\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n\n    # Parameters\n    radius: float = attrs.field(init=False, metadata={\"input\": True})\n    n_sides: int = attrs.field(init=False, metadata={\"input\": True})\n\n    # Paths\n    title_file: Path = attrs.field(init=False, metadata={\"input\": True}, converter=Path)\n\n    # Internal\n    df_points: pd.DataFrame = attrs.field(init=False)\n</code></pre> <p>The operations executed by the Proc are finally implemented as elementary functions (Ops), which are then sequentially called within the <code>__call__()</code> method to define the overall logic of the Proc.</p> <pre><code>import attrs\nimport pandas as pd\nfrom pathlib import Path\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n\n    # Parameters\n    radius: float = attrs.field(init=False, metadata={\"input\": True})\n    n_sides: int = attrs.field(init=False, metadata={\"input\": True})\n\n    # Paths\n    title_file: Path = attrs.field(init=False, metadata={\"input\": True}, converter=Path)\n\n    # Internal\n    df_points: pd.DataFrame = attrs.field(init=False)\n\n    def __call__(self):\n        super().__call__()\n\n        self.generate_polygon_shape()\n        self.plot_polygon_shape()\n\n    def generate_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n\n    def plot_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n</code></pre> <p>Note that the Proc should at some point produce output data, typically in the form of files or folders generated during the execution of its Ops. To make these output data trackable by the nuRemics framework, each must be registered in the <code>self.output_paths</code> dictionary using a label that is unique to the Proc (e.g., <code>\"coords_file\"</code>, <code>\"fig_file\"</code>).</p> <p>Using the dictionary syntax <code>self.output_paths[\"coords_file\"]</code> effectively declares an output variable named <code>coords_file</code>, which will later be instantiated by assigning it a specific file or folder name when integrating the Proc into a broader application workflow.</p> <pre><code>import attrs\nimport pandas as pd\nfrom pathlib import Path\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n\n    # Parameters\n    radius: float = attrs.field(init=False, metadata={\"input\": True})\n    n_sides: int = attrs.field(init=False, metadata={\"input\": True})\n\n    # Paths\n    title_file: Path = attrs.field(init=False, metadata={\"input\": True}, converter=Path)\n\n    # Internal\n    df_points: pd.DataFrame = attrs.field(init=False)\n\n    def __call__(self):\n        super().__call__()\n\n        self.generate_polygon_shape()\n        self.plot_polygon_shape()\n\n    def generate_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n        file = self.output_paths[\"coords_file\"]\n        # &lt;/&gt; Write file &lt;/&gt;\n\n    def plot_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n        file = self.output_paths[\"fig_file\"]\n        # &lt;/&gt; Write file &lt;/&gt;\n</code></pre> <p>Even though Procs are not intended to be executed independently by end-users, they are still designed with the possibility to run out of the box. This allows developers to easily execute them during the development phase or when implementing dedicated unit tests for a specific Proc.</p> <p>In such cases, it is important to set <code>set_inputs=True</code> when instantiating the Proc, to explicitly inform the nuRemics framework that the input data are being provided manually, outside of any workflow context.</p> <pre><code>import attrs\nimport pandas as pd\nfrom pathlib import Path\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n\n    # Parameters\n    radius: float = attrs.field(init=False, metadata={\"input\": True})\n    n_sides: int = attrs.field(init=False, metadata={\"input\": True})\n\n    # Paths\n    title_file: Path = attrs.field(init=False, metadata={\"input\": True}, converter=Path)\n\n    # Internal\n    df_points: pd.DataFrame = attrs.field(init=False)\n\n    def __call__(self):\n        super().__call__()\n\n        self.generate_polygon_shape()\n        self.plot_polygon_shape()\n\n    def generate_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n        file = self.output_paths[\"coords_file\"]\n        # &lt;/&gt; Write file &lt;/&gt;\n\n    def plot_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n        file = self.output_paths[\"fig_file\"]\n        # &lt;/&gt; Write file &lt;/&gt;\n\nif __name__ == \"__main__\":\n\n    # ================================================================== #\n    #                      USER-DEFINED PARAMETERS                       #\n    #              &gt;&gt;&gt;&gt;&gt; TO BE EDITED BY THE OPERATOR &lt;&lt;&lt;&lt;&lt;              #\n    # ================================================================== #\n\n    # Working directory\n    working_dir = Path(r\"...\")\n\n    # Input parameters\n    radius = 0.5\n    n_sides = 3\n\n    # Input paths\n    title_file = Path(r\"...\") / \"plot_title.txt\"\n\n    # Output paths\n    coords_file = \"points_coordinates.csv\"\n    fig_file = \"polygon_shape.png\"\n\n    # ================================================================== #\n\n    # Go to working directory\n    os.chdir(working_dir)\n\n    # Create dictionary containing input data\n    dict_inputs = {\n        \"radius\": radius,\n        \"n_sides\": n_sides,\n        \"title_file\": title_file,\n    }\n\n    # Create process\n    process = PolygonGeometryProc(\n        dict_inputs=dict_inputs,\n        set_inputs=True,\n    )\n\n    # Define output paths\n    process.output_paths[\"coords_file\"] = coords_file\n    process.output_paths[\"fig_file\"] = fig_file\n\n    # Run process\n    process()\n    process.finalize()\n</code></pre>"},{"location":"handbook/practice/#assemble-procs-into-app","title":"Assemble Procs into App","text":"<p>Most of the development effort has already been carried out when implementing the individual Procs. The next step consists in assembling them into a coherent App, where each Proc is instantiated, connected, and orchestrated to form a complete, executable workflow.</p> <p>We start by defining the name of our App.</p> <pre><code>APP_NAME = \"DEMO_APP\"\n</code></pre> <p>We then import the <code>Application</code> class from <code>nuremics</code>, which serves as the container and manager to define a workflow composed of multiple Procs.</p> <pre><code>from nuremics import Application\n\nAPP_NAME = \"DEMO_APP\"\n</code></pre> <p>We now import two Procs, <code>PolygonGeometryProc</code> and <code>ProjectileModelProc</code>, previously implemented. These will be the building blocks to assemble into our final App.</p> <pre><code>from nuremics import Application\nfrom labs.procs.general.PolygonGeometryProc import PolygonGeometryProc\nfrom labs.procs.general.ProjectileModelProc import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\n</code></pre> <p>The source code of the App then adopts the structure of a standard Python script, which can both be executed directly or imported as a module. This is achieved by defining a <code>main()</code> function and guarding it with the typical <code>if __name__ == \"__main__\":</code> statement.</p> <pre><code>from nuremics import Application\nfrom labs.procs.general.PolygonGeometryProc import PolygonGeometryProc\nfrom labs.procs.general.ProjectileModelProc import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\n\ndef main():\n    # Application logic here\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Inside the <code>main()</code> function, we define a list called <code>workflow</code> which contains the sequence of Procs to be executed, in the order specified. This list is made up of dictionaries, where each dictionary describes the assembly characteristics of each individual Proc into the App. This dictionary-based structure offers flexibility to easily add more parameters or options later by simply adding new keys to each dictionary in the workflow.</p> <p>Let's first define the key <code>\"process\"</code> of each dictionary, which specifies the Proc class (previously imported, e.g., <code>PolygonGeometryProc</code> and <code>ProjectileModelProc</code>) to instantiate and execute within the App workflow.</p> <pre><code>from nuremics import Application\nfrom labs.procs.general.PolygonGeometryProc import PolygonGeometryProc\nfrom labs.procs.general.ProjectileModelProc import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\n\ndef main():\n\n    # --------------- #\n    # Define workflow #\n    # --------------- #\n    workflow = [\n        {\n            \"process\": PolygonGeometryProc,\n        },\n        {\n            \"process\": ProjectileModelProc,\n        },\n    ]\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>We now create an <code>Application</code> object <code>app</code>, which acts as the core engine of our App. This object is instantiated using the previously defined inputs:</p> <ul> <li> <p><code>app_name</code>: the name of the App.</p> </li> <li> <p><code>nuremics_dir</code>: the root directory of your <code>nuremics-labs</code> repository.</p> </li> <li> <p><code>workflow</code>: the ordered list of Procs to run.</p> </li> </ul> <p>Once the <code>Application</code> object is created, calling <code>app()</code> launches the workflow execution of all the defined Procs.</p> <pre><code>import git\nfrom pathlib import Path\nfrom nuremics import Application\nfrom labs.procs.general.PolygonGeometryProc import PolygonGeometryProc\nfrom labs.procs.general.ProjectileModelProc import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\nrepo = git.Repo(Path(__file__).resolve().parent, search_parent_directories=True)\n\ndef main():\n\n    # --------------- #\n    # Define workflow #\n    # --------------- #\n    workflow = [\n        {\n            \"process\": PolygonGeometryProc,\n        },\n        {\n            \"process\": ProjectileModelProc,\n        },\n    ]\n\n    # ------------------ #\n    # Define application #\n    # ------------------ #\n    app = Application(\n        app_name=APP_NAME,\n        nuremics_dir=repo.working_tree_dir,\n        workflow=workflow,\n    )\n    # Run it!\n    app()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>At this stage, we can start executing the App and see what's happen.</p> <p>Note that nuRemics performs a structural check of each Proc by inspecting its <code>__call__</code> method. Specifically, it ensures that only functions (Ops) defined within the Proc class itself are called during execution. This design choice enforces a clean and self-contained structure for each Proc, where all internal logic remains encapsulated.</p> <p>Let's consider a case where the developer does not adhere to this enforced structural rule, for instance, by injecting additional logic directly into the <code>__call__</code> method of a Proc (in this example, in the <code>ProjectileModelProc</code> class).</p> <pre><code>    def __call__(self):\n        super().__call__()\n\n        some_variable = 2 # &lt;-- External logic added here\n\n        self.simulate_projectile_motion()\n        self.calculate_analytical_trajectory()\n        self.compare_model_vs_analytical_trajectories()\n</code></pre> <p>In this situation, nuRemics will immediately raise a structural validation error and halt execution.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| Workflow |\nDEMO_APP_____\n             |_____PolygonGeometryProc_____\n             |                             |_____generate_polygon_shape\n             |                             |_____plot_polygon_shape\n             |\n             |_____ProjectileModelProc_____(X)\n\n(X) Each process must only call its internal function(s):\n\n    def __call__(self):\n        super().__call__()\n\n        self.operation1()\n        self.operation2()\n        self.operation3()\n        ...\n</code></pre></p> <p>nuRemics is then expected to display a summary of all required input/output data for each Proc, along with their current mapping status within the App.</p> <p>At this stage, the system automatically verifies whether every required input/output data has been properly mapped within the App configuration.</p> <p>If any input parameters are missing, they are explicitly listed, and the developer is prompted to define them using either the <code>\"user_params\"</code> or <code>\"hard_params\"</code> key.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| PolygonGeometryProc |\n&gt; Input Parameter(s) :\n(float) radius  -----||----- Not defined (X)\n(int)   n_sides -----||----- Not defined (X)\n\n(X) Please define all input parameters either in \"user_params\" or \"hard_params\".\n</code></pre></p> <p>The input parameters of the Proc <code>PolygonGeometryProc</code> can be properly mapped within the App by defining the <code>\"user_params\"</code> and/or <code>\"hard_params\"</code> keys in its corresponding dictionary entry inside the <code>workflow</code> list.</p> <pre><code>import git\nfrom pathlib import Path\nfrom nuremics import Application\nfrom labs.procs.general.PolygonGeometryProc import PolygonGeometryProc\nfrom labs.procs.general.ProjectileModelProc import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\nrepo = git.Repo(Path(__file__).resolve().parent, search_parent_directories=True)\n\ndef main():\n\n    # --------------- #\n    # Define workflow #\n    # --------------- #\n    workflow = [\n        {\n            \"process\": PolygonGeometryProc,\n            \"user_params\": {\n                \"n_sides\": \"nb_sides\",\n            },\n            \"hard_params\": {\n                \"radius\": 0.5,\n            },\n        },\n        {\n            \"process\": ProjectileModelProc,\n        },\n    ]\n\n    # ------------------ #\n    # Define application #\n    # ------------------ #\n    app = Application(\n        app_name=APP_NAME,\n        nuremics_dir=repo.working_tree_dir,\n        workflow=workflow,\n    )\n    # Run it!\n    app()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>When running the App again, nuRemics detects that all required input parameters for <code>PolygonGeometryProc</code> have been successfully mapped. However, it now reports that one or more input paths are missing. These are explicitly listed, and the developer is prompted to define them using either the <code>\"user_paths\"</code> or <code>\"required_paths\"</code> key.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| PolygonGeometryProc |\n&gt; Input Parameter(s) :\n(float) radius  -----||----- 0.5      (hard_params)\n(int)   n_sides -----||----- nb_sides (user_params)\n&gt; Input Path(s) :\ntitle_file -----||----- Not defined (X)\n\n(X) Please define all input paths either in \"user_paths\" or \"required_paths\".\n</code></pre></p> <p>The input paths of the Proc <code>PolygonGeometryProc</code> can be properly mapped within the App by defining the <code>\"user_paths\"</code> and/or <code>\"required_paths\"</code> keys in its corresponding dictionary entry inside the workflow list.</p> <pre><code>import git\nfrom pathlib import Path\nfrom nuremics import Application\nfrom labs.procs.general.PolygonGeometryProc import PolygonGeometryProc\nfrom labs.procs.general.ProjectileModelProc import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\nrepo = git.Repo(Path(__file__).resolve().parent, search_parent_directories=True)\n\ndef main():\n\n    # --------------- #\n    # Define workflow #\n    # --------------- #\n    workflow = [\n        {\n            \"process\": PolygonGeometryProc,\n            \"user_params\": {\n                \"n_sides\": \"nb_sides\",\n            },\n            \"hard_params\": {\n                \"radius\": 0.5,\n            },\n            \"user_paths\": {\n                \"title_file\": \"plot_title.txt\",\n            },\n        },\n        {\n            \"process\": ProjectileModelProc,\n        },\n    ]\n\n    # ------------------ #\n    # Define application #\n    # ------------------ #\n    app = Application(\n        app_name=APP_NAME,\n        nuremics_dir=repo.working_tree_dir,\n        workflow=workflow,\n    )\n    # Run it!\n    app()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>When running the App again, nuRemics detects that all required input paths for <code>PolygonGeometryProc</code> have been successfully mapped. However, it now reports that one or more output paths are missing. These are explicitly listed, and the developer is prompted to define them using the <code>\"output_paths\"</code> key.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| PolygonGeometryProc |\n&gt; Input Parameter(s) :\n(float) radius  -----||----- 0.5      (hard_params)\n(int)   n_sides -----||----- nb_sides (user_params)\n&gt; Input Path(s) :\ntitle_file -----||----- plot_title.txt (user_paths)\n&gt; Input Analysis :\nNone.\n&gt; Output Path(s) :\ncoords_file -----||----- Not defined (X)\nfig_file    -----||----- Not defined (X)\n\n(X) Please define all output paths in \"output_paths\".\n</code></pre></p> <p>The output paths of the Proc <code>PolygonGeometryProc</code> can be properly mapped within the App by defining the <code>\"output_paths\"</code> key in its corresponding dictionary entry inside the workflow list.</p> <p>In the same way, we also complete the mapping for the Proc <code>ProjectileModelProc</code> by providing all required entries: <code>\"user_params\"</code> and/or <code>\"hard_params\"</code>, <code>\"user_paths\"</code> and/or <code>\"required_paths\"</code>, <code>\"output_paths\"</code>.</p> <pre><code>import git\nfrom pathlib import Path\nfrom nuremics import Application\nfrom labs.procs.general.PolygonGeometryProc import PolygonGeometryProc\nfrom labs.procs.general.ProjectileModelProc import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\nrepo = git.Repo(Path(__file__).resolve().parent, search_parent_directories=True)\n\ndef main():\n\n    # --------------- #\n    # Define workflow #\n    # --------------- #\n    workflow = [\n        {\n            \"process\": PolygonGeometryProc,\n            \"user_params\": {\n                \"n_sides\": \"nb_sides\",\n            },\n            \"hard_params\": {\n                \"radius\": 0.5,\n            },\n            \"user_paths\": {\n                \"title_file\": \"plot_title.txt\",\n            },\n            \"output_paths\": {\n                \"coords_file\": \"points_coordinates.csv\",\n                \"fig_file\": \"polygon_shape.png\",\n            },\n        },\n        {\n            \"process\": ProjectileModelProc,\n            \"user_params\": {\n                \"gravity\": \"gravity\",\n                \"mass\": \"mass\",\n            },\n            \"user_paths\": {\n                \"velocity_file\": \"velocity.json\",\n                \"configs_folder\": \"configs\",\n            },\n            \"required_paths\": {\n                \"coords_file\": \"points_coordinates.csv\",\n            },\n            \"output_paths\": {\n                \"comp_folder\": \"comparison\",\n            },\n        },\n    ]\n\n    # ------------------ #\n    # Define application #\n    # ------------------ #\n    app = Application(\n        app_name=APP_NAME,\n        nuremics_dir=repo.working_tree_dir,\n        workflow=workflow,\n    )\n    # Run it!\n    app()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>With all required mappings now properly defined for each Proc, the App can be executed without raising any errors. nuRemics confirms that the full mapping is complete by prompting a summary for each Proc, indicating that all input parameters, input paths, and output paths have been successfully resolved.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| PolygonGeometryProc |\n&gt; Input Parameter(s) :\n(float) radius  -----||----- 0.5      (hard_params)\n(int)   n_sides -----||----- nb_sides (user_params)\n&gt; Input Path(s) :\ntitle_file -----||----- plot_title.txt (user_paths)\n&gt; Input Analysis :\nNone.\n&gt; Output Path(s) :\ncoords_file -----||----- points_coordinates.csv (output_paths)\nfig_file    -----||----- polygon_shape.png      (output_paths)\n\n| ProjectileModelProc |\n&gt; Input Parameter(s) :\n(float) gravity -----||----- gravity (user_params)\n(float) mass    -----||----- mass    (user_params)\n&gt; Input Path(s) :\nvelocity_file  -----||----- velocity.json          (user_paths)\nconfigs_folder -----||----- configs                (user_paths)\ncoords_file    -----||----- points_coordinates.csv (required_paths)\n&gt; Input Analysis :\nNone.\n&gt; Output Path(s) :\ncomp_folder -----||----- comparison (output_paths)\n</code></pre></p> <p>As the App has now been fully assembled, nuRemics displays a clean summary of its I/O interface, as it will appear to the end-user. This summary includes all declared user parameters (<code>\"user_params\"</code>) and user paths (<code>\"user_paths\"</code>) required as inputs, along with the corresponding output files and folders that the App will generate. It serves as an explicit interface contract, allowing end-users to clearly understand what data they need to provide and what results to expect.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; INPUTS &lt;\n\n| User Parameters |\n&gt; nb_sides (int)\n&gt; gravity (float)\n&gt; mass (float)\n\n| User Paths |\n&gt; plot_title.txt\n&gt; velocity.json\n&gt; configs\n\n&gt; OUTPUTS &lt;\n\n&gt; points_coordinates.csv\n&gt; polygon_shape.png\n&gt; comparison\n</code></pre></p> <p>With all Procs implemented and properly assembled within the App, the development work is now complete. The developer\u2019s responsibility ends here (excluding, of course, the implementation of unit tests to ensure long-term maintainability, which falls outside the scope of this tutorial).</p> <p>The App is now fully functional and ready to be operated by end-users. From this point, users can interact with the App through its declared I/O interface, without needing to modify or understand the underlying code structure.</p>  Explore nuRemics in:       Theory"},{"location":"handbook/theory/","title":"Theory","text":""},{"location":"handbook/theory/#design-patterns","title":"Design Patterns","text":"<p>Let\u2019s introduce the core design patterns behind Procs and Apps in nuRemics.</p>"},{"location":"handbook/theory/#proc","title":"Proc","text":"<p>A Proc can be seen as an algorithmic box which processes some input data and produces corresponding output data.</p> <p>The input data typically fall into two main categories:</p> <ul> <li> <p>Input parameters: Scalar values such as <code>float</code>, <code>int</code>, <code>bool</code>, or <code>str</code>.</p> </li> <li> <p>Input paths: Files or folders provided as <code>Path</code> objects (from Python's <code>pathlib</code> module), pointing to structured data on disk.</p> </li> </ul> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n\n  **Parameters** {\n    float radius\n    int n_sides\n  }\n  **Paths** {\n    file title_file \"txt\"\n  }</code></pre> <p>As mentioned in the Handbook Overview, the algorithmic box of the Proc is a class composed of functions (Op) called sequentially within its <code>__call__</code> method.</p> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **PolygonGeometryProc** : feeds\n\n  **Parameters** {\n    float radius\n    int n_sides\n  }\n  **Paths** {\n    file title_file \"txt\"\n  }\n  **PolygonGeometryProc** {\n    op generate_polygon_shape\n    op plot_polygon_shape\n  }</code></pre> <p>Output data are typically expressed as <code>Path</code> objects as well, corresponding to files or folders written to disk during the execution of the Proc.</p> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **PolygonGeometryProc** : feeds\n  **PolygonGeometryProc** ||--|| **Outputs** : generates\n\n  **Parameters** {\n    float radius\n    int n_sides\n  }\n  **Paths** {\n    file title_file \"txt\"\n  }\n  **PolygonGeometryProc** {\n    op generate_polygon_shape\n    op plot_polygon_shape\n  }\n  **Outputs** {\n    file coords_file \"csv\"\n    file fig_file \"png\"\n  }</code></pre> <p>For the sake of example, let's define another Proc considering the same structure.</p> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **ProjectileModelProc** : feeds\n  **ProjectileModelProc** ||--|| **Outputs** : generates\n\n  **Parameters** {\n    float gravity\n    float mass\n  }\n  **Paths** {\n    file velocity_file \"json\"\n    folder configs_folder \"_\"\n    file coords_file \"csv\"\n  }\n  **ProjectileModelProc** {\n    op simulate_projectile_motion\n    op calculate_analytical_trajectory\n    op compare_model_vs_analytical_trajectories\n  }\n  **Outputs** {\n    folder comp_folder \"_\"\n  }</code></pre>"},{"location":"handbook/theory/#app","title":"App","text":"<p>A final end-user App can be built by plugging together previously implemented Procs, and specifying their sequential order of execution within the workflow.</p> <pre><code>flowchart RL\n  **PolygonGeometryProc** e1@--1--o **DEMO_APP**\n  **ProjectileModelProc** e2@--2--o **DEMO_APP**\n  **TrajectoryAnalysisProc** e3@--3--o **DEMO_APP**\n  **generate_polygon_shape** e4@--A--o **PolygonGeometryProc**\n  **plot_polygon_shape** e5@--B--o **PolygonGeometryProc**\n  **simulate_projectile_motion** e6@--A--o **ProjectileModelProc**\n  **calculate_analytical_trajectory** e7@--B--o **ProjectileModelProc**\n  **compare_model_vs_analytical_trajectories** e8@--C--o **ProjectileModelProc**\n  **plot_overall_model_vs_theory** e9@--A--o **TrajectoryAnalysisProc**\n  e1@{ animate: true }\n  e2@{ animate: true }\n  e3@{ animate: true }\n  e4@{ animate: true }\n  e5@{ animate: true }\n  e6@{ animate: true }\n  e7@{ animate: true }\n  e8@{ animate: true }\n  e9@{ animate: true }</code></pre> <p>Each Proc integrated into the App defines its own set of inputs and outputs, specific to its internal algorithmic logic. When these Procs are assembled into a workflow, the App itself exposes a higher-level set of inputs and outputs. These define the I/O interface presented to the end-user, who provides the necessary input data and retrieves the final results upon execution.</p> <p>The assembly step is performed through a mapping between the internal I/O data of each Proc and the global I/O interface of the App. This mapping mechanism serves multiple purposes:</p> <ul> <li> <p>It defines which data are exposed to the end-user (and how they are displayed) and which remain internal to the workflow.</p> </li> <li> <p>It manages the data dependencies between Procs, when the output of one Proc is used as input for another.</p> </li> </ul> <p>This notably ensures a coherent and seamless management of data across the workflow, while delivering a clean and focused I/O interface tailored to the user's needs.</p> <p>The mapping between a Proc and the App starts by specifying which Proc input parameters are exposed to the end-user, and how they are labeled in the App input interface.</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }</code></pre> <p>The Proc input parameters that remain internal to the workflow are assigned fixed values directly within the mapping definition, without being exposed to the end-user.</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n  **hard_params** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }\n  **hard_params** {\n    float radius \"0.5\"\n  }</code></pre> <p>The Proc input paths that need to be provided by the end-user are specified by defining the expected file or folder names within the App input interface.</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n  **hard_params** ||--|| **PolygonGeometryProc** : mapping\n  **user_paths** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }\n  **hard_params** {\n    float radius \"0.5\"\n  }\n  **user_paths** {\n    file title_file \"plot_title.txt\"\n  }</code></pre> <p>The Proc input paths can also be mapped to output paths produced by a previous Proc within the workflow (although this does not apply here, as we are currently focusing on the first Proc in the workflow).</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **DEMO_APP** ||--|| **required_paths** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n  **hard_params** ||--|| **PolygonGeometryProc** : mapping\n  **user_paths** ||--|| **PolygonGeometryProc** : mapping\n  **required_paths** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }\n  **hard_params** {\n    float radius \"0.5\"\n  }\n  **user_paths** {\n    file title_file \"plot_title.txt\"\n  }\n  **required_paths** {\n    _ _ \"_\"\n  }</code></pre> <p>Finally, the Proc output paths are specified by indicating the name of the file(s) or folder(s) that will be written by the Proc during the workflow execution.</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **DEMO_APP** ||--|| **required_paths** : mapping\n  **DEMO_APP** ||--|| **output_paths** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n  **hard_params** ||--|| **PolygonGeometryProc** : mapping\n  **user_paths** ||--|| **PolygonGeometryProc** : mapping\n  **required_paths** ||--|| **PolygonGeometryProc** : mapping\n  **output_paths** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }\n  **hard_params** {\n    float radius \"0.5\"\n  }\n  **user_paths** {\n    file title_file \"plot_title.txt\"\n  }\n  **required_paths** {\n    _ _ \"_\"\n  }\n  **output_paths** {\n    file coords_file \"points_coordinates.csv\"\n    file fig_file \"polygon_shape.png\"\n  }</code></pre> <p>Let's now assemble the second Proc to be executed by the App within the workflow, by establishing a dependency: the output data produced by the first Proc will serve as input data for this second one.</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **DEMO_APP** ||--|| **required_paths** : mapping\n  **DEMO_APP** ||--|| **output_paths** : mapping\n  **user_params** ||--|| **ProjectileModelProc** : mapping\n  **hard_params** ||--|| **ProjectileModelProc** : mapping\n  **user_paths** ||--|| **ProjectileModelProc** : mapping\n  **required_paths** ||--|| **ProjectileModelProc** : mapping\n  **output_paths** ||--|| **ProjectileModelProc** : mapping\n\n  **user_params** {\n    float gravity \"gravity\"   \n    float mass \"mass\"\n  }\n  **hard_params** {\n    _ _ \"_\"\n  }\n  **user_paths** {\n    file velocity_file \"velocity.json\"\n    folder configs_folder \"configs\"\n  }\n  **required_paths** {\n    file coords_file \"points_coordinates.csv\"\n  }\n  **output_paths** {\n    folder comp_folder \"comparison\"\n  }</code></pre> <p>Once all Procs have been assembled into the App, the final I/O interface presented to the end-user emerges.</p> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path1[\"plot_title.txt _(file)_\"]\n      path2[\"velocity.json _(file)_\"]\n      path3[\"configs _(folder)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"nb_sides _(int)_\"]\n      param2[\"gravity _(float)_\"]\n      param3[\"mass _(float)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc1[\"PolygonGeometryProc\"]\n    proc2[\"ProjectileModelProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out1[\"points_coordinates.csv _(file)_\"]\n    out2[\"polygon_shape.png _(file)_\"]\n    out3[\"comparison _(folder)_\"]\n  end\n\n  **INPUTS** --&gt; **DEMO_APP**\n  **DEMO_APP** --&gt; **OUTPUTS**</code></pre> <p>It is also insightful for the end-user to present this I/O interface by showing which INPUTS are used by each Proc of the App, and which OUTPUTS are written by each of them.</p> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path1[\"plot_title.txt _(file)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"nb_sides _(int)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc1[\"PolygonGeometryProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out1[\"points_coordinates.csv _(file)_\"]\n    out2[\"polygon_shape.png _(file)_\"]\n  end\n\n  **INPUTS** --&gt; proc1\n  proc1 --&gt; **OUTPUTS**</code></pre> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path2[\"velocity.json _(file)_\"]\n      path3[\"configs _(folder)_\"]\n      out1[\"points_coordinates.csv _(file)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param2[\"gravity _(float)_\"]\n      param3[\"mass _(float)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc2[\"ProjectileModelProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out3[\"comparison _(folder)_\"]\n  end\n\n  **INPUTS** --&gt; proc2\n  proc2 --&gt; **OUTPUTS**\n\n  classDef blueBox fill:#d0e6ff,stroke:#339,stroke-width:1.5px;\n  class out1 blueBox;</code></pre>"},{"location":"handbook/theory/#usability","title":"Usability","text":"<p>The Apps built with nuRemics come with a lean and pragmatic user interface by design. No flashy GUI, but instead, the focus is on simplicity and efficiency:</p> <ul> <li> <p>An input database that the operator completes by editing configuration files and uploading the required input files and folders.</p> </li> <li> <p>A terminal interface that provides informative feedback at each execution, clearly indicating what the App is doing and what actions are expected from the operator.</p> </li> <li> <p>An output database that stores all results in a well-structured and traceable folder hierarchy.</p> </li> </ul> <pre><code>sequenceDiagram\n    actor Operator\n    Operator-&gt;&gt;DEMO_APP: Execution\n    DEMO_APP-&gt;&gt;INPUTS: Initialize database\n    DEMO_APP-&gt;&gt;Operator: Terminal feedback\n    Operator-&gt;&gt;INPUTS: Complete database\n    Operator-&gt;&gt;DEMO_APP: Execution\n    DEMO_APP-&gt;&gt;INPUTS: Read database\n    DEMO_APP-&gt;&gt;OUTPUTS: Write database\n    DEMO_APP-&gt;&gt;Operator: Terminal feedback\n    Operator-&gt;&gt;OUTPUTS: Access results</code></pre> <p>This streamlined approach prioritizes clarity, control, and reproducibility, making each App built with nuRemics well-suited for both direct interaction by end-users and seamless integration into larger software ecosystems. In such environments, nuRemics can operate as a backend computational engine, interacting programmatically with other tools (such as web applications) that provide their own user interfaces.</p>"},{"location":"handbook/theory/#configuration","title":"Configuration","text":"<p>When running an App, the operator first defines a set of studies aimed at exploring the INPUTS space and analyzing the outcomes in the OUTPUTS space.</p> <pre><code>flowchart LR\n    Study_Shape\n    Study_Velocity</code></pre> <p>The operator then configures each study by selecting which inputs stay constant (Fixed) and which ones change (Variable) across the various experiments.</p> <pre><code>flowchart LR\n\n  subgraph Fixed1[\"**Fixed**\"]\n    direction TB\n\n    subgraph Paths_Fixed1[\"**Paths**\"]\n      direction LR\n      path1_1[\"plot_title.txt\"]\n      path2_1[\"velocity.json\"]\n      path3_1[\"configs\"]\n    end\n\n    subgraph Parameter_Fixed1[\"**Parameters**\"]\n      direction LR\n      param2_1[\"gravity\"]\n      param3_1[\"mass\"]\n    end\n  end\n\n  subgraph Variable1[\"**Variable**\"]\n    direction TB\n\n    subgraph Paths_Variable1[\"**Paths**\"]\n      direction LR\n      no_path[\"_\"]\n    end\n\n    subgraph Parameter_Variable1[\"**Parameters**\"]\n      direction LR\n      param1_1[\"nb_sides\"]\n    end\n  end\n\n  Study_Shape --&gt; Fixed1\n  Study_Shape --&gt; Variable1\n\n  subgraph Fixed2[\"**Fixed**\"]\n    direction TB\n\n    subgraph Paths_Fixed2[\"**Paths**\"]\n      direction LR\n      path1_2[\"plot_title.txt\"]\n      path3_2[\"configs\"]\n    end\n\n    subgraph Parameter_Fixed2[\"**Parameters**\"]\n      direction LR\n      param1_2[\"nb_sides\"]\n      param2_2[\"gravity\"]\n      param3_2[\"mass\"]\n    end\n  end\n\n  subgraph Variable2[\"**Variable**\"]\n    direction TB\n\n    subgraph Paths_Variable2[\"**Paths**\"]\n      direction LR\n      path2_2[\"velocity.json\"]\n    end\n\n    subgraph Parameter_Variable2[\"**Parameters**\"]\n      direction LR\n      no_param[\"_\"]\n    end\n  end\n\n  Study_Velocity --&gt; Fixed2\n  Study_Velocity --&gt; Variable2</code></pre>"},{"location":"handbook/theory/#settings","title":"Settings","text":"<p>To conduct experiments, the operator assigns values for both fixed and variable inputs: fixed inputs remain constant across all experiments (Common), while variable inputs are adjusted from one experiment to another (Test1, Test2, ...).</p> <pre><code>flowchart LR\n    Study_Shape --&gt; Study1_Common[\"Common\"]\n    Study_Shape --&gt; Study1_Test1[\"Test1\"]\n    Study_Shape --&gt; Study1_Test2[\"Test2\"]\n    Study_Shape --&gt; Study1_Test3[\"...\"]\n\n    Study1_Common --&gt; common1_param2[\"gravity = ...\"]\n    Study1_Common --&gt; common1_param3[\"mass = ...\"]\n    Study1_Common --&gt; common1_input1[\"plot_title.txt _(uploaded)_\"]\n    Study1_Common --&gt; common1_input2[\"velocity.json _(uploaded)_\"]\n    Study1_Common --&gt; common1_input3[\"configs _(uploaded)_\"]\n\n    Study1_Test1 --&gt; test1_param1[\"nb_sides = ...\"]\n    Study1_Test2 --&gt; test2_param1[\"nb_sides = ...\"]\n    Study1_Test3 --&gt; test3_param1[\"nb_sides = ...\"]\n\n    Study_Velocity --&gt; Study2_Common[\"Common\"]\n    Study_Velocity --&gt; Study2_Test1[\"Test1\"]\n    Study_Velocity --&gt; Study2_Test2[\"Test2\"]\n    Study_Velocity --&gt; Study2_Test3[\"...\"]\n\n    Study2_Common --&gt; common2_param1[\"nb_sides = ...\"]\n    Study2_Common --&gt; common2_param2[\"gravity = ...\"]\n    Study2_Common --&gt; common2_param3[\"mass = ...\"]\n    Study2_Common --&gt; common2_input1[\"plot_title.txt _(uploaded)_\"]\n    Study2_Common --&gt; common2_input3[\"configs _(uploaded)_\"]\n\n    Study2_Test1 --&gt; test1_path2[\"velocity.json _(uploaded)_\"]\n    Study2_Test2 --&gt; test2_path2[\"velocity.json _(uploaded)_\"]\n    Study2_Test3 --&gt; test3_path2[\"velocity.json _(uploaded)_\"]</code></pre>"},{"location":"handbook/theory/#results","title":"Results","text":"<p>At the end of the execution, results are stored in a structured output tree, ready for review or further processing. The outputs are first organized by Proc, each of them writing its own result data. Within each Proc, the results are further subdivided by experiment (Test1, Test2, ...), ensuring a clear separation and traceability of outcomes across the entire study.</p> <p>This organization is automatically determined based on how the study is configured by the operator. nuRemics analyzes which input data are marked as fixed or variable, and how they connect to the internal workflow of the App. If a Proc directly depends on variable inputs, or indirectly through upstream dependencies, it will generate distinct outputs for each experiment. Otherwise, it will produce shared outputs only once.</p> <p>This logic ensures that only the necessary parts of the workflow are repeated through experimentations, and that the output structure faithfully reflects the configuration of the study along with the internal dependencies within the workflow.</p> <pre><code>flowchart LR\n    Study_Shape --&gt; Study1_PolygonGeometryProc[\"PolygonGeometryProc\"]\n    Study_Shape --&gt; Study1_ProjectileModelProc[\"ProjectileModelProc\"]\n\n    Study1_PolygonGeometryProc --&gt; Study1_PolygonGeometryProc_Test1[\"Test1\"]\n    Study1_PolygonGeometryProc --&gt; Study1_PolygonGeometryProc_Test2[\"Test2\"]\n    Study1_PolygonGeometryProc --&gt; Study1_PolygonGeometryProc_Test3[\"...\"]\n\n    Study1_PolygonGeometryProc_Test1 --&gt; Study1_PolygonGeometryProc_Test1_output1[\"points_coordinates.csv\"]\n    Study1_PolygonGeometryProc_Test1 --&gt; Study1_PolygonGeometryProc_Test1_output2[\"polygon_shape.png\"]\n    Study1_PolygonGeometryProc_Test2 --&gt; Study1_PolygonGeometryProc_Test2_output1[\"points_coordinates.csv\"]\n    Study1_PolygonGeometryProc_Test2 --&gt; Study1_PolygonGeometryProc_Test2_output2[\"polygon_shape.png\"]\n    Study1_PolygonGeometryProc_Test3 --&gt; Study1_PolygonGeometryProc_Test3_output1[\"points_coordinates.csv\"]\n    Study1_PolygonGeometryProc_Test3 --&gt; Study1_PolygonGeometryProc_Test3_output2[\"polygon_shape.png\"]\n\n    Study1_ProjectileModelProc --&gt; Study1_ProjectileModelProc_Test1[\"Test1\"]\n    Study1_ProjectileModelProc --&gt; Study1_ProjectileModelProc_Test2[\"Test2\"]\n    Study1_ProjectileModelProc --&gt; Study1_ProjectileModelProc_Test3[\"...\"]\n\n    Study1_ProjectileModelProc_Test1 --&gt; Study1_ProjectileModelProc_Test1_output3[\"comparison\"]\n    Study1_ProjectileModelProc_Test2 --&gt; Study1_ProjectileModelProc_Test2_output3[\"comparison\"]\n    Study1_ProjectileModelProc_Test3 --&gt; Study1_ProjectileModelProc_Test3_output3[\"comparison\"]\n\n    Study_Velocity --&gt; Study2_PolygonGeometryProc[\"PolygonGeometryProc\"]\n    Study_Velocity --&gt; Study2_ProjectileModelProc[\"ProjectileModelProc\"]\n\n    Study2_PolygonGeometryProc --&gt; Study2_PolygonGeometryProc_Common_output1[\"points_coordinates.csv\"]\n    Study2_PolygonGeometryProc --&gt; Study2_PolygonGeometryProc_Common_output2[\"polygon_shape.png\"]\n\n    Study2_ProjectileModelProc --&gt; Study2_ProjectileModelProc_Test1[\"Test1\"]\n    Study2_ProjectileModelProc --&gt; Study2_ProjectileModelProc_Test2[\"Test2\"]\n    Study2_ProjectileModelProc --&gt; Study2_ProjectileModelProc_Test3[\"...\"]\n\n    Study2_ProjectileModelProc_Test1 --&gt; Study2_ProjectileModelProc_Test1_output3[\"comparison\"]\n    Study2_ProjectileModelProc_Test2 --&gt; Study2_ProjectileModelProc_Test2_output3[\"comparison\"]\n    Study2_ProjectileModelProc_Test3 --&gt; Study2_ProjectileModelProc_Test3_output3[\"comparison\"]</code></pre>  Explore nuRemics in:       Practice"},{"location":"labs/apps/cms/CANTILEVER_SHEAR_APP/app/","title":"CANTILEVER_SHEAR_APP","text":""},{"location":"labs/apps/cms/CANTILEVER_SHEAR_APP/app/#workflow","title":"Workflow","text":"<ol> <li><code>GeometryProc</code>: Create a geometric representation of a physical system.   A/ <code>create_geometry</code>: Create and export a simple geometric entity (beam, plate, or block) in STEP or BREP format.</li> <li><code>LabelingProc</code>: Define and label the entities of a physical system from its geometric representation.   A/ <code>label_entities</code>: Assign labels to the entities of a geometric model.</li> </ol> <pre><code>flowchart RL\n  **GeometryProc** e1@--1--o **CANTILEVER_SHEAR_APP**\n  **LabelingProc** e2@--2--o **CANTILEVER_SHEAR_APP**\n  **create_geometry** e3@--A--o **GeometryProc**\n  **label_entities** e4@--A--o **LabelingProc**\n  e1@{ animate: true }\n  e2@{ animate: true }\n  e3@{ animate: true }\n  e4@{ animate: true }</code></pre>"},{"location":"labs/apps/cms/CANTILEVER_SHEAR_APP/app/#mapping","title":"Mapping","text":"<pre><code>erDiagram\n  **CANTILEVER_SHEAR_APP** ||--|| **user_params** : mapping\n  **CANTILEVER_SHEAR_APP** ||--|| **hard_params** : mapping\n  **CANTILEVER_SHEAR_APP** ||--|| **output_paths** : mapping\n  **user_params** ||--|| **GeometryProc** : mapping\n  **hard_params** ||--|| **GeometryProc** : mapping\n  **output_paths** ||--|| **GeometryProc** : mapping\n\n  **user_params** {\n    int dim \"dimension\"\n  }\n  **hard_params** {\n    float length \"10.0\"\n    float width \"1.0\"\n    float height \"0.1\"\n  }\n  **output_paths** {\n    file outfile \"geometry.(step/brep)\"\n  }</code></pre> <pre><code>erDiagram\n  **CANTILEVER_SHEAR_APP** ||--|| **user_params** : mapping\n  **CANTILEVER_SHEAR_APP** ||--|| **required_paths** : mapping\n  **CANTILEVER_SHEAR_APP** ||--|| **output_paths** : mapping\n  **user_params** ||--|| **LabelingProc** : mapping\n  **required_paths** ||--|| **LabelingProc** : mapping\n  **output_paths** ||--|| **LabelingProc** : mapping\n\n  **user_params** {\n    int dim \"dimension\"\n  }\n  **required_paths** {\n    file infile \"geometry.(step/brep)\"\n  }\n  **output_paths** {\n    file outfile \"labels.json\"\n  }</code></pre>"},{"location":"labs/apps/cms/CANTILEVER_SHEAR_APP/app/#io-interface","title":"I/O Interface","text":"<pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path[\"_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"dimension _(int)_\"]\n    end\n  end\n\n  subgraph **CANTILEVER_SHEAR_APP**\n    direction RL\n    proc1[\"GeometryProc\"]\n    proc2[\"LabelingProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out1[\"geometry.(step/brep) _(file)_\"]\n    out2[\"labels.json _(file)_\"]\n  end\n\n  **INPUTS** --&gt; **CANTILEVER_SHEAR_APP**\n  **CANTILEVER_SHEAR_APP** --&gt; **OUTPUTS**</code></pre> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path[\"_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"dimension _(int)_\"]\n    end\n  end\n\n  subgraph **CANTILEVER_SHEAR_APP**\n    direction RL\n    proc1[\"GeometryProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out1[\"geometry.(step/brep) _(file)_\"]\n  end\n\n  **INPUTS** --&gt; proc1\n  proc1 --&gt; **OUTPUTS**</code></pre> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      out1[\"geometry.(step/brep) _(file)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"dimension _(int)_\"]\n    end\n\n  end\n\n  subgraph **CANTILEVER_SHEAR_APP**\n    direction RL\n    proc2[\"LabelingProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out2[\"labels.json _(file)_\"]\n  end\n\n  **INPUTS** --&gt; proc2\n  proc2 --&gt; **OUTPUTS**\n\n  classDef blueBox fill:#d0e6ff,stroke:#339,stroke-width:1.5px;\n  class out1 blueBox;</code></pre>"},{"location":"labs/apps/cms/CANTILEVER_SHEAR_APP/app/#inputs","title":"INPUTS","text":""},{"location":"labs/apps/cms/CANTILEVER_SHEAR_APP/app/#parameters","title":"Parameters","text":"<ul> <li><code>dimension</code>: Dimension of the geometry: 1 for a line (beam), 2 for a rectangle (plate), 3 for a box (block).</li> </ul>"},{"location":"labs/apps/cms/CANTILEVER_SHEAR_APP/app/#paths","title":"Paths","text":"<p>N/A</p>"},{"location":"labs/apps/cms/CANTILEVER_SHEAR_APP/app/#outputs","title":"OUTPUTS","text":"<ul> <li><code>geometry.(step/brep)</code>: File containing the geometric model (in .step if <code>dim</code> = 3|2 or .brep if <code>dim</code> = 1).</li> <li><code>labels.json</code>: File containing the labeled geometric entities.</li> </ul>      View source code"},{"location":"labs/apps/cms/CANTILEVER_SHEAR_APP/procs/GeometryProc/","title":"GeometryProc","text":""},{"location":"labs/apps/cms/CANTILEVER_SHEAR_APP/procs/GeometryProc/#process","title":"Process","text":"<p>Create a geometric representation of a physical system. A/ <code>create_geometry</code>: Create and export a simple geometric entity (beam, plate, or block) in STEP or BREP format.</p> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **GeometryProc** : feeds\n  **GeometryProc** ||--|| **Outputs** : generates\n\n  **Parameters** {\n    int dim\n    float length\n    float width\n    float height\n  }\n  **Paths** {\n    _ _ \"_\"\n  }\n  **GeometryProc** {\n    op create_geometry\n  }\n  **Outputs** {\n    file outfile \"step/brep\"\n  }</code></pre>"},{"location":"labs/apps/cms/CANTILEVER_SHEAR_APP/procs/GeometryProc/#input-parameters","title":"Input Parameter(s)","text":"<ul> <li><code>dim</code>: Dimension of the geometry: 1 for a line (beam), 2 for a rectangle (plate), 3 for a box (block).</li> <li><code>length</code>: Length of the geometry along the X axis.</li> <li><code>width</code>: Width of the geometry along the Y axis (only used if dim = 2|3).</li> <li><code>height</code>: Height of the geometry along the Z axis (only used if dim = 3).</li> </ul>"},{"location":"labs/apps/cms/CANTILEVER_SHEAR_APP/procs/GeometryProc/#output-paths","title":"Output Path(s)","text":"<ul> <li><code>outfile</code>: File containing the geometric model (in .step if <code>dim</code> = 3|2 or .brep if <code>dim</code> = 1).</li> </ul>      View source code"},{"location":"labs/apps/cms/CANTILEVER_SHEAR_APP/procs/LabelingProc/","title":"LabelingProc","text":""},{"location":"labs/apps/cms/CANTILEVER_SHEAR_APP/procs/LabelingProc/#process","title":"Process","text":"<p>Define and label the entities of a physical system from its geometric representation. A/ <code>label_entities</code>: Assign labels to the entities of a geometric model.</p> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **LabelingProc** : feeds\n  **LabelingProc** ||--|| **Outputs** : generates\n\n  **Parameters** {\n    int dim\n  }\n  **Paths** {\n    file infile \"step/brep\"\n  }\n  **LabelingProc** {\n    op label_entities\n  }\n  **Outputs** {\n    file outfile \"json\"\n  }</code></pre>"},{"location":"labs/apps/cms/CANTILEVER_SHEAR_APP/procs/LabelingProc/#input-parameters","title":"Input Parameter(s)","text":"<ul> <li><code>dim</code>: Dimension of the geometry: 1 for a line (beam), 2 for a rectangle (plate), 3 for a box (block).</li> </ul>"},{"location":"labs/apps/cms/CANTILEVER_SHEAR_APP/procs/LabelingProc/#input-paths","title":"Input Path(s)","text":"<ul> <li><code>infile</code>: File containing the geometric model (in .step if <code>dim</code> = 3|2 or .brep if <code>dim</code> = 1).</li> </ul>"},{"location":"labs/apps/cms/CANTILEVER_SHEAR_APP/procs/LabelingProc/#output-paths","title":"Output Path(s)","text":"<ul> <li><code>outfile</code>: File containing the labeled geometric entities.</li> </ul>      View source code"},{"location":"labs/apps/general/DEMO_APP/","title":"DEMO_APP","text":""},{"location":"labs/apps/general/DEMO_APP/#workflow","title":"Workflow","text":"<ol> <li><code>PolygonGeometryProc</code>: Generate and plot a regular 2D polygon shape.   A/ <code>generate_polygon_shape</code>: Generate the 2D coordinates of a regular polygon.   B/ <code>plot_polygon_shape</code>: Plot a closed 2D polygon from a set of points.</li> <li><code>ProjectileModelProc</code>: Simulate the motion of a projectile and compare its trajectory with the analytical solution.   A/ <code>simulate_projectile_motion</code>: Simulate the motion of a 2D rigid body under gravity projected with an initial velocity.   B/ <code>calculate_analytical_trajectory</code>: Calculate the theoretical trajectory of a projectile using analytical equations.   C/ <code>compare_model_vs_analytical_trajectories</code>: Plot and save the comparison between simulated (model) and theoretical projectile trajectories.</li> <li><code>TrajectoryAnalysisProc</code>: Perform overall comparisons between simulated (model) and theoretical trajectories.   A/ <code>plot_overall_model_vs_theory</code>: Generate overall comparative plots of simulated (model) and theoritical trajectories.</li> </ol> <pre><code>flowchart RL\n  **PolygonGeometryProc** e1@--1--o **DEMO_APP**\n  **ProjectileModelProc** e2@--2--o **DEMO_APP**\n  **TrajectoryAnalysisProc** e3@--3--o **DEMO_APP**\n  **generate_polygon_shape** e4@--A--o **PolygonGeometryProc**\n  **plot_polygon_shape** e5@--B--o **PolygonGeometryProc**\n  **simulate_projectile_motion** e6@--A--o **ProjectileModelProc**\n  **calculate_analytical_trajectory** e7@--B--o **ProjectileModelProc**\n  **compare_model_vs_analytical_trajectories** e8@--C--o **ProjectileModelProc**\n  **plot_overall_model_vs_theory** e9@--A--o **TrajectoryAnalysisProc**\n  e1@{ animate: true }\n  e2@{ animate: true }\n  e3@{ animate: true }\n  e4@{ animate: true }\n  e5@{ animate: true }\n  e6@{ animate: true }\n  e7@{ animate: true }\n  e8@{ animate: true }\n  e9@{ animate: true }</code></pre>"},{"location":"labs/apps/general/DEMO_APP/#mapping","title":"Mapping","text":"<pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **DEMO_APP** ||--|| **output_paths** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n  **hard_params** ||--|| **PolygonGeometryProc** : mapping\n  **user_paths** ||--|| **PolygonGeometryProc** : mapping\n  **output_paths** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }\n  **hard_params** {\n    float radius \"0.5\"\n  }\n  **user_paths** {\n    file title_file \"plot_title.txt\"\n  }\n  **output_paths** {\n    file coords_file \"points_coordinates.csv\"\n    file fig_file \"polygon_shape.png\"\n  }</code></pre> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **DEMO_APP** ||--|| **required_paths** : mapping\n  **DEMO_APP** ||--|| **output_paths** : mapping\n  **user_params** ||--|| **ProjectileModelProc** : mapping\n  **user_paths** ||--|| **ProjectileModelProc** : mapping\n  **required_paths** ||--|| **ProjectileModelProc** : mapping\n  **output_paths** ||--|| **ProjectileModelProc** : mapping\n\n  **user_params** {\n    float gravity \"gravity\"   \n    float mass \"mass\"\n  }\n  **user_paths** {\n    file velocity_file \"velocity.json\"\n    folder configs_folder \"configs\"\n  }\n  **required_paths** {\n    file coords_file \"points_coordinates.csv\"\n  }\n  **output_paths** {\n    folder comp_folder \"comparison\"\n  }</code></pre> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **overall_analysis** : mapping\n  **DEMO_APP** ||--|| **output_paths** : mapping\n  **overall_analysis** ||--|| **TrajectoryAnalysisProc** : mapping\n  **output_paths** ||--|| **TrajectoryAnalysisProc** : mapping\n\n  **overall_analysis** {\n    folder comp_folder \"comparison\"\n  }\n  **output_paths** {\n    file fig_file \"overall_comparisons.png\" \n  }</code></pre>"},{"location":"labs/apps/general/DEMO_APP/#io-interface","title":"I/O Interface","text":"<pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path1[\"plot_title.txt _(file)_\"]\n      path2[\"velocity.json _(file)_\"]\n      path3[\"configs _(folder)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"nb_sides _(int)_\"]\n      param2[\"gravity _(float)_\"]\n      param3[\"mass _(float)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc1[\"PolygonGeometryProc\"]\n    proc2[\"ProjectileModelProc\"]\n    proc3[\"TrajectoryAnalysisProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out1[\"points_coordinates.csv _(file)_\"]\n    out2[\"polygon_shape.png _(file)_\"]\n    out3[\"comparison _(folder)_\"]\n    out4[\"overall_comparisons.png _(file)_\"]\n  end\n\n  **INPUTS** --&gt; **DEMO_APP**\n  **DEMO_APP** --&gt; **OUTPUTS**</code></pre> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path1[\"plot_title.txt _(file)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"nb_sides _(int)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc1[\"PolygonGeometryProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out1[\"points_coordinates.csv _(file)_\"]\n    out2[\"polygon_shape.png _(file)_\"]\n  end\n\n  **INPUTS** --&gt; proc1\n  proc1 --&gt; **OUTPUTS**</code></pre> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path2[\"velocity.json _(file)_\"]\n      path3[\"configs _(folder)_\"]\n      out1[\"points_coordinates.csv _(file)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param2[\"gravity _(float)_\"]\n      param3[\"mass _(float)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc2[\"ProjectileModelProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out3[\"comparison _(folder)_\"]\n  end\n\n  **INPUTS** --&gt; proc2\n  proc2 --&gt; **OUTPUTS**\n\n  classDef blueBox fill:#d0e6ff,stroke:#339,stroke-width:1.5px;\n  class out1 blueBox;</code></pre> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      out3[\"comparison _(folder)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param[\"_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc3[\"TrajectoryAnalysisProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out4[\"overall_comparisons.png _(file)_\"]\n  end\n\n  **INPUTS** --&gt; proc3\n  proc3 --&gt; **OUTPUTS**\n\n  classDef blueBox fill:#d0e6ff,stroke:#339,stroke-width:1.5px;\n  class out3 blueBox;</code></pre>"},{"location":"labs/apps/general/DEMO_APP/#inputs","title":"INPUTS","text":""},{"location":"labs/apps/general/DEMO_APP/#parameters","title":"Parameters","text":"<ul> <li><code>nb_sides</code>: Number of sides of the polygon.</li> <li><code>gravity</code>: Gravitational acceleration (m/s\u00b2).</li> <li><code>mass</code>: Mass of the body (kg).</li> </ul>"},{"location":"labs/apps/general/DEMO_APP/#paths","title":"Paths","text":"<ul> <li><code>plot_title.txt</code>: File containing the plot title of the 2D polygon shape.</li> <li><code>velocity.json</code>: File containing the velocity initial conditions {v0 (m/s); angle (\u00b0)}.</li> <li><code>configs/</code> <code>solver_config.json</code>: File containing the parameters for solver configuration.  <code>display_config.json</code>: File containing the parameters for display configuration.</li> </ul>"},{"location":"labs/apps/general/DEMO_APP/#outputs","title":"OUTPUTS","text":"<ul> <li><code>points_coordinates.csv</code>: File containing the X/Y coordinates of the polygon vertices.</li> <li><code>polygon_shape.png</code>: Image of the plotted polygon figure.</li> <li><code>comparison/</code> <code>results.xlsx</code>: File containing simulated (model) and theoritical trajectories.  <code>model_vs_theory.png</code>: Image comparing both trajectories.</li> <li><code>overall_comparisons.png</code>: Image containing overall comparative plots.</li> </ul>      View source code"},{"location":"labs/procs/general/PolygonGeometryProc/","title":"PolygonGeometryProc","text":""},{"location":"labs/procs/general/PolygonGeometryProc/#process","title":"Process","text":"<p>Generate and plot a regular 2D polygon shape. A/ <code>generate_polygon_shape</code>: Generate the 2D coordinates of a regular polygon. B/ <code>plot_polygon_shape</code>: Plot a closed 2D polygon from a set of points.</p> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **PolygonGeometryProc** : feeds\n  **PolygonGeometryProc** ||--|| **Outputs** : generates\n\n  **Parameters** {\n    float radius\n    int n_sides\n  }\n  **Paths** {\n    file title_file \"txt\"\n  }\n  **PolygonGeometryProc** {\n    op generate_polygon_shape\n    op plot_polygon_shape\n  }\n  **Outputs** {\n    file coords_file \"csv\"\n    file fig_file \"png\"\n  }</code></pre>"},{"location":"labs/procs/general/PolygonGeometryProc/#input-parameters","title":"Input Parameter(s)","text":"<ul> <li><code>radius</code>: Radius (m) of the circumscribed circle of the polygon.</li> <li><code>n_sides</code>: Number of sides of the polygon.</li> </ul>"},{"location":"labs/procs/general/PolygonGeometryProc/#input-paths","title":"Input Path(s)","text":"<ul> <li><code>title_file</code>: File containing the plot title of the 2D polygon shape.</li> </ul>"},{"location":"labs/procs/general/PolygonGeometryProc/#output-paths","title":"Output Path(s)","text":"<ul> <li><code>coords_file</code>: File containing the X/Y coordinates of the polygon vertices.</li> <li><code>fig_file</code>: Image of the plotted polygon figure.</li> </ul>      View source code"},{"location":"labs/procs/general/ProjectileModelProc/","title":"ProjectileModelProc","text":""},{"location":"labs/procs/general/ProjectileModelProc/#process","title":"Process","text":"<p>Simulate the motion of a projectile and compare its trajectory with the analytical solution. A/ <code>simulate_projectile_motion</code>: Simulate the motion of a 2D rigid body under gravity projected with an initial velocity. B/ <code>calculate_analytical_trajectory</code>: Calculate the theoretical trajectory of a projectile using analytical equations. C/ <code>compare_model_vs_analytical_trajectories</code>: Plot and save the comparison between simulated (model) and theoretical projectile trajectories.</p> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **ProjectileModelProc** : feeds\n  **ProjectileModelProc** ||--|| **Outputs** : generates\n\n  **Parameters** {\n    float gravity\n    float mass\n  }\n  **Paths** {\n    file velocity_file \"json\"\n    folder configs_folder \"_\"\n    file coords_file \"csv\"\n  }\n  **ProjectileModelProc** {\n    op simulate_projectile_motion\n    op calculate_analytical_trajectory\n    op compare_model_vs_analytical_trajectories\n  }\n  **Outputs** {\n    folder comp_folder \"_\"\n  }</code></pre>"},{"location":"labs/procs/general/ProjectileModelProc/#input-parameters","title":"Input Parameter(s)","text":"<ul> <li><code>gravity</code>: Gravitational acceleration (m/s\u00b2).</li> <li><code>mass</code>: Mass of the body (kg).</li> </ul>"},{"location":"labs/procs/general/ProjectileModelProc/#input-paths","title":"Input Path(s)","text":"<ul> <li><code>velocity_file</code>: File containing the velocity initial conditions {v0 (m/s); angle (\u00b0)}.</li> <li><code>configs_folder/</code> <code>solver_config.json</code>: File containing the parameters for solver configuration. <code>display_config.json</code>: File containing the parameters for display configuration.</li> <li><code>coords_file</code>: File containing the X/Y coordinates of the polygonal shape to simulate.</li> </ul>"},{"location":"labs/procs/general/ProjectileModelProc/#output-paths","title":"Output Path(s)","text":"<ul> <li><code>comp_folder/</code> <code>results.xlsx</code>: File containing simulated (model) and theoritical trajectories. <code>model_vs_theory.png</code>: Image comparing both trajectories.</li> </ul>      View source code"},{"location":"labs/procs/general/TrajectoryAnalysisProc/","title":"TrajectoryAnalysisProc","text":""},{"location":"labs/procs/general/TrajectoryAnalysisProc/#process","title":"Process","text":"<p>Perform overall comparisons between simulated (model) and theoretical trajectories. A/ <code>plot_overall_model_vs_theory</code>: Generate overall comparative plots of simulated (model) and theoritical trajectories.</p> <pre><code>erDiagram\n  **Analysis** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **TrajectoryAnalysisProc** : feeds\n  **TrajectoryAnalysisProc** ||--|| **Outputs** : generates\n\n  **Analysis** {\n    folder comp_folder \"_\"\n  }\n  **TrajectoryAnalysisProc** {\n    op plot_overall_model_vs_theory\n  }\n  **Outputs** {\n    file fig_file \"png\"\n  }</code></pre>"},{"location":"labs/procs/general/TrajectoryAnalysisProc/#input-analysis","title":"Input Analysis","text":"<ul> <li><code>comp_folder/</code> <code>results.xlsx</code>: File containing both trajectories.</li> </ul>"},{"location":"labs/procs/general/TrajectoryAnalysisProc/#output-paths","title":"Output Path(s)","text":"<ul> <li><code>fig_file</code>: Image containing overall comparative plots.</li> </ul>      View source code"},{"location":"use-cases/","title":"Use Cases","text":"Computational Modeling &amp; Simulation (CM&amp;S) Digitally reproduce and analyze real-world physical systems using mathematical models and physics-based laws. Artificial Intelligence (AI) &amp; Data Science Extract knowledge and drive decisions from data using statistical, machine learning, and deep learning methods."},{"location":"use-cases/aids/","title":"Artificial Intelligence (AI) &amp; Data Science","text":"<p>Coming soon...</p>"},{"location":"use-cases/cms/","title":"Computational Modeling &amp; Simulation (CM&amp;S)","text":"Cantilever subjected to end shear force Computational Structural Mechanics (CSM) benchmark focusing on the non-linear response of a shear-loaded beam structure."},{"location":"use-cases/cms/cantilever-shear/","title":"Cantilever subjected to end shear force","text":"<ul> <li>Branch: <code>cantilever-shear</code></li> <li>App: <code>CANTILEVER_SHEAR_APP</code></li> </ul>  Take part of the discussions on the Discord channel <code>#cantilever-shear</code>      Start Your Onboarding"},{"location":"use-cases/cms/cantilever-shear/#introduction","title":"Introduction","text":"<p>The present use case addresses a classical benchmark problem in Computational Structural Mechanics (CSM), namely the simulation of a beam structure fixed at one end and loaded by a shear force at the other end (see Fig. 1). This type of problem is widely used in the literature as a reference for evaluating the accuracy and robustness of numerical methods in CSM.</p> <p>The benchmark considered here was originally reported by Sze et al. 2004, who compiled a comprehensive set of non-linear test cases for shell Finite-Element (FE) analysis. In their work, the reference solution (summarized in Tab. 1) for this specific problem was obtained using the commercial FE solver Abaqus, relying on the S4R four-node shell elements with reduced integration and hourglass control.</p> Figure 1 (extracted from      Sze et al. 2004):     (a) Cantilever subjected to end shear force. (b) Load\u2013deflection curves for cantilever subjected to end shear force. (c) The deformed 16 \u00d7 1 mesh under the maximum force.    Table 1 (extracted from      Sze et al. 2004):     Horizontal and vertical tip deflections for the cantilever loaded with end shear force.    <p>This test case is particularly interesting because it exhibits non-linear elastic behavior, which provides a meaningful challenge for numerical methods. Additionally, the simple geometric shape of the structure allows for different modeling approaches: fully resolved 3D solid elements, 2D shell elements, or simplified 1D beam elements. Each approach introduces different levels of approximation and computational cost, offering a clear perspective on the trade-offs inherent in structural modeling.</p> <p>The main objective of this use case is therefore to simulate the benchmark problem using three different modeling strategies [3D solid elements | 2D shell elements | 1D beam elements] within the nuRemics framework, and to compare their respective capabilities in capturing the non-linear response of the structure.</p> Figure 2:     The ASME V&amp;V40 Standard provides structured guidance for assessing credibility and applicability of Computational Modeling &amp; Simulation in the context of Medical Devices. For more information, see the official ASME V&amp;V40 page.    <p>Importantly, this study is performed in application of the ASME V&amp;V40 standard (V&amp;V40) (see Fig. 2), which provides guidance for the development of Computational Modeling &amp; Simulation (CM&amp;S) technologies, ensuring their credibility and reliability through rigorous Verification &amp; Validation (V&amp;V) activities. The standard establishes a structured framework to guarantee that CM&amp;S methods meet the highest standards of safety and effectiveness, particularly in the context of Medical Device (MD) development. By adhering to the V&amp;V40, this use case not only serves as a benchmark for numerical accuracy but also demonstrates how nuRemics can be applied within a scientifically rigorous and regulatory-aware workflow.</p> <p>It is nonetheless important to note that this methodology could be broadened to contexts beyond MD, making the V&amp;V40 framework relevant for a wide range of industrial applications where the V&amp;V of computational models is critical for design, safety, and performance assessment.</p> <p>In the present use case, the benchmark problem is employed to establish the credibility factor associated with Numerical Code Verification (NCV). The objective of NCV is to demonstrate the correct implementation and functioning of the numerical algorithms within the CM&amp;S framework. This involves a careful investigation of key numerical aspects, including spatial and temporal convergence rates, independence from coordinate transformations, and symmetry tests under various system conditions.</p> <p>NCV is typically conducted by comparing numerical solutions to exact benchmark solutions, which may be analytical or semi-analytical, or generated using techniques such as the methods of manufactured solutions. In this use case, the cantilever beam benchmark provides such a reference solution, enabling a rigorous assessment of the numerical fidelity of the nuRemics CM&amp;S software system across multiple modeling strategies (3D solids, 2D shells, and 1D beams).</p>"},{"location":"use-cases/cms/cantilever-shear/#materials-methods","title":"Materials &amp; Methods","text":"<p>This use case is organized into a sequential scientific workflow, implemented through a nuRemics App called <code>CANTILEVER_SHEAR_APP</code>.</p>"},{"location":"use-cases/cms/cantilever-shear/#workflow","title":"Workflow","text":"<p>The workflow is composed of the following software processes:</p> <ol> <li><code>GeometryProc</code>: Create a geometric representation of a physical system.   A/ <code>create_geometry</code>: Create and export a simple geometric entity (beam, plate, or block) in STEP or BREP format.</li> <li><code>LabelingProc</code>: Define and label the entities of a physical system from its geometric representation.   A/ <code>label_boundaries</code>: Assign labels to the boundaries of a geometric model.</li> </ol> <pre><code>flowchart RL\n  **GeometryProc** e1@--1--o **CANTILEVER_SHEAR_APP**\n  **LabelingProc** e2@--2--o **CANTILEVER_SHEAR_APP**\n  **create_geometry** e3@--A--o **GeometryProc**\n  **label_boundaries** e4@--A--o **LabelingProc**\n  e1@{ animate: true }\n  e2@{ animate: true }\n  e3@{ animate: true }\n  e4@{ animate: true }</code></pre>"},{"location":"use-cases/cms/cantilever-shear/#io-interface","title":"I/O Interface","text":"<p>The following I/O interface describes the input data required and the output data generated by the workflow:</p> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path[\"_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"dimension _(int)_\"]\n    end\n  end\n\n  subgraph **CANTILEVER_SHEAR_APP**\n    direction RL\n    proc1[\"GeometryProc\"]\n    proc2[\"LabelingProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out1[\"geometry.(step/brep) _(file)_\"]\n    out2[\"boundaries.json _(file)_\"]\n  end\n\n  **INPUTS** --&gt; **CANTILEVER_SHEAR_APP**\n  **CANTILEVER_SHEAR_APP** --&gt; **OUTPUTS**</code></pre>"},{"location":"use-cases/cms/cantilever-shear/#inputs","title":"INPUTS","text":"<p>The input data are divided into two categories: Parameters and Paths.</p>"},{"location":"use-cases/cms/cantilever-shear/#parameters","title":"Parameters","text":"<p>These are scalar values that must be defined to configure the workflow:</p> <ul> <li><code>dimension</code>: Dimension of the geometry: 1 for a line (beam), 2 for a rectangle (plate), 3 for a box (block).</li> </ul>"},{"location":"use-cases/cms/cantilever-shear/#paths","title":"Paths","text":"<p>These are either files or folders that must be provided to configure the workflow:</p> <p><code>N/A</code></p>"},{"location":"use-cases/cms/cantilever-shear/#outputs","title":"OUTPUTS","text":"<p>The output data are either files or folders generated by the workflow and written to disk:</p> <ul> <li><code>geometry.(step/brep)</code>: File containing the geometric model (in .step if <code>dim</code> = 3|2 or .brep if <code>dim</code> = 1).</li> <li><code>boundaries.json</code>: File containing the labeled geometric entities.</li> </ul>"},{"location":"use-cases/cms/cantilever-shear/#results","title":"Results","text":"<p>The following studies were carried out:</p> <pre><code>flowchart LR\n    Study_Dim</code></pre>"},{"location":"use-cases/cms/cantilever-shear/#study_dim","title":"Study_Dim","text":"<p>This study has been configured as follows:</p> <pre><code>flowchart LR\n\n  subgraph Fixed[\"**FIXED**\"]\n    direction TB\n\n    subgraph Paths_Fixed[\"**Paths**\"]\n      direction LR\n      path[\"_\"]\n    end\n\n    subgraph Parameter_Fixed[\"**Parameters**\"]\n      direction LR\n      param[\"_\"]\n    end\n  end\n\n  subgraph Variable[\"**VARIABLE**\"]\n    direction TB\n\n    subgraph Paths_Variable[\"**Paths**\"]\n      direction LR\n      no_path[\"_\"]\n    end\n\n    subgraph Parameter_Variable[\"**Parameters**\"]\n      direction LR\n      param1[\"dimension\"]\n    end\n  end\n\n  Study_Dim --&gt; Fixed\n  Study_Dim --&gt; Variable</code></pre>"},{"location":"use-cases/cms/cantilever-shear/#geometryproc","title":"GeometryProc","text":""},{"location":"use-cases/cms/cantilever-shear/#test1","title":"Test1","text":"Test"},{"location":"use-cases/cms/cantilever-shear/#test2","title":"Test2","text":"Test"},{"location":"use-cases/cms/cantilever-shear/#test3","title":"Test3","text":"Test Test1 Test2 Test3      Figure 3: Created geometry of the physical system.         View App"},{"location":"use-cases/cms/cantilever-shear/","title":"Cantilever subjected to end shear force","text":"<ul> <li>Branch: <code>cantilever-shear</code></li> <li>App: <code>CANTILEVER_SHEAR_APP</code></li> </ul>      Introduction         Materials &amp; Methods         Results"},{"location":"use-cases/cms/cantilever-shear/introduction/","title":"Introduction","text":"<p>The present use case addresses a classical benchmark problem in Computational Structural Mechanics (CSM), namely the simulation of a beam structure fixed at one end and loaded by a shear force at the other end (see Fig. 1). This type of problem is widely used in the literature as a reference for evaluating the accuracy and robustness of numerical methods in CSM.</p> <p>The benchmark considered here was originally reported by Sze et al. 2004, who compiled a comprehensive set of non-linear test cases for shell Finite-Element (FE) analysis. In their work, the reference solution (summarized in Tab. 1) for this specific problem was obtained using the commercial FE solver Abaqus, relying on the S4R four-node shell elements with reduced integration and hourglass control.</p> Figure 1 (extracted from      Sze et al. 2004):     (a) Cantilever subjected to end shear force. (b) Load\u2013deflection curves for cantilever subjected to end shear force. (c) The deformed 16 \u00d7 1 mesh under the maximum force.    Table 1 (extracted from      Sze et al. 2004):     Horizontal and vertical tip deflections for the cantilever loaded with end shear force.    <p>This test case is particularly interesting because it exhibits non-linear elastic behavior, which provides a meaningful challenge for numerical methods. Additionally, the simple geometric shape of the structure allows for different modeling approaches: fully resolved 3D solid elements, 2D shell elements, or simplified 1D beam elements. Each approach introduces different levels of approximation and computational cost, offering a clear perspective on the trade-offs inherent in structural modeling.</p> <p>The main objective of this use case is therefore to simulate the benchmark problem using three different modeling strategies [3D solid elements | 2D shell elements | 1D beam elements] within the nuRemics framework, and to compare their respective capabilities in capturing the non-linear response of the structure.</p> Figure 2:     The ASME V&amp;V40 Standard provides structured guidance for assessing credibility and applicability of Computational Modeling &amp; Simulation in the context of Medical Devices. For more information, see the official ASME V&amp;V40 page.    <p>Importantly, this study is performed in application of the ASME V&amp;V40 standard (V&amp;V40) (see Fig. 2), which provides guidance for the development of Computational Modeling &amp; Simulation (CM&amp;S) technologies, ensuring their credibility and reliability through rigorous Verification &amp; Validation (V&amp;V) activities. The standard establishes a structured framework to guarantee that CM&amp;S methods meet the highest standards of safety and effectiveness, particularly in the context of Medical Device (MD) development. By adhering to the V&amp;V40, this use case not only serves as a benchmark for numerical accuracy but also demonstrates how nuRemics can be applied within a scientifically rigorous and regulatory-aware workflow.</p> <p>It is nonetheless important to note that this methodology could be broadened to contexts beyond MD, making the V&amp;V40 framework relevant for a wide range of industrial applications where the V&amp;V of computational models is critical for design, safety, and performance assessment.</p> <p>In the present use case, the benchmark problem is employed to establish the credibility factor associated with Numerical Code Verification (NCV). The objective of NCV is to demonstrate the correct implementation and functioning of the numerical algorithms within the CM&amp;S framework. This involves a careful investigation of key numerical aspects, including spatial and temporal convergence rates, independence from coordinate transformations, and symmetry tests under various system conditions.</p> <p>NCV is typically conducted by comparing numerical solutions to exact benchmark solutions, which may be analytical or semi-analytical, or generated using techniques such as the methods of manufactured solutions. In this use case, the cantilever beam benchmark provides such a reference solution, enabling a rigorous assessment of the numerical fidelity of the nuRemics CM&amp;S software system across multiple modeling strategies (3D solids, 2D shells, and 1D beams).</p>      Materials &amp; Methods"},{"location":"use-cases/cms/cantilever-shear/materials-and-methods/","title":"Materials &amp; Methods","text":"<p>This use case is organized into a sequential scientific workflow, implemented through a nuRemics App called <code>CANTILEVER_SHEAR_APP</code>.</p>"},{"location":"use-cases/cms/cantilever-shear/materials-and-methods/#workflow","title":"Workflow","text":"<p>The workflow is composed of the following software processes:</p> <ol> <li><code>GeometryProc</code>: Create a geometric representation of a physical system.   A/ <code>create_geometry</code>: Create and export a simple geometric entity (beam, plate, or block) in STEP or BREP format.</li> <li><code>LabelingProc</code>: Define and label the entities of a physical system from its geometric representation.   A/ <code>label_entities</code>: Assign labels to the entities of a geometric model.</li> </ol> <pre><code>flowchart RL\n  **GeometryProc** e1@--1--o **CANTILEVER_SHEAR_APP**\n  **LabelingProc** e2@--2--o **CANTILEVER_SHEAR_APP**\n  **create_geometry** e3@--A--o **GeometryProc**\n  **label_entities** e4@--A--o **LabelingProc**\n  e1@{ animate: true }\n  e2@{ animate: true }\n  e3@{ animate: true }\n  e4@{ animate: true }</code></pre>"},{"location":"use-cases/cms/cantilever-shear/materials-and-methods/#io-interface","title":"I/O Interface","text":"<p>The following I/O interface describes the input data required and the output data generated by the workflow:</p> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path[\"_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"dimension _(int)_\"]\n    end\n  end\n\n  subgraph **CANTILEVER_SHEAR_APP**\n    direction RL\n    proc1[\"GeometryProc\"]\n    proc2[\"LabelingProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out1[\"geometry.(step/brep) _(file)_\"]\n    out2[\"labels.json _(file)_\"]\n  end\n\n  **INPUTS** --&gt; **CANTILEVER_SHEAR_APP**\n  **CANTILEVER_SHEAR_APP** --&gt; **OUTPUTS**</code></pre> <p>The <code>GeometryProc</code> software process handles the following input and output data:</p> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path[\"_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"dimension _(int)_\"]\n    end\n  end\n\n  subgraph **CANTILEVER_SHEAR_APP**\n    direction RL\n    proc1[\"GeometryProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out1[\"geometry.(step/brep) _(file)_\"]\n  end\n\n  **INPUTS** --&gt; proc1\n  proc1 --&gt; **OUTPUTS**</code></pre> <p>The <code>LabelingProc</code> software process handles the following input and output data:</p> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      out1[\"geometry.(step/brep) _(file)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"dimension _(int)_\"]\n    end\n\n  end\n\n  subgraph **CANTILEVER_SHEAR_APP**\n    direction RL\n    proc2[\"LabelingProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out2[\"labels.json _(file)_\"]\n  end\n\n  **INPUTS** --&gt; proc2\n  proc2 --&gt; **OUTPUTS**\n\n  classDef blueBox fill:#d0e6ff,stroke:#339,stroke-width:1.5px;\n  class out1 blueBox;</code></pre>"},{"location":"use-cases/cms/cantilever-shear/materials-and-methods/#inputs","title":"Inputs","text":"<p>The input data are divided into two categories: Parameters and Paths.</p>"},{"location":"use-cases/cms/cantilever-shear/materials-and-methods/#parameters","title":"Parameters","text":"<p>These are scalar values that must be defined to configure the workflow:</p> <ul> <li><code>dimension</code>: Dimension of the geometry: 1 for a line (beam), 2 for a rectangle (plate), 3 for a box (block).</li> </ul>"},{"location":"use-cases/cms/cantilever-shear/materials-and-methods/#paths","title":"Paths","text":"<p>These are either files or folders that must be provided to configure the workflow:</p> <p>N/A</p>"},{"location":"use-cases/cms/cantilever-shear/materials-and-methods/#outputs","title":"Outputs","text":"<p>The output data are either files or folders generated by the workflow and written to disk:</p> <ul> <li><code>geometry.(step/brep)</code>: File containing the geometric model (in .step if <code>dim</code> = 3|2 or .brep if <code>dim</code> = 1).</li> <li><code>labels.json</code>: File containing the labeled geometric entities.</li> </ul>      Results"},{"location":"use-cases/cms/cantilever-shear/results/","title":"Results","text":"<p>The following studies were carried out:</p>      Study_Dim"},{"location":"use-cases/cms/cantilever-shear/results/study-dim/","title":"Study_Dim","text":"<p>This study has been configured as follows:</p> <pre><code>flowchart LR\n\n  subgraph Fixed[\"**FIXED**\"]\n    direction TB\n\n    subgraph Paths_Fixed[\"**Paths**\"]\n      direction LR\n      path[\"_\"]\n    end\n\n    subgraph Parameter_Fixed[\"**Parameters**\"]\n      direction LR\n      param[\"_\"]\n    end\n  end\n\n  subgraph Variable[\"**VARIABLE**\"]\n    direction TB\n\n    subgraph Paths_Variable[\"**Paths**\"]\n      direction LR\n      no_path[\"_\"]\n    end\n\n    subgraph Parameter_Variable[\"**Parameters**\"]\n      direction LR\n      param1[\"dimension\"]\n    end\n  end\n\n  Study_Dim --&gt; Fixed\n  Study_Dim --&gt; Variable</code></pre>"},{"location":"use-cases/cms/cantilever-shear/results/study-dim/#inputs","title":"Inputs","text":"<p>The input data considered for the present study are summarized below.</p>"},{"location":"use-cases/cms/cantilever-shear/results/study-dim/#fixed","title":"Fixed","text":"<p>These input data remain constant across all experiments and are thus shared by every execution of the workflow.</p>"},{"location":"use-cases/cms/cantilever-shear/results/study-dim/#parameters","title":"Parameters","text":"<p>N/A</p>"},{"location":"use-cases/cms/cantilever-shear/results/study-dim/#paths","title":"Paths","text":"<p>N/A</p>"},{"location":"use-cases/cms/cantilever-shear/results/study-dim/#variable","title":"Variable","text":"<p>These input data vary between experiments, defining multiple test configurations to be evaluated by the workflow.</p>"},{"location":"use-cases/cms/cantilever-shear/results/study-dim/#parameters_1","title":"Parameters","text":"ID dimension Test1 3 Test2 2 Test3 1"},{"location":"use-cases/cms/cantilever-shear/results/study-dim/#paths_1","title":"Paths","text":"<p>N/A</p>"},{"location":"use-cases/cms/cantilever-shear/results/study-dim/#geometryproc","title":"GeometryProc","text":"<p>The output data generated by the present software process are summarized below:</p> <ul> <li><code>geometry.(step/brep)</code></li> </ul>"},{"location":"use-cases/cms/cantilever-shear/results/study-dim/#test1","title":"Test1","text":"Display of the <code>geometry.step</code> file."},{"location":"use-cases/cms/cantilever-shear/results/study-dim/#test2","title":"Test2","text":"Display of the <code>geometry.step</code> file."},{"location":"use-cases/cms/cantilever-shear/results/study-dim/#test3","title":"Test3","text":"Display of the <code>geometry.brep</code> file."},{"location":"use-cases/cms/cantilever-shear/results/study-dim/#labelingproc","title":"LabelingProc","text":"<p>The output data generated by the present software process are summarized below:</p> <ul> <li><code>labels.json</code></li> </ul>"},{"location":"use-cases/cms/cantilever-shear/results/study-dim/#test1_1","title":"Test1","text":"Display of the <code>'Constraint'</code> label within the <code>labels.json</code> file.         Display of the <code>'Load'</code> label within the <code>labels.json</code> file."},{"location":"use-cases/cms/cantilever-shear/results/study-dim/#test2_1","title":"Test2","text":"Display of the <code>'Constraint'</code> label within the <code>labels.json</code> file.         Display of the <code>'Load'</code> label within the <code>labels.json</code> file."},{"location":"use-cases/cms/cantilever-shear/results/study-dim/#test3_1","title":"Test3","text":"Display of the <code>'Constraint'</code> label within the <code>labels.json</code> file.         Display of the <code>'Load'</code> label within the <code>labels.json</code> file.         Results"}]}