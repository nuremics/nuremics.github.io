{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>NUREMICS is an open-source Python framework for developing software-grade scientific workflows.</p> <p>\ud83e\udde0 Code like a scientist \u2014 build like an engineer. \ud83e\udde9 Modular workflows \u2014 no more tangled scripts. \ud83e\uddea Parametric exploration \u2014 configuration over code. \ud83d\udcbe Full traceability \u2014 everything written to disk. \ud83d\udee0\ufe0f Industrial mindset \u2014 R&amp;D speed, software rigor.</p>      Getting Started         Handbook         Join the community"},{"location":"#foreword","title":"Foreword","text":"<p>The NUREMICS project is organized into two complementary repositories:</p> <ul> <li> <p><code>nuremics</code>: This repository is the core Python library. It provides the foundational components to create modular and extensible software workflows.</p> </li> <li> <p><code>nuremics-labs</code>: This repository contains examples of end-user applications built using the NUREMICS framework. It is intended to be forked by developers to initiate their own <code>nuremics-labs</code> project and build custom scientific applications tailored to their specific use cases.</p> </li> </ul> <p>Developers are thus encouraged to treat <code>nuremics</code> as the core engine, and to use <code>nuremics-labs</code> as a starting point for developing and maintaining their own scientific software applications built on top of the NUREMICS framework.</p>"},{"location":"#project-philosophy","title":"Project Philosophy","text":"<p>NUREMICS is built with the ambition of bringing robust software engineering practices into Python-driven scientific research and development.</p> <p>While Python has become the de facto standard for scientific computing, its use in R&amp;D environments is often limited to ad-hoc scripts or notebooks. This leads to critical limitations: unclear definition of inputs, algorithms, and outputs; hard-coded parameters that hinder reproducibility; and inefficient workflows for exploring parameter spaces. As a result, scientific studies are often conducted in a \u201cone-shot\u201d manner, making them difficult to reproduce or extend. Output data is rarely traceable in a structured way, and codebases suffer from poor modularity, limited reusability, and frequent duplication. These challenges are compounded when teams grow, as scripts and notebooks are difficult to scale and maintain collaboratively, slowing down innovation and increasing the risk of undetected errors.</p> <p>In regulated industries where scientific results directly support product development (e.g., MedTech, Biotech, Aerospace), such fragility can have severe consequences. This is also why many of these industries remain hesitant to adopt Python and its powerful open ecosystem, due to concerns about reliability and long-term maintainability.</p> <p>In this landscape, NUREMICS emerges as a unifying framework designed to address these challenges: it provides a rigorous development structure that empowers scientists, engineers, and researchers to deliver high-quality scientific outcomes, and take their research to the next level. By enabling the safe integration of tools from the Python ecosystem, NUREMICS supports the engineering of domain-specific software tailored for scientific exploration and reproducibility, while upholding the discipline and maintainability required in high-stakes industrial environments.</p> <p>Inspired by IEC 62304, a standard originally developed for the engineering of medical device software, NUREMICS promotes structured, layered software development through clearly defined architectural components: systems, items, and units. This organization fosters clarity, modularity, and maintainability, while remaining well-suited to the iterative, exploratory nature of scientific development in Python. Although NUREMICS does not aim for full compliance with IEC 62304, it selectively incorporates its most relevant principles, striking a pragmatic balance between engineering rigor and the agility required in fast-paced research environments.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<ol> <li> <p>Fork and clone the <code>nuremics-labs</code> repository. You have two options to get started:</p> <ul> <li> <p>Option A (recommended): Fork the repository to your own GitHub or GitLab account, then clone your fork. This allows you to modify the code and push your changes to your personal version of the project.</p> <pre><code>    nuremics-labs  \u2192  fork  \u2192  your-labs  \u2192  clone\n</code></pre> </li> <li> <p>Option B (quick start): If you just want to try the framework without making changes, you can simply clone the main repository directly.</p> HTTPSSSH <pre><code>git clone https://github.com/nuremics/nuremics-labs.git\n</code></pre> <pre><code>git clone git@github.com:nuremics/nuremics-labs.git\n</code></pre> </li> </ul> </li> <li> <p>Create the NUREMICS virtual environment. From the root directory of your cloned repository, use either conda or micromamba to create and install the environment using the provided <code>environment.yml</code> file.</p> <p>- Creation -</p> CondaMicromamba <pre><code>conda create -f environment.yml\n</code></pre> <pre><code>micromamba create -f environment.yml\n</code></pre> <p>- Activation -</p> CondaMicromamba <pre><code>conda activate nrs-env\n</code></pre> <pre><code>micromamba activate nrs-env\n</code></pre> <p>This will create a reproducible virtual environment with all required dependencies, including the <code>nuremics</code> core package itself.</p> </li> <li> <p>Install the demo application. Each application in <code>nuremics-labs</code> can be installed independently. You can start by installing the DEMO_APP.</p> <pre><code>pip install .[DEMO_APP]\n</code></pre> </li> </ol>"},{"location":"getting-started/#run-the-demo","title":"Run the demo","text":""},{"location":"handbook/","title":"Overview","text":"<p>The software architecture of NUREMICS is illustrated in the diagram below. It follows the layered structure recommended by the IEC 62304 standard, distinguishing between software systems, software items, and software units. This representation provides a clear, high-level view of how the different software components of the project are organized, and how they interact within a structured yet flexible development framework. It also highlights the relationship between the core framework (<code>nuremics</code>) and its domain-specific applications (<code>nuremics-labs</code>), emphasizing the modular and extensible nature of the overall architecture.</p> <p>In the context of NUREMICS:</p> <ul> <li> <p>A software unit corresponds to a single, testable function. It is the smallest building block of logic.</p> </li> <li> <p>A software item typically takes the form of a Python class that encapsulates related functions (units) to serve a specific purpose.</p> </li> <li> <p>A software system refers to a complete application designed to be executed by an end-user, replacing traditional scripts or notebooks.</p> </li> </ul> <p></p> <p>In practice, the core framework <code>nuremics</code> is composed of three foundational software items:</p> <ul> <li> <p>The <code>Process</code> class defines a generic process component. It provides a flexible base structure that can be extended to implement domain-specific processes within <code>nuremics-labs</code>.</p> </li> <li> <p>The <code>Workflow</code> class orchestrates the execution of multiple processes in a defined sequential order. It encapsulates the coordination logic and manages the progression of tasks throughout the workflow.</p> </li> <li> <p>The <code>Application</code> class is the top-level component. It instantiates and executes a workflow, acting as the main entry point for any end-user application developed within <code>nuremics-labs</code>.</p> </li> </ul> <p>In <code>nuremics-labs</code>, two main types of software components are developed to build domain-specific applications:</p> <ul> <li> <p>Procs (software items) \u2014 such as <code>Proc1, Proc2, ..., ProcX</code> \u2014 are implemented by subclassing the core <code>Process</code> class. Each Proc is defined as a class that encapsulates several functions (software units), which represent elementary operations (Ops) executed sequentially within the <code>__call__</code> method of the Proc. This design enables the creation of independent, reusable Procs that can be executed on their own or integrated into larger workflows.</p> </li> <li> <p>Apps (software systems) \u2014 such as <code>APP1, APP2, ..., APPX</code> \u2014 are the end-user-facing software applications. They import and assemble the required Procs, executing them in a defined order through the <code>Workflow</code> class, by instantiating the <code>Application</code> class. This modular architecture promotes flexibility and reusability, allowing the same Procs to be used across multiple Apps tailored to different scientific purposes.</p> </li> </ul>  Explore NUREMICS in:       Theory         Practice"},{"location":"handbook/practice/","title":"Practice","text":""},{"location":"handbook/practice/#create-app","title":"Create App","text":"<p>This section walks you through the process of building a custom NUREMICS application from scratch. You'll start by implementing your own Procs, which encapsulate domain-specific logic and computational tasks. Then, you\u2019ll learn how to assemble these building blocks into a fully operational App, ready to run studies and generate structured results.</p> <p>Whether you're developing a quick prototype or a full-scale scientific workflow, this guide will help you translate your ideas into modular, reusable, traceable and scalable software components.</p>"},{"location":"handbook/practice/#implement-procs","title":"Implement Procs","text":"<p>We start by defining the core building blocks of the App to be created: the Procs. Each Proc is a reusable item that encapsulates a specific piece of logic executed within the overall workflow. Internally, this logic can be further decomposed into elementary operations (Ops), implemented as individual functions (units) within the Proc itself.</p> <p>To implement our first Proc, we begin by importing the <code>Process</code> base class from NUREMICS, which all custom Procs must inherit from. To make this inheritance simple and structured, we also import the <code>attrs</code> library, which helps define clean, data-driven Python classes.</p> <pre><code>import attrs\nfrom nuremics import Process\n</code></pre> <p>We then declare our first Proc as a Python class named <code>PolygonGeometryProc</code>, inheriting from the <code>Process</code> base class. This marks it as a modular item of computation which can be executed within a NUREMICS workflow.</p> <pre><code>import attrs\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n</code></pre> <p>We now declare the input data required by our <code>PolygonGeometryProc</code>, grouped into two categories: Parameters and Paths. Each input is defined using <code>attrs.field()</code> and marked with <code>metadata={\"input\": True}</code>.</p> <p>This metadata is essential: it tells the NUREMICS framework that these attributes are expected as input data, ensuring they are properly tracked and managed throughout the workflow.</p> <pre><code>import attrs\nfrom pathlib import Path\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n\n    # Parameters\n    radius: float = attrs.field(init=False, metadata={\"input\": True})\n    n_sides: int = attrs.field(init=False, metadata={\"input\": True})\n\n    # Paths\n    title_file: Path = attrs.field(init=False, metadata={\"input\": True}, converter=Path)\n</code></pre> <p>In addition to the previously declared input data, a Proc can also define internal variables: attributes used during the execution of its internal logic but not provided as input data.</p> <p>These internal variables, like <code>df_points</code> in our example below, are declared without the <code>metadata={\"input\": True}</code> tag, signaling to the NUREMICS framework that they are not exposed to the workflow and will be set or computed within the Proc itself.</p> <pre><code>import attrs\nimport pandas as pd\nfrom pathlib import Path\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n\n    # Parameters\n    radius: float = attrs.field(init=False, metadata={\"input\": True})\n    n_sides: int = attrs.field(init=False, metadata={\"input\": True})\n\n    # Paths\n    title_file: Path = attrs.field(init=False, metadata={\"input\": True}, converter=Path)\n\n    # Internal\n    df_points: pd.DataFrame = attrs.field(init=False)\n</code></pre> <p>The operations executed by the Proc are finally implemented as elementary functions (Ops), which are then sequentially called within the <code>__call__()</code> method to define the overall logic of the Proc.</p> <pre><code>import attrs\nimport pandas as pd\nfrom pathlib import Path\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n\n    # Parameters\n    radius: float = attrs.field(init=False, metadata={\"input\": True})\n    n_sides: int = attrs.field(init=False, metadata={\"input\": True})\n\n    # Paths\n    title_file: Path = attrs.field(init=False, metadata={\"input\": True}, converter=Path)\n\n    # Internal\n    df_points: pd.DataFrame = attrs.field(init=False)\n\n    def __call__(self):\n        super().__call__()\n\n        self.generate_polygon_shape()\n        self.plot_polygon_shape()\n\n    def generate_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n\n    def plot_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n</code></pre> <p>Note that the Proc should at some point produce output data, typically in the form of files or folders generated during the execution of its Ops. To make these output data trackable by the NUREMICS framework, each must be registered in the <code>self.output_paths</code> dictionary using a label that is unique to the Proc (e.g., <code>\"coords_file\"</code>, <code>\"fig_file\"</code>).</p> <p>Using the dictionary syntax <code>self.output_paths[\"coords_file\"]</code> effectively declares an output variable named <code>coords_file</code>, which will later be instantiated by assigning it a specific file or folder name when integrating the Proc into a broader application workflow.</p> <pre><code>import attrs\nimport pandas as pd\nfrom pathlib import Path\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n\n    # Parameters\n    radius: float = attrs.field(init=False, metadata={\"input\": True})\n    n_sides: int = attrs.field(init=False, metadata={\"input\": True})\n\n    # Paths\n    title_file: Path = attrs.field(init=False, metadata={\"input\": True}, converter=Path)\n\n    # Internal\n    df_points: pd.DataFrame = attrs.field(init=False)\n\n    def __call__(self):\n        super().__call__()\n\n        self.generate_polygon_shape()\n        self.plot_polygon_shape()\n\n    def generate_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n        file = self.output_paths[\"coords_file\"]\n        # &lt;/&gt; Write file &lt;/&gt;\n\n    def plot_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n        file = self.output_paths[\"fig_file\"]\n        # &lt;/&gt; Write file &lt;/&gt;\n</code></pre> <p>Even though Procs are not intended to be executed independently by end-users, they are still designed with the possibility to run out of the box. This allows developers to easily execute them during the development phase or when implementing dedicated unit tests for a specific Proc.</p> <p>In such cases, it is important to set <code>set_inputs=True</code> when instantiating the Proc, to explicitly inform the NUREMICS framework that the input data are being provided manually, outside of any workflow context.</p> <pre><code>import attrs\nimport pandas as pd\nfrom pathlib import Path\nfrom nuremics import Process\n\n@attrs.define\nclass PolygonGeometryProc(Process):\n\n    # Parameters\n    radius: float = attrs.field(init=False, metadata={\"input\": True})\n    n_sides: int = attrs.field(init=False, metadata={\"input\": True})\n\n    # Paths\n    title_file: Path = attrs.field(init=False, metadata={\"input\": True}, converter=Path)\n\n    # Internal\n    df_points: pd.DataFrame = attrs.field(init=False)\n\n    def __call__(self):\n        super().__call__()\n\n        self.generate_polygon_shape()\n        self.plot_polygon_shape()\n\n    def generate_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n        file = self.output_paths[\"coords_file\"]\n        # &lt;/&gt; Write file &lt;/&gt;\n\n    def plot_polygon_shape(self):\n        # &lt;/&gt; your code &lt;/&gt;\n        file = self.output_paths[\"fig_file\"]\n        # &lt;/&gt; Write file &lt;/&gt;\n\nif __name__ == \"__main__\":\n\n    # Define working directory\n    working_dir = ...\n\n    # Go to working directory\n    os.chdir(working_dir)\n\n    # Create dictionary containing input data\n    dict_inputs = {\n        \"radius\": ...,\n        \"n_sides\": ...,\n        \"title_file\": ...,\n    }\n\n    # Create process\n    process = PolygonGeometryProc(\n        dict_inputs=dict_inputs,\n        set_inputs=True,\n    )\n    process.output_paths[\"coords_file\"] = \"points_coordinates.csv\"\n    process.output_paths[\"fig_file\"] = \"polygon_shape.png\"\n\n    # Run process\n    process()\n    process.finalize()\n</code></pre>"},{"location":"handbook/practice/#assemble-procs-into-app","title":"Assemble Procs into App","text":"<p>Most of the development effort has already been carried out when implementing the individual Procs. The next step consists in assembling them into a coherent App, where each Proc is instantiated, connected, and orchestrated to form a complete, executable workflow.</p> <p>We start by defining the name of our App.</p> <pre><code>APP_NAME = \"DEMO_APP\"\n</code></pre> <p>We then import the <code>Application</code> class from the NUREMICS framework, which serves as the container and manager to define a workflow composed of multiple Procs.</p> <pre><code>from nuremics import Application\n\nAPP_NAME = \"DEMO_APP\"\n</code></pre> <p>We now import the two Procs, <code>PolygonGeometryProc</code> and <code>ProjectileModelProc</code>, that we previously implemented. These will be the building blocks to assemble into our final App.</p> <pre><code>from nuremics import Application\nfrom procs.general.PolygonGeometryProc.item import PolygonGeometryProc\nfrom procs.general.ProjectileModelProc.item import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\n</code></pre> <p>The source code of the App then adopts the structure of a standard Python script, which can both be executed directly or imported as a module. This is achieved by defining a <code>main()</code> function and guarding it with the typical <code>if __name__ == \"__main__\":</code> statement.</p> <pre><code>from nuremics import Application\nfrom procs.general.PolygonGeometryProc.item import PolygonGeometryProc\nfrom procs.general.ProjectileModelProc.item import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\n\ndef main():\n    # Application logic here\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>In the <code>main()</code> function, we add two input arguments that the end-user must specify when launching the App inside the <code>if __name__ == \"__main__\":</code> block:</p> <ul> <li> <p><code>working_dir</code>: the working directory from which the App will be executed.</p> </li> <li> <p><code>studies</code>: a list of study names that the end-user wants to perform with the App.</p> </li> </ul> <pre><code>from pathlib import Path\nfrom nuremics import Application\nfrom procs.general.PolygonGeometryProc.item import PolygonGeometryProc\nfrom procs.general.ProjectileModelProc.item import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\n\ndef main(\n    working_dir: Path = None,\n    studies: list = [\"Default\"],\n):\n    # Application logic here\n\nif __name__ == \"__main__\":\n\n    # ------------------------ #\n    # Define working directory #\n    # ------------------------ #\n    working_dir = Path(os.environ[\"WORKING_DIR\"])\n\n    # -------------- #\n    # Define studies #\n    # -------------- #\n    studies = [\n        \"Study_Shape\",\n        \"Study_Velocity\",\n    ]\n\n    # --------------- #\n    # Run application #\n    # --------------- #\n    main(\n        working_dir=working_dir,\n        studies=studies,\n    )\n</code></pre> <p>Inside the <code>main()</code> function, we define a list called <code>workflow</code> which contains the sequence of Procs to be executed, in the order specified. This list is made up of dictionaries, where each dictionary describes the characteristics of a particular Proc.</p> <p>Let's first define the key <code>\"process\"</code> of each dictionary, which specifies the Proc class (previously imported, e.g., <code>PolygonGeometryProc</code> and <code>ProjectileModelProc</code>) to instantiate and execute within the App workflow.</p> <p>This dictionary-based structure offers flexibility to easily add more parameters or options later by simply adding new keys to each dictionary in the workflow.</p> <pre><code>from pathlib import Path\nfrom nuremics import Application\nfrom procs.general.PolygonGeometryProc.item import PolygonGeometryProc\nfrom procs.general.ProjectileModelProc.item import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\n\ndef main(\n    working_dir: Path = None,\n    studies: list = [\"Default\"],\n):\n    # --------------- #\n    # Define workflow #\n    # --------------- #\n    workflow = [\n        {\n            \"process\": PolygonGeometryProc,\n        },\n        {\n            \"process\": ProjectileModelProc,\n        },\n    ]\n\nif __name__ == \"__main__\":\n\n    # ------------------------ #\n    # Define working directory #\n    # ------------------------ #\n    working_dir = Path(os.environ[\"WORKING_DIR\"])\n\n    # -------------- #\n    # Define studies #\n    # -------------- #\n    studies = [\n        \"Study_Shape\",\n        \"Study_Velocity\",\n    ]\n\n    # --------------- #\n    # Run application #\n    # --------------- #\n    main(\n        working_dir=working_dir,\n        studies=studies,\n    )\n</code></pre> <p>We now create an <code>Application</code> object <code>app</code>, which acts as the core engine of our App. This object is instantiated using the previously defined inputs:</p> <ul> <li> <p><code>app_name</code>: the name of the App.</p> </li> <li> <p><code>working_dir</code>: the root directory from which the App is executed.</p> </li> <li> <p><code>workflow</code>: the ordered list of Procs to run.</p> </li> <li> <p><code>studies</code>: the list of studies the end-user wishes to perform.</p> </li> </ul> <p>Once the <code>Application</code> object is created, calling <code>app()</code> launches the workflow execution of all the defined Procs for each study.</p> <pre><code>from pathlib import Path\nfrom nuremics import Application\nfrom procs.general.PolygonGeometryProc.item import PolygonGeometryProc\nfrom procs.general.ProjectileModelProc.item import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\n\ndef main(\n    working_dir: Path = None,\n    studies: list = [\"Default\"],\n):\n    # --------------- #\n    # Define workflow #\n    # --------------- #\n    workflow = [\n        {\n            \"process\": PolygonGeometryProc,\n        },\n        {\n            \"process\": ProjectileModelProc,\n        },\n    ]\n\n    # ------------------ #\n    # Define application #\n    # ------------------ #\n    app = Application(\n        app_name=APP_NAME,\n        working_dir=working_dir,\n        workflow=workflow,\n        studies=studies,\n    )\n    # Run it!\n    app()\n\nif __name__ == \"__main__\":\n\n    # ------------------------ #\n    # Define working directory #\n    # ------------------------ #\n    working_dir = Path(os.environ[\"WORKING_DIR\"])\n\n    # -------------- #\n    # Define studies #\n    # -------------- #\n    studies = [\n        \"Study_Shape\",\n        \"Study_Velocity\",\n    ]\n\n    # --------------- #\n    # Run application #\n    # --------------- #\n    main(\n        working_dir=working_dir,\n        studies=studies,\n    )\n</code></pre> <p>When running the App, NUREMICS first provides the following terminal feedback:</p> <ul> <li> <p>A visual banner indicating the launch of a NUREMICS App.</p> </li> <li> <p>A structured overview of the assembled workflow, showing each registered Proc, its associated Ops (functions), and their order of execution within the App workflow.</p> </li> </ul> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>                      ___\n                     /\\  \\                      ___\n     ___            /::\\  \\        ___         /\\  \\\n    /\\__\\          /:/\\:\\  \\      /\\__\\       /::\\  \\\n   /::|  |        /::\\~\\:\\  \\    /::|  |     /:/\\:\\  \\\n  /:|:|  |       /:/\\:\\ \\:\\__\\  /:|:|  |    /:/  \\:\\  \\\n /:/|:|  |__     \\/_|::\\/:/  / /:/|:|__|__ /:/__/ \\:\\__\\\n/:/ |:| /\\__\\  ___  |:|::/  / /:/ |::::\\__\\\\:\\  \\  \\/__/\n\\/__|:|/:/  / /\\__\\ |:|\\/__/  \\/__/~~/:/  / \\:\\  \\\n    |:/:/  / /:/  / |:|  |  ___     /:/  /   \\:\\  \\\n    |::/  / /:/  /   \\|__| /\\  \\   /:/  / ___ \\:\\__\\ ___\n    /:/  / /:/  /  ___    /::\\  \\ /:/  / /\\  \\ \\/__//\\  \\\n    \\/__/ /:/__/  /\\__\\  /:/\\:\\  \\\\/__/  \\:\\  \\    /::\\  \\\n          \\:\\  \\ /:/  / /::\\~\\:\\  \\      /::\\__\\  /:/\\ \\  \\\n           \\:\\  /:/  / /:/\\:\\ \\:\\__\\  __/:/\\/__/ _\\:\\~\\ \\  \\\n            \\:\\/:/  /  \\:\\~\\:\\ \\/__/ /\\/:/  /   /\\ \\:\\ \\ \\__\\\n             \\::/  /    \\:\\ \\:\\__\\   \\::/__/    \\:\\ \\:\\ \\/__/\n              \\/__/      \\:\\ \\/__/    \\:\\__\\     \\:\\ \\:\\__\\\n                          \\:\\__\\       \\/__/      \\:\\/:/  /\n                           \\/__/                   \\::/  /\n                                                    \\/__/\n&gt; APPLICATION &lt;\n\n| Workflow |\nDEMO_APP_____\n             |_____PolygonGeometryProc_____\n             |                             |_____generate_polygon_shape\n             |                             |_____plot_polygon_shape\n             |\n             |_____ProjectileModelProc_____\n                                           |_____simulate_projectile_motion\n                                           |_____calculate_analytical_trajectory\n                                           |_____compare_model_vs_analytical_trajectories\n</code></pre></p> <p>At this stage, NUREMICS also performs a structural check of each Proc by inspecting its <code>__call__</code> method. Specifically, it ensures that only functions defined within the Proc class itself are invoked during execution. This design choice enforces a clean and self-contained structure for each Proc, where all internal logic remains encapsulated.</p> <p>Let\u2019s consider a case where the developer does not adhere to this enforced structural rule, for instance, by injecting additional logic directly into the <code>__call__</code> method of a Proc (in this example, in the <code>ProjectileModelProc</code> class).</p> <pre><code>    def __call__(self):\n        super().__call__()\n\n        some_parameter = 2 # &lt;-- External logic added here\n\n        self.simulate_projectile_motion()\n        self.calculate_analytical_trajectory()\n        self.compare_model_vs_analytical_trajectories()\n</code></pre> <p>In this situation, NUREMICS will immediately raise a structural validation error and halt execution.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| Workflow |\nDEMO_APP_____\n             |_____PolygonGeometryProc_____\n             |                             |_____generate_polygon_shape\n             |                             |_____plot_polygon_shape\n             |\n             |_____ProjectileModelProc_____(X)\n\n(X) Each process must only call its internal function(s):\n\n    def __call__(self):\n        super().__call__()\n\n        self.operation1()\n        self.operation2()\n        self.operation3()\n        ...\n</code></pre></p> <p>NUREMICS is then expected to display a summary of all required input/output data for each Proc, along with their current mapping status within the App.</p> <p>At this stage, the system automatically verifies whether every required input/output data has been properly mapped within the App configuration.</p> <p>If any input parameters are missing, they are explicitly listed, and the developer is prompted to define them using either the <code>\"user_params\"</code> or <code>\"hard_params\"</code> key.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| PolygonGeometryProc |\n&gt; Input Parameter(s) :\n(float) radius  -----||----- Not defined (X)\n(int)   n_sides -----||----- Not defined (X)\n\n(X) Please define all input parameters either in \"user_params\" or \"hard_params\".\n</code></pre></p> <p>The input parameters of the Proc <code>PolygonGeometryProc</code> can be properly mapped within the App by defining the <code>\"user_params\"</code> and/or <code>\"hard_params\"</code> keys in its corresponding dictionary entry inside the <code>workflow</code> list.</p> <pre><code>from pathlib import Path\nfrom nuremics import Application\nfrom procs.general.PolygonGeometryProc.item import PolygonGeometryProc\nfrom procs.general.ProjectileModelProc.item import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\n\ndef main(\n    working_dir: Path = None,\n    studies: list = [\"Default\"],\n):\n    # --------------- #\n    # Define workflow #\n    # --------------- #\n    workflow = [\n        {\n            \"process\": PolygonGeometryProc,\n            \"user_params\": {\n                \"n_sides\": \"nb_sides\",\n            },\n            \"hard_params\": {\n                \"radius\": 0.5,\n            },\n        },\n        {\n            \"process\": ProjectileModelProc,\n        },\n    ]\n\n    # ------------------ #\n    # Define application #\n    # ------------------ #\n    app = Application(\n        app_name=APP_NAME,\n        working_dir=working_dir,\n        workflow=workflow,\n        studies=studies,\n    )\n    # Run it!\n    app()\n\nif __name__ == \"__main__\":\n\n    # ------------------------ #\n    # Define working directory #\n    # ------------------------ #\n    working_dir = Path(os.environ[\"WORKING_DIR\"])\n\n    # -------------- #\n    # Define studies #\n    # -------------- #\n    studies = [\n        \"Study_Shape\",\n        \"Study_Velocity\",\n    ]\n\n    # --------------- #\n    # Run application #\n    # --------------- #\n    main(\n        working_dir=working_dir,\n        studies=studies,\n    )\n</code></pre> <p>When running the App again, NUREMICS detects that all required input parameters for <code>PolygonGeometryProc</code> have been successfully mapped.</p> <p>However, it now reports that one or more input paths are missing. These are explicitly listed, and the developer is prompted to define them using either the <code>\"user_paths\"</code> or <code>\"required_paths\"</code> key.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| PolygonGeometryProc |\n&gt; Input Parameter(s) :\n(float) radius  -----||----- 0.5      (hard_params)\n(int)   n_sides -----||----- nb_sides (user_params)\n&gt; Input Path(s) :\ntitle_file -----||----- Not defined (X)\n\n(X) Please define all input paths either in \"user_paths\" or \"required_paths\".\n</code></pre></p> <p>The input paths of the Proc <code>PolygonGeometryProc</code> can be properly mapped within the App by defining the <code>\"user_paths\"</code> and/or <code>\"required_paths\"</code> keys in its corresponding dictionary entry inside the workflow list.</p> <pre><code>from pathlib import Path\nfrom nuremics import Application\nfrom procs.general.PolygonGeometryProc.item import PolygonGeometryProc\nfrom procs.general.ProjectileModelProc.item import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\n\ndef main(\n    working_dir: Path = None,\n    studies: list = [\"Default\"],\n):\n    # --------------- #\n    # Define workflow #\n    # --------------- #\n    workflow = [\n        {\n            \"process\": PolygonGeometryProc,\n            \"user_params\": {\n                \"n_sides\": \"nb_sides\",\n            },\n            \"hard_params\": {\n                \"radius\": 0.5,\n            },\n            \"user_paths\": {\n                \"title_file\": \"plot_title.txt\",\n            },\n        },\n        {\n            \"process\": ProjectileModelProc,\n        },\n    ]\n\n    # ------------------ #\n    # Define application #\n    # ------------------ #\n    app = Application(\n        app_name=APP_NAME,\n        working_dir=working_dir,\n        workflow=workflow,\n        studies=studies,\n    )\n    # Run it!\n    app()\n\nif __name__ == \"__main__\":\n\n    # ------------------------ #\n    # Define working directory #\n    # ------------------------ #\n    working_dir = Path(os.environ[\"WORKING_DIR\"])\n\n    # -------------- #\n    # Define studies #\n    # -------------- #\n    studies = [\n        \"Study_Shape\",\n        \"Study_Velocity\",\n    ]\n\n    # --------------- #\n    # Run application #\n    # --------------- #\n    main(\n        working_dir=working_dir,\n        studies=studies,\n    )\n</code></pre> <p>When running the App again, NUREMICS detects that all required input paths for <code>PolygonGeometryProc</code> have been successfully mapped.</p> <p>However, it now reports that one or more output paths are missing. These are explicitly listed, and the developer is prompted to define them using the <code>\"output_paths\"</code> key.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| PolygonGeometryProc |\n&gt; Input Parameter(s) :\n(float) radius  -----||----- 0.5      (hard_params)\n(int)   n_sides -----||----- nb_sides (user_params)\n&gt; Input Path(s) :\ntitle_file -----||----- plot_title.txt (user_paths)\n&gt; Output Path(s) :\ncoords_file -----||----- Not defined (X)\nfig_file    -----||----- Not defined (X)\n\n(X) Please define all output paths in \"output_paths\".\n</code></pre></p> <p>The output paths of the Proc <code>PolygonGeometryProc</code> can be properly mapped within the App by defining the <code>\"output_paths\"</code> key in its corresponding dictionary entry inside the workflow list.</p> <p>In the same way, we also complete the mapping for the Proc <code>ProjectileModelProc</code> by providing all required entries: <code>\"user_params\"</code> and/or <code>\"hard_params\"</code>, <code>\"user_paths\"</code> and/or <code>\"required_paths\"</code>, <code>\"output_paths\"</code>.</p> <pre><code>from pathlib import Path\nfrom nuremics import Application\nfrom procs.general.PolygonGeometryProc.item import PolygonGeometryProc\nfrom procs.general.ProjectileModelProc.item import ProjectileModelProc\n\nAPP_NAME = \"DEMO_APP\"\n\ndef main(\n    working_dir: Path = None,\n    studies: list = [\"Default\"],\n):\n    # --------------- #\n    # Define workflow #\n    # --------------- #\n    workflow = [\n        {\n            \"process\": PolygonGeometryProc,\n            \"user_params\": {\n                \"n_sides\": \"nb_sides\",\n            },\n            \"hard_params\": {\n                \"radius\": 0.5,\n            },\n            \"user_paths\": {\n                \"title_file\": \"plot_title.txt\",\n            },\n            \"output_paths\": {\n                \"coords_file\": \"points_coordinates.csv\",\n                \"fig_file\": \"polygon_shape.png\",\n            },\n        },\n        {\n            \"process\": ProjectileModelProc,\n            \"user_params\": {\n                \"gravity\": \"gravity\",\n                \"mass\": \"mass\",\n            },\n            \"user_paths\": {\n                \"velocity_file\": \"velocity.json\",\n                \"configs_folder\": \"configs\",\n            },\n            \"required_paths\": {\n                \"coords_file\": \"points_coordinates.csv\",\n            },\n            \"output_paths\": {\n                \"comp_folder\": \"comparison\",\n            },\n        },\n    ]\n\n    # ------------------ #\n    # Define application #\n    # ------------------ #\n    app = Application(\n        app_name=APP_NAME,\n        working_dir=working_dir,\n        workflow=workflow,\n        studies=studies,\n    )\n    # Run it!\n    app()\n\nif __name__ == \"__main__\":\n\n    # ------------------------ #\n    # Define working directory #\n    # ------------------------ #\n    working_dir = Path(os.environ[\"WORKING_DIR\"])\n\n    # -------------- #\n    # Define studies #\n    # -------------- #\n    studies = [\n        \"Study_Shape\",\n        \"Study_Velocity\",\n    ]\n\n    # --------------- #\n    # Run application #\n    # --------------- #\n    main(\n        working_dir=working_dir,\n        studies=studies,\n    )\n</code></pre> <p>With all required mappings now properly defined for each Proc, the App can be executed without raising any errors. NUREMICS confirms that the full mapping is complete by prompting a summary for each Proc, indicating that all input parameters, input paths, and output paths have been successfully resolved.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>| PolygonGeometryProc |\n&gt; Input Parameter(s) :\n(float) radius  -----||----- 0.5      (hard_params)\n(int)   n_sides -----||----- nb_sides (user_params)\n&gt; Input Path(s) :\ntitle_file -----||----- plot_title.txt (user_paths)\n&gt; Output Path(s) :\ncoords_file -----||----- points_coordinates.csv (output_paths)\nfig_file    -----||----- polygon_shape.png      (output_paths)\n\n| ProjectileModelProc |\n&gt; Input Parameter(s) :\n(float) gravity -----||----- gravity (user_params)\n(float) mass    -----||----- mass    (user_params)\n&gt; Input Path(s) :\nvelocity_file  -----||----- velocity.json          (user_paths)\nconfigs_folder -----||----- configs                (user_paths)\ncoords_file    -----||----- points_coordinates.csv (required_paths)\n&gt; Output Path(s) :\ncomp_folder -----||----- comparison (output_paths)\n</code></pre></p> <p>As the App has now been fully assembled, NUREMICS displays a clean summary of its I/O interface, as it will appear to the end-user.</p> <p>This summary includes all declared user parameters and user paths required as inputs, along with the corresponding output files and folders that the App will generate. It serves as an explicit interface contract, allowing end-users to clearly understand what data they need to provide and what results to expect.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; INPUTS &lt;\n\n| User Parameters |\n&gt; nb_sides (int)\n&gt; gravity (float)\n&gt; mass (float)\n\n| User Paths |\n&gt; plot_title.txt\n&gt; velocity.json\n&gt; configs\n\n&gt; OUTPUTS &lt;\n\n&gt; points_coordinates.csv\n&gt; polygon_shape.png\n&gt; comparison\n</code></pre></p> <p>With all Procs implemented and properly assembled within the App, the development work is now complete. The developer\u2019s responsibility ends here (excluding, of course, the implementation of unit tests to ensure long-term maintainability, which falls outside the scope of this tutorial).</p> <p>The App is now fully functional and ready to be operated by end-users. From this point, users can interact with the App through its declared I/O interface, without needing to modify or understand the underlying code structure.</p>"},{"location":"handbook/practice/#use-app","title":"Use App","text":"<p>Now that the App has been fully implemented and assembled, this new section focuses on its usage from the end-user's perspective.</p> <p>We will demonstrate how to interact with a ready-to-use NUREMICS App, including how to provide inputs, run the App, and retrieve the expected outputs, all without needing to understand its internal structure.</p> <p>This section assumes the job of the developer is done, and shifts the focus to the operational phase of the App.</p>"},{"location":"handbook/practice/#define-working-environment","title":"Define Working Environment","text":"<p>Before running a NUREMICS App, the operator must first define the working environment in the <code>if __name__ == \"__main__\":</code> section of the App.</p> <p>This setup step specifies two key elements: - Working directory (<code>working_dir</code>): The root path where all input/output data, logs, and results will be stored. - Study names (<code>studies</code>): A list of identifiers corresponding to the different studies the operator wants to run. Each study will be managed in its own dedicated folder under the working directory.</p> <pre><code>if __name__ == \"__main__\":\n\n    # ------------------------ #\n    # Define working directory #\n    # ------------------------ #\n    working_dir = Path(os.environ[\"WORKING_DIR\"])\n\n    # -------------- #\n    # Define studies #\n    # -------------- #\n    studies = [\n        \"Study_Shape\",\n        \"Study_Velocity\",\n    ]\n\n    # --------------- #\n    # Run application #\n    # --------------- #\n    main(\n        working_dir=working_dir,\n        studies=studies,\n    )\n</code></pre> <p>In this example:</p> <ul> <li>The <code>working_dir</code> is read from the environment variable <code>WORKING_DIR</code> previously introduced.</li> <li>The <code>studies</code> list contains the names of the studies you want to run. You can define as many studies as needed, each representing a self-contained parametric study.</li> </ul> <p>As the App is executed, a new folder named after the App is automatically created under the specified <code>working_dir</code>. This folder acts as the root container for all the execution-related content generated by the App.</p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u2514\u2500\u2500 studies.json\n</code></pre></p> <p>\ud83d\udcc1 App folder (<code>DEMO_APP/</code>) The name of this folder is derived from the name of the application (<code>APP_NAME</code>) as defined during its construction.</p> <p>\ud83d\udcc4 Studies configuration file (<code>studies.json</code>) This file serves as a centralized configuration hub for each study, allowing the operator to specify which input data remain fixed and which can vary across various experiments.</p>"},{"location":"handbook/practice/#configure-studies","title":"Configure Studies","text":"<p>The NUREMICS terminal now provides feedback on the defined studies and halts execution, indicating that the first study <code>Study_Shape</code> requires configuration.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; STUDIES &lt;\n\n| Study_Shape |\n(X) nb_sides not configured.\n(X) gravity not configured.\n(X) mass not configured.\n(X) plot_title.txt not configured.\n(X) velocity.json not configured.\n(X) configs not configured.\n\n(X) Please configure file :\n&gt; .../DEMO_APP/studies.json\n</code></pre></p> <p>Let's configure <code>Study_Shape</code> by allowing only <code>nb_sides</code> to vary (by assigning a <code>true</code> value in the <code>studies.json</code> file), and keeping all other input data fixed (by assigning <code>false</code> values in the <code>studies.json</code> file) across the study.</p> <p>\ud83d\udcc4 <code>studies.json</code> <pre><code>{\n    \"Study_Shape\": {\n        \"execute\": true,\n        \"user_params\": {\n            \"nb_sides\": true,\n            \"gravity\": false,\n            \"mass\": false\n        },\n        \"user_paths\": {\n            \"plot_title.txt\": false,\n            \"velocity.json\": false,\n            \"configs\": false\n        }\n    },\n    \"Study_Velocity\": {\n        \"execute\": true,\n        \"user_params\": {\n            \"nb_sides\": null,\n            \"gravity\": null,\n            \"mass\": null\n        },\n        \"user_paths\": {\n            \"plot_title.txt\": null,\n            \"velocity.json\": null,\n            \"configs\": null\n        }\n    }\n}\n</code></pre></p> <p>At the next execution of the App, the NUREMICS terminal now prompts that <code>Study_Shape</code> is properly configured, but halts indicating that the second study <code>Study_Velocity</code> still requires configuration.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; STUDIES &lt;\n\n| Study_Shape |\n(V) nb_sides is variable.\n(V) gravity is fixed.\n(V) mass is fixed.\n(V) plot_title.txt is fixed.\n(V) velocity.json is fixed.\n(V) configs is fixed.\n\n| Study_Velocity |\n(X) nb_sides not configured.\n(X) gravity not configured.\n(X) mass not configured.\n(X) plot_title.txt not configured.\n(X) velocity.json not configured.\n(X) configs not configured.\n\n(X) Please configure file :\n&gt; .../DEMO_APP/studies.json\n</code></pre></p> <p>Let's this time configure <code>Study_Velocity</code> by allowing only <code>velocity.json</code> to vary, and keeping all other input data fixed across the study.</p> <p>\ud83d\udcc4 <code>studies.json</code> <pre><code>{\n    \"Study_Shape\": {\n        \"execute\": true,\n        \"user_params\": {\n            \"nb_sides\": true,\n            \"gravity\": false,\n            \"mass\": false\n        },\n        \"user_paths\": {\n            \"plot_title.txt\": false,\n            \"velocity.json\": false,\n            \"configs\": false\n        }\n    },\n    \"Study_Velocity\": {\n        \"execute\": true,\n        \"user_params\": {\n            \"nb_sides\": false,\n            \"gravity\": false,\n            \"mass\": false\n        },\n        \"user_paths\": {\n            \"plot_title.txt\": false,\n            \"velocity.json\": true,\n            \"configs\": false\n        }\n    }\n}\n</code></pre></p> <p>At the next execution of the App, the NUREMICS terminal now prompts that both <code>Study_Shape</code> and <code>Study_Velocity</code> are properly configured.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; STUDIES &lt;\n\n| Study_Shape |\n(V) nb_sides is variable.\n(V) gravity is fixed.\n(V) mass is fixed.\n(V) plot_title.txt is fixed.\n(V) velocity.json is fixed.\n(V) configs is fixed.\n\n| Study_Velocity |\n(V) nb_sides is fixed.\n(V) gravity is fixed.\n(V) mass is fixed.\n(V) plot_title.txt is fixed.\n(V) velocity.json is variable.\n(V) configs is fixed.\n</code></pre></p> <p>Going back to the data tree generated within the defined <code>working_dir</code>, we can see that a specific folder for each study has been created.</p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u251c\u2500\u2500 studies.json\n    \u251c\u2500\u2500 Study_Shape/\n    \u2514\u2500\u2500 Study_Velocity/\n</code></pre></p>"},{"location":"handbook/practice/#set-input-data","title":"Set Input Data","text":"<p>Each study directory within the data tree now contains an initialized input database that must be completed by the operator.</p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u251c\u2500\u2500 studies.json\n    \u251c\u2500\u2500 Study_Shape/\n    \u2502   \u251c\u2500\u2500 0_inputs/\n    \u2502   \u251c\u2500\u2500 inputs.json\n    \u2502   \u2514\u2500\u2500 inputs.csv\n    \u2514\u2500\u2500 Study_Velocity/\n        \u251c\u2500\u2500 0_inputs/\n        \u251c\u2500\u2500 inputs.json\n        \u2514\u2500\u2500 inputs.csv\n</code></pre></p> <p>This input database contains:</p> <ul> <li><code>0_inputs</code>: This folder must contain the input files and/or folders defined as <code>\"user_paths\"</code>.</li> <li><code>inputs.json</code>: This file must contain the input parameters defined as fixed <code>\"user_params\"</code>.</li> <li><code>inputs.csv</code>: This file must contain the input parameters defined as variable <code>\"user_params\"</code>.</li> </ul> <p>At this stage of the App execution, the NUREMICS terminal halts by indicating that the fixed input data must be set.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; SETTINGS &lt;\n\n| Study_Shape |\n&gt; Common : (X) gravity (X) mass (X) plot_title.txt (X) velocity.json (X) configs\n\n(X) Please set inputs :\n&gt; .../DEMO_APP/Study_Shape/inputs.json\n&gt; .../DEMO_APP/Study_Shape/0_inputs/plot_title.txt\n&gt; .../DEMO_APP/Study_Shape/0_inputs/velocity.json\n&gt; .../DEMO_APP/Study_Shape/0_inputs/configs\n</code></pre></p> <p>For the <code>Study_Shape</code>, we are speaking about:</p> <ul> <li><code>gravity</code> and <code>mass</code> within the <code>inputs.json</code> file.</li> <li><code>plot_title.txt</code>, <code>velocity.json</code> and <code>configs</code> within the <code>0_inputs</code> folder.</li> </ul> <p></p> <p>\ud83d\udcc4 <code>inputs.json</code> <pre><code>{\n    \"gravity\": -9.81,\n    \"mass\": 0.1\n}\n</code></pre> </p> <p>\ud83d\udcc4 <code>0_inputs/plot_title.txt</code> <pre><code>2D polygon shape\n</code></pre> </p> <p>\ud83d\udcc4 <code>0_inputs/velocity.json</code> <pre><code>{\n    \"v0\": 15.0,\n    \"angle\": 45.0\n}\n</code></pre> </p> <p>\ud83d\udcc4 <code>0_inputs/configs/solver_config.json</code> <pre><code>{\n    \"timestep\": 0.01\n}\n</code></pre> </p> <p>\ud83d\udcc4 <code>0_inputs/configs/display_config.json</code> <pre><code>{\n    \"fps\": 60,\n    \"size\": 700\n}\n</code></pre> </p> <p>All fixed input data have now been completed within the <code>Study_Shape</code> input database.</p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u251c\u2500\u2500 studies.json\n    \u251c\u2500\u2500 Study_Shape/\n    \u2502   \u251c\u2500\u2500 0_inputs/\n    \u2502   \u2502   \u251c\u2500\u2500 plot_title.txt\n    \u2502   \u2502   \u251c\u2500\u2500 velocity.json\n    \u2502   \u2502   \u2514\u2500\u2500 configs/\n    \u2502   \u2502       \u251c\u2500\u2500 solver_config.json\n    \u2502   \u2502       \u2514\u2500\u2500 display_config.json\n    \u2502   \u251c\u2500\u2500 inputs.json\n    \u2502   \u2514\u2500\u2500 inputs.csv\n    \u2514\u2500\u2500 Study_Velocity/\n        \u251c\u2500\u2500 0_inputs/\n        \u251c\u2500\u2500 inputs.json\n        \u2514\u2500\u2500 inputs.csv\n</code></pre></p> <p>At this stage of the App execution, the NUREMICS terminal prompts that all fixed input data are now properly set, but halts by indicating that datasets of variable input data must be defined (to conduct various experiments).</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; SETTINGS &lt;\n\n| Study_Shape |\n&gt; Common : (V) gravity (V) mass (V) plot_title.txt (V) velocity.json (V) configs\n\n(X) Please define at least one dataset in file :\n&gt; .../DEMO_APP/Study_Shape/inputs.csv\n</code></pre></p> <p>Let's define three datasets identified as <code>Test1</code>, <code>Test2</code> and <code>Test3</code> within the <code>input.csv</code> file.</p> <p>\ud83d\udcc4 <code>inputs.csv</code></p> ID nb_sides Test1 Test2 Test3 <p>We can now see that NUREMICS has properly identified the three defined datasets, but is waiting for the variable input data <code>nb_sides</code> to be set for each of them.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code> &gt; SETTINGS &lt;\n\n| Study_Shape |\n&gt; Common : (V) gravity (V) mass (V) plot_title.txt (V) velocity.json (V) configs\n&gt; Test1 : (X) nb_sides\n&gt; Test2 : (X) nb_sides\n&gt; Test3 : (X) nb_sides\n\n(X) Please set inputs :\n&gt; .../DEMO_APP/Study_Shape/inputs.csv\n</code></pre></p> <p>Let's thus set some values of <code>nb_sides</code> for each defined dataset within the <code>input.csv</code> file.</p> <p>\ud83d\udcc4 <code>inputs.csv</code></p> ID nb_sides Test1 3 Test2 4 Test3 5 <p>NUREMICS finally prompts that all input data are properly set for <code>Study_Shape</code>.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; SETTINGS &lt;\n\n| Study_Shape |\n&gt; Common : (V) gravity (V) mass (V) plot_title.txt (V) velocity.json (V) configs\n&gt; Test1 : (V) nb_sides\n&gt; Test2 : (V) nb_sides\n&gt; Test3 : (V) nb_sides\n</code></pre></p> <p>The same job must be done to set the input data for <code>Study_Velocity</code>.</p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u251c\u2500\u2500 studies.json\n    \u251c\u2500\u2500 Study_Shape/\n    \u2502   \u251c\u2500\u2500 0_inputs/\n    \u2502   \u2502   \u251c\u2500\u2500 plot_title.txt\n    \u2502   \u2502   \u251c\u2500\u2500 velocity.json\n    \u2502   \u2502   \u2514\u2500\u2500 configs/\n    \u2502   \u2502       \u251c\u2500\u2500 solver_config.json\n    \u2502   \u2502       \u2514\u2500\u2500 display_config.json\n    \u2502   \u251c\u2500\u2500 inputs.json\n    \u2502   \u2514\u2500\u2500 inputs.csv\n    \u2514\u2500\u2500 Study_Velocity/\n        \u251c\u2500\u2500 0_inputs/\n        \u2502   \u251c\u2500\u2500 0_datasets/\n        \u2502   \u2502   \u251c\u2500\u2500 Test1/\n        \u2502   \u2502   \u2502   \u2514\u2500\u2500 velocity.json\n        \u2502   \u2502   \u251c\u2500\u2500 Test2/\n        \u2502   \u2502   \u2502   \u2514\u2500\u2500 velocity.json\n        \u2502   \u2502   \u2514\u2500\u2500 Test3/\n        \u2502   \u2502       \u2514\u2500\u2500 velocity.json\n        \u2502   \u251c\u2500\u2500 plot_title.txt\n        \u2502   \u2514\u2500\u2500 configs/\n        \u2502       \u251c\u2500\u2500 solver_config.json\n        \u2502       \u2514\u2500\u2500 display_config.json\n        \u251c\u2500\u2500 inputs.json\n        \u2514\u2500\u2500 inputs.csv\n</code></pre> </p> <p>Let's here consider the same fixed input data <code>plot_title.txt</code> and <code>configs</code> as for the previous study <code>Study_Shape</code>.</p> <p></p> <p>\ud83d\udcc4 <code>inputs.json</code> <pre><code>{\n    \"nb_sides\": 5,\n    \"gravity\": -9.81\n}\n</code></pre> </p> <p>\ud83d\udcc4 <code>inputs.csv</code></p> ID Test1 Test2 Test3 <p></p> <p>\ud83d\udcc4 <code>0_inputs/0_datasets/Test1/velocity.json</code> <pre><code>{\n    \"v0\": 15.0,\n    \"angle\": 45.0\n}\n</code></pre> </p> <p>\ud83d\udcc4 <code>0_inputs/0_datasets/Test2/velocity.json</code> <pre><code>{\n    \"v0\": 20.0,\n    \"angle\": 45.0\n}\n</code></pre> </p> <p>\ud83d\udcc4 <code>0_inputs/0_datasets/Test3/velocity.json</code> <pre><code>{\n    \"v0\": 20.0,\n    \"angle\": 60.0\n}\n</code></pre> </p> <p>NUREMICS is now prompting that all input data are properly set for both <code>Study_Shape</code> and <code>Study_Velocity</code>.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; SETTINGS &lt;\n\n| Study_Shape |\n&gt; Common : (V) gravity (V) mass (V) plot_title.txt (V) velocity.json (V) configs\n&gt; Test1 : (V) nb_sides\n&gt; Test2 : (V) nb_sides\n&gt; Test3 : (V) nb_sides\n\n| Study_Velocity |\n&gt; Common : (V) nb_sides (V) gravity (V) plot_title.txt (V) configs\n&gt; Test1 : (V) mass (V) velocity.json\n&gt; Test2 : (V) mass (V) velocity.json\n&gt; Test3 : (V) mass (V) velocity.json\n</code></pre></p>"},{"location":"handbook/practice/#get-results","title":"Get Results","text":"<p>At this stage, NUREMICS is ready to run all the defined studies and generate the corresponding results.</p> <p>\ud83d\udc64\ud83d\udd04\ud83d\udda5\ufe0f <pre><code>&gt; RUNNING &lt;\n\n| Study_Shape | PolygonGeometryProc | Test1 |\n&gt; n_sides = 3\n&gt; radius = 0.5\n&gt; title_file = .../DEMO_APP/Study_Shape/0_inputs/plot_title.txt\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Shape | PolygonGeometryProc | Test2 |\n&gt; n_sides = 4\n&gt; radius = 0.5\n&gt; title_file = .../DEMO_APP/Study_Shape/0_inputs/plot_title.txt\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Shape | PolygonGeometryProc | Test3 |\n&gt; n_sides = 5\n&gt; radius = 0.5\n&gt; title_file = .../DEMO_APP/Study_Shape/0_inputs/plot_title.txt\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Shape | ProjectileModelProc | Test1 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; velocity_file = .../DEMO_APP/Study_Shape/0_inputs/velocity.json\n&gt; configs_folder = .../DEMO_APP/Study_Shape/0_inputs/configs\n&gt; coords_file = .../DEMO_APP/Study_Shape/1_PolygonGeometryProc/Test1/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Shape | ProjectileModelProc | Test2 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; velocity_file = .../DEMO_APP/Study_Shape/0_inputs/velocity.json\n&gt; configs_folder = .../DEMO_APP/Study_Shape/0_inputs/configs\n&gt; coords_file = .../DEMO_APP/Study_Shape/1_PolygonGeometryProc/Test2/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Shape | ProjectileModelProc | Test3 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; velocity_file = .../DEMO_APP/Study_Shape/0_inputs/velocity.json\n&gt; configs_folder = .../DEMO_APP/Study_Shape/0_inputs/configs\n&gt; coords_file = .../DEMO_APP/Study_Shape/1_PolygonGeometryProc/Test3/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Velocity | PolygonGeometryProc |\n&gt; n_sides = 5\n&gt; radius = 0.5\n&gt; title_file = .../DEMO_APP/Study_Velocity/0_inputs/plot_title.txt\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Velocity | ProjectileModelProc | Test1 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; configs_folder = .../DEMO_APP/Study_Velocity/0_inputs/configs\n&gt; velocity_file = .../DEMO_APP/Study_Velocity/0_inputs/0_datasets/Test1/velocity.json\n&gt; coords_file = .../DEMO_APP/Study_Velocity/1_PolygonGeometryProc/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Velocity | ProjectileModelProc | Test2 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; configs_folder = .../DEMO_APP/Study_Velocity/0_inputs/configs\n&gt; velocity_file = .../DEMO_APP/Study_Velocity/0_inputs/0_datasets/Test2/velocity.json\n&gt; coords_file = .../DEMO_APP/Study_Velocity/1_PolygonGeometryProc/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n\n| Study_Velocity | ProjectileModelProc | Test3 |\n&gt; gravity = -9.81\n&gt; mass = 0.1\n&gt; configs_folder = .../DEMO_APP/Study_Velocity/0_inputs/configs\n&gt; velocity_file = .../DEMO_APP/Study_Velocity/0_inputs/0_datasets/Test3/velocity.json\n&gt; coords_file = .../DEMO_APP/Study_Velocity/1_PolygonGeometryProc/points_coordinates.csv\n&gt;&gt;&gt; START\nCOMPLETED &lt;&lt;&lt;\n</code></pre></p> <p>The operator can then access the results in the output database generated by NUREMICS within the data tree. </p> <p>\ud83d\udc64\ud83d\udc41\ufe0f\ud83d\udcbe <pre><code>&lt;working_dir&gt;/\n\u2514\u2500\u2500 DEMO_APP/\n    \u251c\u2500\u2500 studies.json\n    \u251c\u2500\u2500 Study_Shape/\n    \u2502   \u251c\u2500\u2500 1_PolygonGeometryProc/\n    \u2502   \u2502   \u251c\u2500\u2500 Test1/\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 points_coordinates.csv\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 polygon_shape.png\n    \u2502   \u2502   \u251c\u2500\u2500 Test2/\n    \u2502   \u2502   \u2502   \u251c\u2500\u2500 points_coordinates.csv\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 polygon_shape.png\n    \u2502   \u2502   \u2514\u2500\u2500 Test3/\n    \u2502   \u2502       \u251c\u2500\u2500 points_coordinates.csv\n    \u2502   \u2502       \u2514\u2500\u2500 polygon_shape.png\n    \u2502   \u2514\u2500\u2500 2_ProjectileModelProc/\n    \u2502       \u251c\u2500\u2500 Test1/\n    \u2502       \u2502   \u2514\u2500\u2500 comparison/\n    \u2502       \u2502       \u251c\u2500\u2500 results.xlsx\n    \u2502       \u2502       \u2514\u2500\u2500 model_vs_theory.png\n    \u2502       \u251c\u2500\u2500 Test2/\n    \u2502       \u2502   \u2514\u2500\u2500 comparison/\n    \u2502       \u2502       \u251c\u2500\u2500 results.xlsx\n    \u2502       \u2502       \u2514\u2500\u2500 model_vs_theory.png\n    \u2502       \u2514\u2500\u2500 Test3/\n    \u2502           \u2514\u2500\u2500 comparison/\n    \u2502               \u251c\u2500\u2500 results.xlsx\n    \u2502               \u2514\u2500\u2500 model_vs_theory.png\n    \u2514\u2500\u2500 Study_Velocity/\n        \u251c\u2500\u2500 1_PolygonGeometryProc/\n        \u2502   \u251c\u2500\u2500 points_coordinates.csv\n        \u2502   \u2514\u2500\u2500 polygon_shape.png\n        \u2514\u2500\u2500 2_ProjectileModelProc/\n            \u251c\u2500\u2500 Test1/\n            \u2502   \u2514\u2500\u2500 comparison/\n            \u2502       \u251c\u2500\u2500 results.xlsx\n            \u2502       \u2514\u2500\u2500 model_vs_theory.png\n            \u251c\u2500\u2500 Test2/\n            \u2502   \u2514\u2500\u2500 comparison/\n            \u2502       \u251c\u2500\u2500 results.xlsx\n            \u2502       \u2514\u2500\u2500 model_vs_theory.png\n            \u2514\u2500\u2500 Test3/\n                \u2514\u2500\u2500 comparison/\n                    \u251c\u2500\u2500 results.xlsx\n                    \u2514\u2500\u2500 model_vs_theory.png\n</code></pre></p>"},{"location":"handbook/theory/","title":"Theory","text":""},{"location":"handbook/theory/#design-patterns","title":"Design Patterns","text":"<p>Let\u2019s introduce the core design patterns behind Procs and Apps in NUREMICS.</p>"},{"location":"handbook/theory/#proc","title":"Proc","text":"<p>A Proc can be seen as an algorithmic box which processes some input data and produces corresponding output data.</p> <p>The input data typically fall into two main categories:</p> <ul> <li> <p>Input parameters: Scalar values such as <code>float</code>, <code>int</code>, <code>bool</code>, or <code>str</code>.</p> </li> <li> <p>Input paths: Files or folders provided as <code>Path</code> objects (from Python's <code>pathlib</code> module), pointing to structured data on disk.</p> </li> </ul> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n\n  **Parameters** {\n    float radius\n    int n_sides\n  }\n  **Paths** {\n    file title_file \"txt\"\n  }</code></pre> <p>As mentioned in the Handbook Overview, the algorithmic box of the Proc is a class composed of functions (Op) called sequentially within its <code>__call__</code> method.</p> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **PolygonGeometryProc** : feeds\n\n  **Parameters** {\n    float radius\n    int n_sides\n  }\n  **Paths** {\n    file title_file \"txt\"\n  }\n  **PolygonGeometryProc** {\n    op generate_polygon_shape\n    op plot_polygon_shape\n  }</code></pre> <p>Output data are typically expressed as <code>Path</code> objects as well, corresponding to files or folders written to disk during the execution of the Proc.</p> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **PolygonGeometryProc** : feeds\n  **PolygonGeometryProc** ||--|| **Outputs** : generates\n\n  **Parameters** {\n    float radius\n    int n_sides\n  }\n  **Paths** {\n    file title_file \"txt\"\n  }\n  **PolygonGeometryProc** {\n    op generate_polygon_shape\n    op plot_polygon_shape\n  }\n  **Outputs** {\n    file coords_file \"csv\"\n    file fig_file \"png\"\n  }</code></pre> <p>For the sake of example, let's define another Proc considering the same structure.</p> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **ProjectileModelProc** : feeds\n  **ProjectileModelProc** ||--|| **Outputs** : generates\n\n  **Parameters** {\n    float gravity\n    float mass\n  }\n  **Paths** {\n    file velocity_file \"json\"\n    folder configs_folder \"_\"\n    file coords_file \"csv\"\n  }\n  **ProjectileModelProc** {\n    op simulate_projectile_motion\n    op calculate_analytical_trajectory\n    op compare_model_vs_analytical_trajectories\n  }\n  **Outputs** {\n    folder comp_folder \"_\"\n  }</code></pre>"},{"location":"handbook/theory/#app","title":"App","text":"<p>A final end-user App can be built by plugging together previously implemented Procs, and specifying their sequential order of execution within the workflow.</p> <pre><code>flowchart RL\n  **PolygonGeometryProc** e1@--1--o **DEMO_APP**\n  **ProjectileModelProc** e2@--2--o **DEMO_APP**\n  **TrajectoryAnalysisProc** e3@--3--o **DEMO_APP**\n  **generate_polygon_shape** e4@--A--o **PolygonGeometryProc**\n  **plot_polygon_shape** e5@--B--o **PolygonGeometryProc**\n  **simulate_projectile_motion** e6@--A--o **ProjectileModelProc**\n  **calculate_analytical_trajectory** e7@--B--o **ProjectileModelProc**\n  **compare_model_vs_analytical_trajectories** e8@--C--o **ProjectileModelProc**\n  **plot_overall_model_vs_theory** e9@--A--o **TrajectoryAnalysisProc**\n  e1@{ animate: true }\n  e2@{ animate: true }\n  e3@{ animate: true }\n  e4@{ animate: true }\n  e5@{ animate: true }\n  e6@{ animate: true }\n  e7@{ animate: true }\n  e8@{ animate: true }\n  e9@{ animate: true }</code></pre> <p>Each Proc integrated into the App defines its own set of inputs and outputs, specific to its internal algorithmic logic. When these Procs are assembled into a workflow, the App itself exposes a higher-level set of inputs and outputs. These define the I/O interface presented to the end-user, who provides the necessary input data and retrieves the final results upon execution.</p> <p>The assembly step is performed through a mapping between the internal I/O data of each Proc and the global I/O interface of the App. This mapping mechanism serves multiple purposes:</p> <ul> <li> <p>It defines which data are exposed to the end-user (and how they are displayed) and which remain internal to the workflow.</p> </li> <li> <p>It manages the data dependencies between Procs, when the output of one Proc is used as input for another.</p> </li> </ul> <p>This notably ensures a coherent and seamless management of data across the workflow, while delivering a clean and focused I/O interface tailored to the user's needs.</p> <p>The mapping between a Proc and the App starts by specifying which Proc input parameters are exposed to the end-user, and how they are labeled in the App input interface.</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }</code></pre> <p>The Proc input parameters that remain internal to the workflow are assigned fixed values directly within the mapping definition, without being exposed to the end-user.</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n  **hard_params** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }\n  **hard_params** {\n    float radius \"0.5\"\n  }</code></pre> <p>The Proc input paths that need to be provided by the end-user are specified by defining the expected file or folder names within the App input interface.</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n  **hard_params** ||--|| **PolygonGeometryProc** : mapping\n  **user_paths** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }\n  **hard_params** {\n    float radius \"0.5\"\n  }\n  **user_paths** {\n    file title_file \"plot_title.txt\"\n  }</code></pre> <p>The Proc input paths can also be mapped to output paths produced by a previous Proc within the workflow (although this does not apply here, as we are currently focusing on the first Proc in the workflow).</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **DEMO_APP** ||--|| **required_paths** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n  **hard_params** ||--|| **PolygonGeometryProc** : mapping\n  **user_paths** ||--|| **PolygonGeometryProc** : mapping\n  **required_paths** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }\n  **hard_params** {\n    float radius \"0.5\"\n  }\n  **user_paths** {\n    file title_file \"plot_title.txt\"\n  }\n  **required_paths** {\n    _ _ \"_\"\n  }</code></pre> <p>Finally, the Proc output paths are specified by indicating the name of the file(s) or folder(s) that will be written by the Proc during the workflow execution.</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **DEMO_APP** ||--|| **required_paths** : mapping\n  **DEMO_APP** ||--|| **output_paths** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n  **hard_params** ||--|| **PolygonGeometryProc** : mapping\n  **user_paths** ||--|| **PolygonGeometryProc** : mapping\n  **required_paths** ||--|| **PolygonGeometryProc** : mapping\n  **output_paths** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }\n  **hard_params** {\n    float radius \"0.5\"\n  }\n  **user_paths** {\n    file title_file \"plot_title.txt\"\n  }\n  **required_paths** {\n    _ _ \"_\"\n  }\n  **output_paths** {\n    file coords_file \"points_coordinates.csv\"\n    file fig_file \"polygon_shape.png\"\n  }</code></pre> <p>Let's now assemble the second Proc to be executed by the App within the workflow, by establishing a dependency: the output data produced by the first Proc will serve as input data for this second one.</p> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **DEMO_APP** ||--|| **required_paths** : mapping\n  **DEMO_APP** ||--|| **output_paths** : mapping\n  **user_params** ||--|| **ProjectileModelProc** : mapping\n  **hard_params** ||--|| **ProjectileModelProc** : mapping\n  **user_paths** ||--|| **ProjectileModelProc** : mapping\n  **required_paths** ||--|| **ProjectileModelProc** : mapping\n  **output_paths** ||--|| **ProjectileModelProc** : mapping\n\n  **user_params** {\n    float gravity \"gravity\"   \n    float mass \"mass\"\n  }\n  **hard_params** {\n    _ _ \"_\"\n  }\n  **user_paths** {\n    file velocity_file \"velocity.json\"\n    folder configs_folder \"configs\"\n  }\n  **required_paths** {\n    file coords_file \"points_coordinates.csv\"\n  }\n  **output_paths** {\n    folder comp_folder \"comparison\"\n  }</code></pre> <p>Once all Procs have been assembled into the App, the final I/O interface presented to the end-user emerges.</p> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path1[\"plot_title.txt _(file)_\"]\n      path2[\"velocity.json _(file)_\"]\n      path3[\"configs _(folder)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"nb_sides _(int)_\"]\n      param2[\"gravity _(float)_\"]\n      param3[\"mass _(float)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc1[\"PolygonGeometryProc\"]\n    proc2[\"ProjectileModelProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out1[\"points_coordinates.csv _(file)_\"]\n    out2[\"polygon_shape.png _(file)_\"]\n    out3[\"comparison _(folder)_\"]\n  end\n\n  **INPUTS** --&gt; **DEMO_APP**\n  **DEMO_APP** --&gt; **OUTPUTS**</code></pre> <p>It is also insightful for the end-user to present this I/O interface by showing which INPUTS are used by each Proc of the App, and which OUTPUTS are written by each of them.</p> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path1[\"plot_title.txt _(file)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"nb_sides _(int)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc1[\"PolygonGeometryProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out1[\"points_coordinates.csv _(file)_\"]\n    out2[\"polygon_shape.png _(file)_\"]\n  end\n\n  **INPUTS** --&gt; proc1\n  proc1 --&gt; **OUTPUTS**</code></pre> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path2[\"velocity.json _(file)_\"]\n      path3[\"configs _(folder)_\"]\n      out1[\"points_coordinates.csv _(file)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param2[\"gravity _(float)_\"]\n      param3[\"mass _(float)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc2[\"ProjectileModelProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out3[\"comparison _(folder)_\"]\n  end\n\n  **INPUTS** --&gt; proc2\n  proc2 --&gt; **OUTPUTS**\n\n  classDef blueBox fill:#d0e6ff,stroke:#339,stroke-width:1.5px;\n  class out1 blueBox;</code></pre>"},{"location":"handbook/theory/#usability","title":"Usability","text":"<p>The Apps built with NUREMICS come with a lean and pragmatic user interface by design. No flashy GUI, but instead, the focus is on simplicity and efficiency:</p> <ul> <li> <p>An input database that the operator completes by editing configuration files and uploading the required input files and folders.</p> </li> <li> <p>A terminal interface that provides informative feedback at each execution, clearly indicating what the App is doing and what actions are expected from the operator.</p> </li> <li> <p>An output database that stores all results in a well-structured and traceable folder hierarchy.</p> </li> </ul> <pre><code>sequenceDiagram\n    actor Operator\n    Operator-&gt;&gt;DEMO_APP: Execution\n    DEMO_APP-&gt;&gt;INPUTS: Initialize database\n    DEMO_APP-&gt;&gt;Operator: Terminal feedback\n    Operator-&gt;&gt;INPUTS: Complete database\n    Operator-&gt;&gt;DEMO_APP: Execution\n    DEMO_APP-&gt;&gt;INPUTS: Read database\n    DEMO_APP-&gt;&gt;OUTPUTS: Write database\n    DEMO_APP-&gt;&gt;Operator: Terminal feedback\n    Operator-&gt;&gt;OUTPUTS: Access results</code></pre> <p>This streamlined approach prioritizes clarity, control, and reproducibility, making each App built with NUREMICS well-suited for both direct interaction by end-users and seamless integration into larger software ecosystems. In such environments, NUREMICS can operate as a backend computational engine, interacting programmatically with other tools (such as web applications) that provide their own user interfaces.</p>"},{"location":"handbook/theory/#configuration","title":"Configuration","text":"<p>When running an App, the operator first defines a set of studies aimed at exploring the INPUTS space and analyzing the outcomes in the OUTPUTS space.</p> <pre><code>flowchart LR\n    Study_Shape\n    Study_Velocity</code></pre> <p>The operator then configures each study by selecting which inputs stay constant (Fixed) and which ones change (Variable) across the various experiments.</p> <pre><code>flowchart LR\n\n  subgraph Fixed1[\"**Fixed**\"]\n    direction TB\n\n    subgraph Paths_Fixed1[\"**Paths**\"]\n      direction LR\n      path1_1[\"plot_title.txt\"]\n      path2_1[\"velocity.json\"]\n      path3_1[\"configs\"]\n    end\n\n    subgraph Parameter_Fixed1[\"**Parameters**\"]\n      direction LR\n      param2_1[\"gravity\"]\n      param3_1[\"mass\"]\n    end\n  end\n\n  subgraph Variable1[\"**Variable**\"]\n    direction TB\n\n    subgraph Paths_Variable1[\"**Paths**\"]\n      direction LR\n      no_path[\"_\"]\n    end\n\n    subgraph Parameter_Variable1[\"**Parameters**\"]\n      direction LR\n      param1_1[\"nb_sides\"]\n    end\n  end\n\n  Study_Shape --&gt; Fixed1\n  Study_Shape --&gt; Variable1\n\n  subgraph Fixed2[\"**Fixed**\"]\n    direction TB\n\n    subgraph Paths_Fixed2[\"**Paths**\"]\n      direction LR\n      path1_2[\"plot_title.txt\"]\n      path3_2[\"configs\"]\n    end\n\n    subgraph Parameter_Fixed2[\"**Parameters**\"]\n      direction LR\n      param1_2[\"nb_sides\"]\n      param2_2[\"gravity\"]\n      param3_2[\"mass\"]\n    end\n  end\n\n  subgraph Variable2[\"**Variable**\"]\n    direction TB\n\n    subgraph Paths_Variable2[\"**Paths**\"]\n      direction LR\n      path2_2[\"velocity.json\"]\n    end\n\n    subgraph Parameter_Variable2[\"**Parameters**\"]\n      direction LR\n      no_param[\"_\"]\n    end\n  end\n\n  Study_Velocity --&gt; Fixed2\n  Study_Velocity --&gt; Variable2</code></pre>"},{"location":"handbook/theory/#settings","title":"Settings","text":"<p>To conduct experiments, the operator assigns values for both fixed and variable inputs: fixed inputs remain constant across all experiments (Common), while variable inputs are adjusted from one experiment to another (Test1, Test2, ...).</p> <pre><code>flowchart LR\n    Study_Shape --&gt; Study1_Common[\"Common\"]\n    Study_Shape --&gt; Study1_Test1[\"Test1\"]\n    Study_Shape --&gt; Study1_Test2[\"Test2\"]\n    Study_Shape --&gt; Study1_Test3[\"...\"]\n\n    Study1_Common --&gt; common1_param2[\"gravity = ...\"]\n    Study1_Common --&gt; common1_param3[\"mass = ...\"]\n    Study1_Common --&gt; common1_input1[\"plot_title.txt _(uploaded)_\"]\n    Study1_Common --&gt; common1_input2[\"velocity.json _(uploaded)_\"]\n    Study1_Common --&gt; common1_input3[\"configs _(uploaded)_\"]\n\n    Study1_Test1 --&gt; test1_param1[\"nb_sides = ...\"]\n    Study1_Test2 --&gt; test2_param1[\"nb_sides = ...\"]\n    Study1_Test3 --&gt; test3_param1[\"nb_sides = ...\"]\n\n    Study_Velocity --&gt; Study2_Common[\"Common\"]\n    Study_Velocity --&gt; Study2_Test1[\"Test1\"]\n    Study_Velocity --&gt; Study2_Test2[\"Test2\"]\n    Study_Velocity --&gt; Study2_Test3[\"...\"]\n\n    Study2_Common --&gt; common2_param1[\"nb_sides = ...\"]\n    Study2_Common --&gt; common2_param2[\"gravity = ...\"]\n    Study2_Common --&gt; common2_param3[\"mass = ...\"]\n    Study2_Common --&gt; common2_input1[\"plot_title.txt _(uploaded)_\"]\n    Study2_Common --&gt; common2_input3[\"configs _(uploaded)_\"]\n\n    Study2_Test1 --&gt; test1_path2[\"velocity.json _(uploaded)_\"]\n    Study2_Test2 --&gt; test2_path2[\"velocity.json _(uploaded)_\"]\n    Study2_Test3 --&gt; test3_path2[\"velocity.json _(uploaded)_\"]</code></pre>"},{"location":"handbook/theory/#results","title":"Results","text":"<p>At the end of the execution, results are stored in a structured output tree, ready for review or further processing. The outputs are first organized by Proc, each of them writing its own result data. Within each Proc, the results are further subdivided by experiment (Test1, Test2, ...), ensuring a clear separation and traceability of outcomes across the entire study.</p> <p>This organization is automatically determined based on how the study is configured by the operator. NUREMICS analyzes which input data are marked as fixed or variable, and how they connect to the internal workflow of the App. If a Proc directly depends on variable inputs, or indirectly through upstream dependencies, it will generate distinct outputs for each experiment. Otherwise, it will produce shared outputs only once.</p> <p>This logic ensures that only the necessary parts of the workflow are repeated through experimentations, and that the output structure faithfully reflects the configuration of the study along with the internal dependencies within the workflow.</p> <pre><code>flowchart LR\n    Study_Shape --&gt; Study1_PolygonGeometryProc[\"PolygonGeometryProc\"]\n    Study_Shape --&gt; Study1_ProjectileModelProc[\"ProjectileModelProc\"]\n\n    Study1_PolygonGeometryProc --&gt; Study1_PolygonGeometryProc_Test1[\"Test1\"]\n    Study1_PolygonGeometryProc --&gt; Study1_PolygonGeometryProc_Test2[\"Test2\"]\n    Study1_PolygonGeometryProc --&gt; Study1_PolygonGeometryProc_Test3[\"...\"]\n\n    Study1_PolygonGeometryProc_Test1 --&gt; Study1_PolygonGeometryProc_Test1_output1[\"points_coordinates.csv\"]\n    Study1_PolygonGeometryProc_Test1 --&gt; Study1_PolygonGeometryProc_Test1_output2[\"polygon_shape.png\"]\n    Study1_PolygonGeometryProc_Test2 --&gt; Study1_PolygonGeometryProc_Test2_output1[\"points_coordinates.csv\"]\n    Study1_PolygonGeometryProc_Test2 --&gt; Study1_PolygonGeometryProc_Test2_output2[\"polygon_shape.png\"]\n    Study1_PolygonGeometryProc_Test3 --&gt; Study1_PolygonGeometryProc_Test3_output1[\"points_coordinates.csv\"]\n    Study1_PolygonGeometryProc_Test3 --&gt; Study1_PolygonGeometryProc_Test3_output2[\"polygon_shape.png\"]\n\n    Study1_ProjectileModelProc --&gt; Study1_ProjectileModelProc_Test1[\"Test1\"]\n    Study1_ProjectileModelProc --&gt; Study1_ProjectileModelProc_Test2[\"Test2\"]\n    Study1_ProjectileModelProc --&gt; Study1_ProjectileModelProc_Test3[\"...\"]\n\n    Study1_ProjectileModelProc_Test1 --&gt; Study1_ProjectileModelProc_Test1_output3[\"comparison\"]\n    Study1_ProjectileModelProc_Test2 --&gt; Study1_ProjectileModelProc_Test2_output3[\"comparison\"]\n    Study1_ProjectileModelProc_Test3 --&gt; Study1_ProjectileModelProc_Test3_output3[\"comparison\"]\n\n    Study_Velocity --&gt; Study2_PolygonGeometryProc[\"PolygonGeometryProc\"]\n    Study_Velocity --&gt; Study2_ProjectileModelProc[\"ProjectileModelProc\"]\n\n    Study2_PolygonGeometryProc --&gt; Study2_PolygonGeometryProc_Common_output1[\"points_coordinates.csv\"]\n    Study2_PolygonGeometryProc --&gt; Study2_PolygonGeometryProc_Common_output2[\"polygon_shape.png\"]\n\n    Study2_ProjectileModelProc --&gt; Study2_ProjectileModelProc_Test1[\"Test1\"]\n    Study2_ProjectileModelProc --&gt; Study2_ProjectileModelProc_Test2[\"Test2\"]\n    Study2_ProjectileModelProc --&gt; Study2_ProjectileModelProc_Test3[\"...\"]\n\n    Study2_ProjectileModelProc_Test1 --&gt; Study2_ProjectileModelProc_Test1_output3[\"comparison\"]\n    Study2_ProjectileModelProc_Test2 --&gt; Study2_ProjectileModelProc_Test2_output3[\"comparison\"]\n    Study2_ProjectileModelProc_Test3 --&gt; Study2_ProjectileModelProc_Test3_output3[\"comparison\"]</code></pre>  Explore NUREMICS in:       Practice"},{"location":"labs/Apps/General/DEMO_APP/","title":"DEMO_APP","text":""},{"location":"labs/Apps/General/DEMO_APP/#workflow","title":"Workflow","text":"<ol> <li><code>PolygonGeometryProc</code>: Generate and plot a regular 2D polygon shape.   A/ <code>generate_polygon_shape</code>: Generate the 2D coordinates of a regular polygon.   B/ <code>plot_polygon_shape</code>: Plot a closed 2D polygon from a set of points.</li> <li><code>ProjectileModelProc</code>: Simulate the motion of a projectile and compare its trajectory with the analytical solution.   A/ <code>simulate_projectile_motion</code>: Simulate the motion of a 2D rigid body under gravity projected with an initial velocity.   B/ <code>calculate_analytical_trajectory</code>: Calculate the theoretical trajectory of a projectile using analytical equations.   C/ <code>compare_model_vs_analytical_trajectories</code>: Plot and save the comparison between simulated (model) and theoretical projectile trajectories.</li> <li><code>TrajectoryAnalysisProc</code>: Perform overall comparisons between simulated (model) and theoretical trajectories.   A/ <code>plot_overall_model_vs_theory</code>: Generate overall comparative plots of simulated (model) and theoritical trajectories.</li> </ol> <pre><code>flowchart RL\n  **PolygonGeometryProc** e1@--1--o **DEMO_APP**\n  **ProjectileModelProc** e2@--2--o **DEMO_APP**\n  **TrajectoryAnalysisProc** e3@--3--o **DEMO_APP**\n  **generate_polygon_shape** e4@--A--o **PolygonGeometryProc**\n  **plot_polygon_shape** e5@--B--o **PolygonGeometryProc**\n  **simulate_projectile_motion** e6@--A--o **ProjectileModelProc**\n  **calculate_analytical_trajectory** e7@--B--o **ProjectileModelProc**\n  **compare_model_vs_analytical_trajectories** e8@--C--o **ProjectileModelProc**\n  **plot_overall_model_vs_theory** e9@--A--o **TrajectoryAnalysisProc**\n  e1@{ animate: true }\n  e2@{ animate: true }\n  e3@{ animate: true }\n  e4@{ animate: true }\n  e5@{ animate: true }\n  e6@{ animate: true }\n  e7@{ animate: true }\n  e8@{ animate: true }\n  e9@{ animate: true }</code></pre>"},{"location":"labs/Apps/General/DEMO_APP/#mapping","title":"Mapping","text":"<pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **hard_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **DEMO_APP** ||--|| **output_paths** : mapping\n  **user_params** ||--|| **PolygonGeometryProc** : mapping\n  **hard_params** ||--|| **PolygonGeometryProc** : mapping\n  **user_paths** ||--|| **PolygonGeometryProc** : mapping\n  **output_paths** ||--|| **PolygonGeometryProc** : mapping\n\n  **user_params** {\n    int n_sides \"nb_sides\"\n  }\n  **hard_params** {\n    float radius \"0.5\"\n  }\n  **user_paths** {\n    file title_file \"plot_title.txt\"\n  }\n  **output_paths** {\n    file coords_file \"points_coordinates.csv\"\n    file fig_file \"polygon_shape.png\"\n  }</code></pre> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **user_params** : mapping\n  **DEMO_APP** ||--|| **user_paths** : mapping\n  **DEMO_APP** ||--|| **required_paths** : mapping\n  **DEMO_APP** ||--|| **output_paths** : mapping\n  **user_params** ||--|| **ProjectileModelProc** : mapping\n  **user_paths** ||--|| **ProjectileModelProc** : mapping\n  **required_paths** ||--|| **ProjectileModelProc** : mapping\n  **output_paths** ||--|| **ProjectileModelProc** : mapping\n\n  **user_params** {\n    float gravity \"gravity\"   \n    float mass \"mass\"\n  }\n  **user_paths** {\n    file velocity_file \"velocity.json\"\n    folder configs_folder \"configs\"\n  }\n  **required_paths** {\n    file coords_file \"points_coordinates.csv\"\n  }\n  **output_paths** {\n    folder comp_folder \"comparison\"\n  }</code></pre> <pre><code>erDiagram\n  **DEMO_APP** ||--|| **overall_analysis** : mapping\n  **DEMO_APP** ||--|| **output_paths** : mapping\n  **overall_analysis** ||--|| **TrajectoryAnalysisProc** : mapping\n  **output_paths** ||--|| **TrajectoryAnalysisProc** : mapping\n\n  **overall_analysis** {\n    folder comp_folder \"comparison\"\n  }\n  **output_paths** {\n    file fig_file \"overall_comparisons.png\" \n  }</code></pre>"},{"location":"labs/Apps/General/DEMO_APP/#io-interface","title":"I/O Interface","text":"<pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path1[\"plot_title.txt _(file)_\"]\n      path2[\"velocity.json _(file)_\"]\n      path3[\"configs _(folder)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"nb_sides _(int)_\"]\n      param2[\"gravity _(float)_\"]\n      param3[\"mass _(float)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc1[\"PolygonGeometryProc\"]\n    proc2[\"ProjectileModelProc\"]\n    proc3[\"TrajectoryAnalysisProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out1[\"points_coordinates.csv _(file)_\"]\n    out2[\"polygon_shape.png _(file)_\"]\n    out3[\"comparison _(folder)_\"]\n    out4[\"overall_comparisons.png _(file)_\"]\n  end\n\n  **INPUTS** --&gt; **DEMO_APP**\n  **DEMO_APP** --&gt; **OUTPUTS**</code></pre> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path1[\"plot_title.txt _(file)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param1[\"nb_sides _(int)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc1[\"PolygonGeometryProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out1[\"points_coordinates.csv _(file)_\"]\n    out2[\"polygon_shape.png _(file)_\"]\n  end\n\n  **INPUTS** --&gt; proc1\n  proc1 --&gt; **OUTPUTS**</code></pre> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      path2[\"velocity.json _(file)_\"]\n      path3[\"configs _(folder)_\"]\n      out1[\"points_coordinates.csv _(file)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param2[\"gravity _(float)_\"]\n      param3[\"mass _(float)_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc2[\"ProjectileModelProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out3[\"comparison _(folder)_\"]\n  end\n\n  **INPUTS** --&gt; proc2\n  proc2 --&gt; **OUTPUTS**\n\n  classDef blueBox fill:#d0e6ff,stroke:#339,stroke-width:1.5px;\n  class out1 blueBox;</code></pre> <pre><code>flowchart LR\n  subgraph **INPUTS**\n    direction TB\n\n    subgraph **Paths**\n      direction LR\n      out3[\"comparison _(folder)_\"]\n    end\n\n    subgraph **Parameters**\n      direction LR\n      param[\"_\"]\n    end\n  end\n\n  subgraph **DEMO_APP**\n    direction RL\n    proc3[\"TrajectoryAnalysisProc\"]\n  end\n\n  subgraph **OUTPUTS**\n    direction RL\n    out4[\"overall_comparisons.png _(file)_\"]\n  end\n\n  **INPUTS** --&gt; proc3\n  proc3 --&gt; **OUTPUTS**\n\n  classDef blueBox fill:#d0e6ff,stroke:#339,stroke-width:1.5px;\n  class out3 blueBox;</code></pre>"},{"location":"labs/Apps/General/DEMO_APP/#inputs","title":"INPUTS","text":""},{"location":"labs/Apps/General/DEMO_APP/#parameters","title":"Parameters","text":"<ul> <li><code>nb_sides</code>: Number of sides of the polygon.</li> <li><code>gravity</code>: Gravitational acceleration (m/s\u00b2).</li> <li><code>mass</code>: Mass of the body (kg).</li> </ul>"},{"location":"labs/Apps/General/DEMO_APP/#paths","title":"Paths","text":"<ul> <li><code>plot_title.txt</code>: File containing the plot title of the 2D polygon shape.</li> <li><code>velocity.json</code>: File containing the velocity initial conditions {v0 (m/s); angle (\u00b0)}.</li> <li><code>configs/</code> <code>solver_config.json</code>: File containing the parameters for solver configuration.  <code>display_config.json</code>: File containing the parameters for display configuration.</li> </ul>"},{"location":"labs/Apps/General/DEMO_APP/#outputs","title":"OUTPUTS","text":"<ul> <li><code>points_coordinates.csv</code>: File containing the X/Y coordinates of the polygon vertices.</li> <li><code>polygon_shape.png</code>: Image of the plotted polygon figure.</li> <li><code>comparison/</code> <code>results.xlsx</code>: File containing simulated (model) and theoritical trajectories.  <code>model_vs_theory.png</code>: Image comparing both trajectories.</li> <li><code>overall_comparisons.png</code>: Image containing overall comparative plots.</li> </ul>      View source code"},{"location":"labs/Procs/General/PolygonGeometryProc/","title":"PolygonGeometryProc","text":""},{"location":"labs/Procs/General/PolygonGeometryProc/#process","title":"Process","text":"<p>Generate and plot a regular 2D polygon shape. A/ <code>generate_polygon_shape</code>: Generate the 2D coordinates of a regular polygon. B/ <code>plot_polygon_shape</code>: Plot a closed 2D polygon from a set of points.</p> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **PolygonGeometryProc** : feeds\n  **PolygonGeometryProc** ||--|| **Outputs** : generates\n\n  **Parameters** {\n    float radius\n    int n_sides\n  }\n  **Paths** {\n    file title_file \"txt\"\n  }\n  **PolygonGeometryProc** {\n    op generate_polygon_shape\n    op plot_polygon_shape\n  }\n  **Outputs** {\n    file coords_file \"csv\"\n    file fig_file \"png\"\n  }</code></pre>"},{"location":"labs/Procs/General/PolygonGeometryProc/#input-parameters","title":"Input Parameter(s)","text":"<ul> <li><code>radius</code>: Radius (m) of the circumscribed circle of the polygon.</li> <li><code>n_sides</code>: Number of sides of the polygon.</li> </ul>"},{"location":"labs/Procs/General/PolygonGeometryProc/#input-paths","title":"Input Path(s)","text":"<ul> <li><code>title_file</code>: File containing the plot title of the 2D polygon shape.</li> </ul>"},{"location":"labs/Procs/General/PolygonGeometryProc/#output-paths","title":"Output Path(s)","text":"<ul> <li><code>coords_file</code>: File containing the X/Y coordinates of the polygon vertices.</li> <li><code>fig_file</code>: Image of the plotted polygon figure.</li> </ul>      View source code"},{"location":"labs/Procs/General/ProjectileModelProc/","title":"ProjectileModelProc","text":""},{"location":"labs/Procs/General/ProjectileModelProc/#process","title":"Process","text":"<p>Simulate the motion of a projectile and compare its trajectory with the analytical solution. A/ <code>simulate_projectile_motion</code>: Simulate the motion of a 2D rigid body under gravity projected with an initial velocity. B/ <code>calculate_analytical_trajectory</code>: Calculate the theoretical trajectory of a projectile using analytical equations. C/ <code>compare_model_vs_analytical_trajectories</code>: Plot and save the comparison between simulated (model) and theoretical projectile trajectories.</p> <pre><code>erDiagram\n  **Parameters** ||--|| **Inputs** : provides\n  **Paths** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **ProjectileModelProc** : feeds\n  **ProjectileModelProc** ||--|| **Outputs** : generates\n\n  **Parameters** {\n    float gravity\n    float mass\n  }\n  **Paths** {\n    file velocity_file \"json\"\n    folder configs_folder \"_\"\n    file coords_file \"csv\"\n  }\n  **ProjectileModelProc** {\n    op simulate_projectile_motion\n    op calculate_analytical_trajectory\n    op compare_model_vs_analytical_trajectories\n  }\n  **Outputs** {\n    folder comp_folder \"_\"\n  }</code></pre>"},{"location":"labs/Procs/General/ProjectileModelProc/#input-parameters","title":"Input Parameter(s)","text":"<ul> <li><code>gravity</code>: Gravitational acceleration (m/s\u00b2).</li> <li><code>mass</code>: Mass of the body (kg).</li> </ul>"},{"location":"labs/Procs/General/ProjectileModelProc/#input-paths","title":"Input Path(s)","text":"<ul> <li><code>velocity_file</code>: File containing the velocity initial conditions {v0 (m/s); angle (\u00b0)}.</li> <li><code>configs_folder/</code> <code>solver_config.json</code>: File containing the parameters for solver configuration. <code>display_config.json</code>: File containing the parameters for display configuration.</li> <li><code>coords_file</code>: File containing the X/Y coordinates of the polygonal shape to simulate.</li> </ul>"},{"location":"labs/Procs/General/ProjectileModelProc/#output-paths","title":"Output Path(s)","text":"<ul> <li><code>comp_folder/</code> <code>results.xlsx</code>: File containing simulated (model) and theoritical trajectories. <code>model_vs_theory.png</code>: Image comparing both trajectories.</li> </ul>      View source code"},{"location":"labs/Procs/General/TrajectoryAnalysisProc/","title":"TrajectoryAnalysisProc","text":""},{"location":"labs/Procs/General/TrajectoryAnalysisProc/#process","title":"Process","text":"<p>Perform overall comparisons between simulated (model) and theoretical trajectories. A/ <code>plot_overall_model_vs_theory</code>: Generate overall comparative plots of simulated (model) and theoritical trajectories.</p> <pre><code>erDiagram\n  **Analysis** ||--|| **Inputs** : provides\n  **Inputs** ||--|| **TrajectoryAnalysisProc** : feeds\n  **TrajectoryAnalysisProc** ||--|| **Outputs** : generates\n\n  **Analysis** {\n    folder comp_folder \"_\"\n  }\n  **TrajectoryAnalysisProc** {\n    op plot_overall_model_vs_theory\n  }\n  **Outputs** {\n    file fig_file \"png\"\n  }</code></pre>"},{"location":"labs/Procs/General/TrajectoryAnalysisProc/#input-analysis","title":"Input Analysis","text":"<ul> <li><code>comp_folder/</code> <code>results.xlsx</code>: File containing both trajectories.</li> </ul>"},{"location":"labs/Procs/General/TrajectoryAnalysisProc/#output-paths","title":"Output Path(s)","text":"<ul> <li><code>fig_file</code>: Image containing overall comparative plots.</li> </ul>      View source code"}]}